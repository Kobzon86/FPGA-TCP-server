
tcp_webserver.elf:     file format elf32-littlenios2
tcp_webserver.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00208230

Program Header:
    LOAD off    0x00001000 vaddr 0x00208000 paddr 0x00208000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00208020 paddr 0x00208020 align 2**12
         filesz 0x00005af8 memsz 0x00005af8 flags r-x
    LOAD off    0x00006b18 vaddr 0x0020db18 paddr 0x0020e108 align 2**12
         filesz 0x000005f0 memsz 0x000005f0 flags rw-
    LOAD off    0x000076f8 vaddr 0x0020e6f8 paddr 0x0020e6f8 align 2**12
         filesz 0x00000000 memsz 0x00000d54 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00208000  00208000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000210  00208020  00208020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000055d4  00208230  00208230  00001230  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000314  0020d804  0020d804  00006804  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000005f0  0020db18  0020e108  00006b18  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000d54  0020e6f8  0020e6f8  000076f8  2**2
                  ALLOC, SMALL_DATA
  6 .sram_cntrlr_0 00000000  00000000  00000000  00007108  2**0
                  CONTENTS
  7 .onchip_memory2_0 00000000  0020f44c  0020f44c  00007108  2**0
                  CONTENTS
  8 .descriptor_memory 00000000  00210000  00210000  00007108  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00007108  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000006f0  00000000  00000000  00007130  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0000877d  00000000  00000000  00007820  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00003004  00000000  00000000  0000ff9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000387b  00000000  00000000  00012fa1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001270  00000000  00000000  0001681c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00002857  00000000  00000000  00017a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00000d91  00000000  00000000  0001a2e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000040  00000000  00000000  0001b074  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000200  00000000  00000000  0001b0b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0001d956  2**0
                  CONTENTS, READONLY
 20 .cpu          0000000c  00000000  00000000  0001d959  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0001d965  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0001d966  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   0000000b  00000000  00000000  0001d967  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    0000000b  00000000  00000000  0001d972  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   0000000b  00000000  00000000  0001d97d  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 0000000c  00000000  00000000  0001d988  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001f  00000000  00000000  0001d994  2**0
                  CONTENTS, READONLY
 28 .jdi          000065ee  00000000  00000000  0001d9b3  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     000940a4  00000000  00000000  00023fa1  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00208000 l    d  .entry	00000000 .entry
00208020 l    d  .exceptions	00000000 .exceptions
00208230 l    d  .text	00000000 .text
0020d804 l    d  .rodata	00000000 .rodata
0020db18 l    d  .rwdata	00000000 .rwdata
0020e6f8 l    d  .bss	00000000 .bss
00000000 l    d  .sram_cntrlr_0	00000000 .sram_cntrlr_0
0020f44c l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00210000 l    d  .descriptor_memory	00000000 .descriptor_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../tcp_webserver_bsp//obj/HAL/src/crt0.o
00208268 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 tcp_socket.c
0020e6fc l     O .bss	00000004 secs.3396
00000000 l    df *ABS*	00000000 tcp_webserver.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
0020a0bc l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0020a224 l     F .text	00000034 alt_dev_reg
0020dd84 l     O .rwdata	0000002c jtag_uart_0
0020ddb0 l     O .rwdata	00000030 sgdma_0
0020dde0 l     O .rwdata	00000030 sgdma_1
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
0020e0d0 l     O .rwdata	00000004 colstart
0020a54c l     F .text	000000b8 lcd_write_command
0020a604 l     F .text	000000d8 lcd_write_data
0020a6dc l     F .text	000000e8 lcd_clear_screen
0020a7c4 l     F .text	00000228 lcd_repaint_screen
0020a9ec l     F .text	000000e8 lcd_scroll_up
0020aad4 l     F .text	000002c4 lcd_handle_escape
0020b2b8 l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0020b498 l     F .text	0000003c alt_get_errno
0020c0c8 l     F .text	000000bc alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0020c22c l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0020c44c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0020c5a8 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0020c5d4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0020c8c0 l     F .text	000000e4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0020ca20 l     F .text	0000003c alt_get_errno
0020ca5c l     F .text	000000ec alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 ctype_.c
0020d997 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 impure.c
0020dfb8 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_exit.c
0020e720 g     O .bss	00000004 alt_instruction_exception_handler
0020a1a8 g     F .text	0000007c alt_main
0020893c g     F .text	00000834 rx_ethernet_isr
0020f34c g     O .bss	00000100 alt_irq
0020e108 g       *ABS*	00000000 __flash_rwdata_start
0020b5f8 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
00208768 g     F .text	00000020 check_checksumm
0020bd10 g     F .text	000003b8 alt_avalon_sgdma_construct_descriptor_burst
00209d5c g     F .text	00000060 memmove
0020e70d g     O .bss	00000001 in
0020e0bc g     O .rwdata	00000004 my_ip
0020cefc g     F .text	00000024 altera_nios2_gen2_irq_init
00208000 g     F .entry	0000000c __reset
0020b860 g     F .text	00000078 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00208020 g       *ABS*	00000000 __flash_exceptions_start
00000000 g       *ABS*	00000000 __alt_mem_sram_cntrlr_0
0020e72c g     O .bss	00000004 errno
0020e718 g     O .bss	00000004 alt_argv
00216098 g       *ABS*	00000000 _gp
0020cecc g     F .text	00000030 usleep
0020de38 g     O .rwdata	00000180 alt_fd_list
0020c774 g     F .text	00000090 alt_find_dev
0020d2a8 g     F .text	00000028 memcpy
0020c9a4 g     F .text	0000007c alt_io_redirect
00208664 g     F .text	0000009c check_tcp_sender_ip
0020d804 g       *ABS*	00000000 __DTOR_END__
0020c824 g     F .text	0000009c alt_exception_cause_generated_bad_addr
0020b958 g     F .text	0000008c alt_avalon_sgdma_construct_mem_to_stream_desc_burst
002094fc g     F .text	000001e0 get_tcp_checksumm
0020a3cc g     F .text	000000ec altera_avalon_jtag_uart_read
00208000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
0020d6ec g     F .text	00000064 .hidden __udivsi3
0020e0c8 g     O .rwdata	00000004 tse
0020ba90 g     F .text	0000005c alt_avalon_sgdma_stop
0020e70e g     O .bss	00000001 lcd_string_len
0020c560 g     F .text	00000028 alt_dcache_flush
0020e0ec g     O .rwdata	00000004 alt_max_fd
0020938c g     F .text	0000008c timer_int_en
0020e100 g     O .rwdata	00000004 _global_impure_ptr
00208700 g     F .text	00000068 get_seq_num
0020f44c g       *ABS*	00000000 __bss_end
00209fcc g     F .text	000000f0 alt_iic_isr_register
0020b4d4 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
0020cdc4 g     F .text	00000108 alt_tick
0020e0a4 g     O .rwdata	00000004 rx_descriptor_end
00209f80 g     F .text	0000004c alt_ic_irq_enabled
0020e0ac g     O .rwdata	00000004 arp_recieved
0020e0c0 g     O .rwdata	00000006 my_mac
0020cd28 g     F .text	0000009c alt_alarm_stop
00210000 g       *ABS*	00000000 __alt_mem_descriptor_memory
0020e710 g     O .bss	00000004 alt_irq_active
0020ed1e g     O .bss	000005ee tx_frame
002080fc g     F .exceptions	000000d4 alt_irq_handler
0020de10 g     O .rwdata	00000028 alt_dev_null
0020baec g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
0020c588 g     F .text	00000020 alt_dcache_flush_all
0020e0a0 g     O .rwdata	00000004 rx_descriptor
0020e108 g       *ABS*	00000000 __ram_rwdata_end
0020e0e4 g     O .rwdata	00000008 alt_dev_list
0020bc30 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0020e6f8 g     O .bss	00000001 set_timer_zero
0020db18 g       *ABS*	00000000 __ram_rodata_end
0020d750 g     F .text	00000058 .hidden __umodsi3
0020b8d8 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_stream_desc
0020b9e4 g     F .text	00000054 alt_avalon_sgdma_register_callback
0020f44c g       *ABS*	00000000 end
0020e70f g     O .bss	00000001 leds
0020ad98 g     F .text	00000520 altera_avalon_lcd_16207_write
002081d0 g     F .exceptions	00000060 alt_instruction_exception_entry
0020d804 g       *ABS*	00000000 __CTOR_LIST__
00210000 g       *ABS*	00000000 __alt_stack_pointer
0020bcb0 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
0020c2a4 g     F .text	0000007c alt_avalon_timer_sc_init
0020a4b8 g     F .text	00000094 altera_avalon_jtag_uart_write
0020b708 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_mem_desc
0020b800 g     F .text	00000060 alt_avalon_sgdma_construct_stream_to_mem_desc
0020f30c g     O .bss	00000040 lcd_string
0020d464 g     F .text	00000190 __call_exitprocs
0020828c g     F .text	0000020c tse_init
00208498 g     F .text	00000094 send_packet
00208230 g     F .text	0000003c _start
0020e724 g     O .bss	00000004 _alt_tick_rate
0020e700 g     O .bss	00000004 sgdma_tx_dev
0020bb50 g     F .text	00000054 alt_avalon_sgdma_open
0020e728 g     O .bss	00000004 _alt_nticks
0020a290 g     F .text	0000007c alt_sys_init
0020d30c g     F .text	00000158 __register_exitproc
00208820 g     F .text	0000011c ack_check
00209dbc g     F .text	00000060 strncmp
0020d7a8 g     F .text	00000028 .hidden __mulsi3
0020db18 g       *ABS*	00000000 __ram_rwdata_start
0020d804 g       *ABS*	00000000 __ram_rodata_start
00209170 g     F .text	0000021c timeout_isr
0020a30c g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0020d180 g     F .text	000000c4 alt_get_fd
0020cf20 g     F .text	00000158 alt_busy_sleep
0020d278 g     F .text	00000030 memcmp
0020f44c g       *ABS*	00000000 __alt_stack_base
0020d078 g     F .text	00000108 alt_find_file
0020c610 g     F .text	000000a4 alt_dev_llist_insert
0020ba38 g     F .text	00000058 alt_avalon_sgdma_start
0020852c g     F .text	0000007c sgdma_int_en
0020e6f8 g       *ABS*	00000000 __bss_start
0020d2d0 g     F .text	00000020 memset
002099ac g     F .text	000001a4 main
0020e71c g     O .bss	00000004 alt_envp
0020a36c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0020b364 g     F .text	00000134 altera_avalon_lcd_16207_init
0020e0d4 g     O .rwdata	00000008 alt_sgdma_list
0020e0f0 g     O .rwdata	00000004 alt_errno
0020e098 g     O .rwdata	00000004 tx_descriptor
0020e730 g     O .bss	000005ee rx_frame
0020d5f4 g     F .text	00000084 .hidden __divsi3
0020d804 g       *ABS*	00000000 __CTOR_END__
0020d804 g       *ABS*	00000000 __flash_rodata_start
0020d804 g       *ABS*	00000000 __DTOR_LIST__
0020a258 g     F .text	00000038 alt_irq_init
0020cca4 g     F .text	00000084 alt_release_fd
0020d244 g     F .text	00000014 atexit
00209b50 g     F .text	0000020c get_command
0020e104 g     O .rwdata	00000004 _impure_ptr
0020e714 g     O .bss	00000004 alt_argc
0020c714 g     F .text	00000060 _do_dtors
002085a8 g     F .text	000000bc checkmac
00208020 g       .exceptions	00000000 alt_irq_entry
0020e704 g     O .bss	00000004 TCP
0020e0dc g     O .rwdata	00000008 alt_fs_list
0020e0b4 g     O .rwdata	00000004 tcp_out
00208020 g       *ABS*	00000000 __ram_exceptions_start
00209e1c g     F .text	00000050 alt_ic_isr_register
0020e108 g       *ABS*	00000000 _edata
0020f44c g       *ABS*	00000000 _end
00208230 g       *ABS*	00000000 __ram_exceptions_end
0020db18 g     O .rwdata	0000026c html_page
00209ef4 g     F .text	0000008c alt_ic_irq_disable
0020e09c g     O .rwdata	00000004 tx_descriptor_end
0020e0a8 g     O .rwdata	00000004 arp_packet
0020bba4 g     F .text	0000008c alt_avalon_sgdma_construct_descriptor
0020d258 g     F .text	00000020 exit
0020d678 g     F .text	00000074 .hidden __modsi3
0020e0fc g     O .rwdata	00000004 __ctype_ptr__
002096dc g     F .text	000002d0 create_tcp_pkt
00210000 g       *ABS*	00000000 __alt_data_end
00208020 g     F .exceptions	00000000 alt_exception
0020d896 g     O .rodata	00000101 _ctype_
0020e708 g     O .bss	00000004 sgdma_rx_dev
00208788 g     F .text	00000098 get_payload_len
0020d7d0 g     F .text	00000034 _exit
0020c320 g     F .text	0000012c alt_alarm_start
00209418 g     F .text	000000e4 get_ipv4_checksumm
0020e70c g     O .bss	00000001 lcd_string_changed
0020d2f0 g     F .text	0000001c strlen
0020cb48 g     F .text	0000015c open
0020e0b0 g     O .rwdata	00000004 ipv4_recieved
0020c804 g     F .text	00000020 alt_icache_flush_all
0020e0cc g     O .rwdata	00000004 alt_priority_mask
00209e6c g     F .text	00000088 alt_ic_irq_enable
0020826c g     F .text	00000020 add_phy_to_profile
0020b77c g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0020e0b8 g     O .rwdata	00000004 tcp_recieved
0020e0f4 g     O .rwdata	00000008 alt_alarm_list
0020c6b4 g     F .text	00000060 _do_ctors
0020c488 g     F .text	000000d8 close
0020a124 g     F .text	00000084 alt_load
0020c184 g     F .text	000000a8 alt_avalon_sgdma_init



Disassembly of section .entry:

00208000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  208000:	00400834 	movhi	at,32
    ori r1, r1, %lo(_start)
  208004:	08608c14 	ori	at,at,33328
    jmp r1
  208008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

00208020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  208020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  208024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  208028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  20802c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  208030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  208034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  208038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  20803c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  208040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  208044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  208048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  20804c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  208050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  208054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  208058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  20805c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  208060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  208064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  208068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  20806c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  208070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  208074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  208078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  20807c:	10000326 	beq	r2,zero,20808c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  208080:	20000226 	beq	r4,zero,20808c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  208084:	02080fc0 	call	2080fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  208088:	00000706 	br	2080a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
  20808c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
  208090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
  208094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
  208098:	02081d00 	call	2081d0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
  20809c:	1000021e 	bne	r2,zero,2080a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
  2080a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  2080a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  2080a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  2080ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  2080b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  2080b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  2080b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  2080bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  2080c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  2080c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  2080c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  2080cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  2080d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  2080d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  2080d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  2080dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  2080e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  2080e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  2080e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  2080ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  2080f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  2080f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  2080f8:	ef80083a 	eret

002080fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  2080fc:	defff904 	addi	sp,sp,-28
  208100:	dfc00615 	stw	ra,24(sp)
  208104:	df000515 	stw	fp,20(sp)
  208108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  20810c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  208110:	0005313a 	rdctl	r2,ipending
  208114:	e0bffe15 	stw	r2,-8(fp)

  return active;
  208118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  20811c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  208120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  208124:	00800044 	movi	r2,1
  208128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  20812c:	e0fffb17 	ldw	r3,-20(fp)
  208130:	e0bffc17 	ldw	r2,-16(fp)
  208134:	1884703a 	and	r2,r3,r2
  208138:	10001426 	beq	r2,zero,20818c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  20813c:	00800874 	movhi	r2,33
  208140:	10bcd304 	addi	r2,r2,-3252
  208144:	e0fffd17 	ldw	r3,-12(fp)
  208148:	180690fa 	slli	r3,r3,3
  20814c:	10c5883a 	add	r2,r2,r3
  208150:	10c00017 	ldw	r3,0(r2)
  208154:	00800874 	movhi	r2,33
  208158:	10bcd304 	addi	r2,r2,-3252
  20815c:	e13ffd17 	ldw	r4,-12(fp)
  208160:	200890fa 	slli	r4,r4,3
  208164:	1105883a 	add	r2,r2,r4
  208168:	10800104 	addi	r2,r2,4
  20816c:	10800017 	ldw	r2,0(r2)
  208170:	1009883a 	mov	r4,r2
  208174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  208178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  20817c:	0005313a 	rdctl	r2,ipending
  208180:	e0bfff15 	stw	r2,-4(fp)

  return active;
  208184:	e0bfff17 	ldw	r2,-4(fp)
  208188:	00000706 	br	2081a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
  20818c:	e0bffc17 	ldw	r2,-16(fp)
  208190:	1085883a 	add	r2,r2,r2
  208194:	e0bffc15 	stw	r2,-16(fp)
      i++;
  208198:	e0bffd17 	ldw	r2,-12(fp)
  20819c:	10800044 	addi	r2,r2,1
  2081a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  2081a4:	003fe106 	br	20812c <_gp+0xffff2094>

    active = alt_irq_pending ();
  2081a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  2081ac:	e0bffb17 	ldw	r2,-20(fp)
  2081b0:	103fdb1e 	bne	r2,zero,208120 <_gp+0xffff2088>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  2081b4:	0001883a 	nop
}
  2081b8:	0001883a 	nop
  2081bc:	e037883a 	mov	sp,fp
  2081c0:	dfc00117 	ldw	ra,4(sp)
  2081c4:	df000017 	ldw	fp,0(sp)
  2081c8:	dec00204 	addi	sp,sp,8
  2081cc:	f800283a 	ret

002081d0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
  2081d0:	defffb04 	addi	sp,sp,-20
  2081d4:	dfc00415 	stw	ra,16(sp)
  2081d8:	df000315 	stw	fp,12(sp)
  2081dc:	df000304 	addi	fp,sp,12
  2081e0:	e13fff15 	stw	r4,-4(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  2081e4:	00bfffc4 	movi	r2,-1
  2081e8:	e0bffd15 	stw	r2,-12(fp)
  badaddr = 0;
  2081ec:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
  2081f0:	d0a1a217 	ldw	r2,-31096(gp)
  2081f4:	10000726 	beq	r2,zero,208214 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
  2081f8:	d0a1a217 	ldw	r2,-31096(gp)
  2081fc:	e0fffd17 	ldw	r3,-12(fp)
  208200:	e1bffe17 	ldw	r6,-8(fp)
  208204:	e17fff17 	ldw	r5,-4(fp)
  208208:	1809883a 	mov	r4,r3
  20820c:	103ee83a 	callr	r2
  208210:	00000206 	br	20821c <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
  208214:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
  208218:	0005883a 	mov	r2,zero
}
  20821c:	e037883a 	mov	sp,fp
  208220:	dfc00117 	ldw	ra,4(sp)
  208224:	df000017 	ldw	fp,0(sp)
  208228:	dec00204 	addi	sp,sp,8
  20822c:	f800283a 	ret

Disassembly of section .text:

00208230 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  208230:	06c00874 	movhi	sp,33
    ori sp, sp, %lo(__alt_stack_pointer)
  208234:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
  208238:	06800874 	movhi	gp,33
    ori gp, gp, %lo(_gp)
  20823c:	d6982614 	ori	gp,gp,24728
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  208240:	00800834 	movhi	r2,32
    ori r2, r2, %lo(__bss_start)
  208244:	10b9be14 	ori	r2,r2,59128

    movhi r3, %hi(__bss_end)
  208248:	00c00834 	movhi	r3,32
    ori r3, r3, %lo(__bss_end)
  20824c:	18fd1314 	ori	r3,r3,62540

    beq r2, r3, 1f
  208250:	10c00326 	beq	r2,r3,208260 <_start+0x30>

0:
    stw zero, (r2)
  208254:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  208258:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  20825c:	10fffd36 	bltu	r2,r3,208254 <_gp+0xffff21bc>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  208260:	020a1240 	call	20a124 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  208264:	020a1a80 	call	20a1a8 <alt_main>

00208268 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  208268:	003fff06 	br	208268 <_gp+0xffff21d0>

0020826c <add_phy_to_profile>:
alt_u8 my_ip[4] = { 0xa9, 0xfe, 0xe5, 0x0e }; //my ip = a9.fe.e5.0e = 169.254.229.14
alt_u8 my_mac[6] = {0x60, 0xe3, 0x27, 0x04, 0xd5, 0xe3}; //"\x60\xe3\x27\x04\xd5\xe3"


void add_phy_to_profile()
{
  20826c:	deffff04 	addi	sp,sp,-4
  208270:	df000015 	stw	fp,0(sp)
  208274:	d839883a 	mov	fp,sp
//	                            &marvell_phy_cfg        /* Function pointer to configure Marvell PHY                     */
//	                           };
//
//	/* add supported PHY to profile */
//	alt_tse_phy_add_profile(&MV88E1111);
}
  208278:	0001883a 	nop
  20827c:	e037883a 	mov	sp,fp
  208280:	df000017 	ldw	fp,0(sp)
  208284:	dec00104 	addi	sp,sp,4
  208288:	f800283a 	ret

0020828c <tse_init>:

void tse_init(int *tse, struct tcp_conn * TCP_link){
  20828c:	defffc04 	addi	sp,sp,-16
  208290:	dfc00315 	stw	ra,12(sp)
  208294:	df000215 	stw	fp,8(sp)
  208298:	df000204 	addi	fp,sp,8
  20829c:	e13ffe15 	stw	r4,-8(fp)
  2082a0:	e17fff15 	stw	r5,-4(fp)
	TCP = TCP_link;
  2082a4:	e0bfff17 	ldw	r2,-4(fp)
  2082a8:	d0a19b15 	stw	r2,-31124(gp)
	/*********** Open the sgdma transmit device ********************/
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_0");
  2082ac:	01000874 	movhi	r4,33
  2082b0:	21360104 	addi	r4,r4,-10236
  2082b4:	020bb500 	call	20bb50 <alt_avalon_sgdma_open>
  2082b8:	d0a19a15 	stw	r2,-31128(gp)
	// 	alt_printf ("Error: could not open scatter-gather dma transmit device\n");
	// 	//return -1;
	// } else alt_printf ("Opened scatter-gather dma transmit device\n");

/***********  Open the sgdma receive device *************************/
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/sgdma_1");
  2082bc:	01000874 	movhi	r4,33
  2082c0:	21360504 	addi	r4,r4,-10220
  2082c4:	020bb500 	call	20bb50 <alt_avalon_sgdma_open>
  2082c8:	d0a19c15 	stw	r2,-31120(gp)
	// 	alt_printf ("Error: could not open scatter-gather dma receive device\n");
	// 	//return -1;
	// } else alt_printf ("Opened scatter-gather dma receive device\n");


	add_phy_to_profile();
  2082cc:	020826c0 	call	20826c <add_phy_to_profile>

	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x00;
  2082d0:	e0bffe17 	ldw	r2,-8(fp)
  2082d4:	10800f04 	addi	r2,r2,60
  2082d8:	10000015 	stw	zero,0(r2)

/************ Disable read and write transfers and wait**************************/
	*(tse + 0x02 ) = *(tse + 0x02) | 0x00800220;
  2082dc:	e0bffe17 	ldw	r2,-8(fp)
  2082e0:	10c00204 	addi	r3,r2,8
  2082e4:	e0bffe17 	ldw	r2,-8(fp)
  2082e8:	10800204 	addi	r2,r2,8
  2082ec:	11000017 	ldw	r4,0(r2)
  2082f0:	00802034 	movhi	r2,128
  2082f4:	10808804 	addi	r2,r2,544
  2082f8:	2084b03a 	or	r2,r4,r2
  2082fc:	18800015 	stw	r2,0(r3)
	while ( *(tse + 0x02 ) != ( *(tse + 0x02 ) | 0x00800220 )) {
  208300:	0001883a 	nop
  208304:	e0bffe17 	ldw	r2,-8(fp)
  208308:	10800204 	addi	r2,r2,8
  20830c:	10c00017 	ldw	r3,0(r2)
  208310:	e0bffe17 	ldw	r2,-8(fp)
  208314:	10800204 	addi	r2,r2,8
  208318:	11000017 	ldw	r4,0(r2)
  20831c:	00802034 	movhi	r2,128
  208320:	10808804 	addi	r2,r2,544
  208324:	2084b03a 	or	r2,r4,r2
  208328:	18bff61e 	bne	r3,r2,208304 <_gp+0xffff226c>
		// alt_printf("n0");
	}

/****************MAC FIFO Configuration*****************************************/
	*(tse + 0x09) = ETH_TSE_0_TRANSMIT_FIFO_DEPTH-16;
  20832c:	e0bffe17 	ldw	r2,-8(fp)
  208330:	10800904 	addi	r2,r2,36
  208334:	00c07c04 	movi	r3,496
  208338:	10c00015 	stw	r3,0(r2)
	*(tse + 0x0E) = 3;
  20833c:	e0bffe17 	ldw	r2,-8(fp)
  208340:	10800e04 	addi	r2,r2,56
  208344:	00c000c4 	movi	r3,3
  208348:	10c00015 	stw	r3,0(r2)
	*(tse + 0x0D) = 8;
  20834c:	e0bffe17 	ldw	r2,-8(fp)
  208350:	10800d04 	addi	r2,r2,52
  208354:	00c00204 	movi	r3,8
  208358:	10c00015 	stw	r3,0(r2)
	*(tse + 0x07) = ETH_TSE_0_RECEIVE_FIFO_DEPTH-16;
  20835c:	e0bffe17 	ldw	r2,-8(fp)
  208360:	10800704 	addi	r2,r2,28
  208364:	00c1fc04 	movi	r3,2032
  208368:	10c00015 	stw	r3,0(r2)
	*(tse + 0x0C) = 8;
  20836c:	e0bffe17 	ldw	r2,-8(fp)
  208370:	10800c04 	addi	r2,r2,48
  208374:	00c00204 	movi	r3,8
  208378:	10c00015 	stw	r3,0(r2)
	*(tse + 0x0B) = 8;
  20837c:	e0bffe17 	ldw	r2,-8(fp)
  208380:	10800b04 	addi	r2,r2,44
  208384:	00c00204 	movi	r3,8
  208388:	10c00015 	stw	r3,0(r2)
	*(tse + 0x0A) = 0;
  20838c:	e0bffe17 	ldw	r2,-8(fp)
  208390:	10800a04 	addi	r2,r2,40
  208394:	10000015 	stw	zero,0(r2)
	*(tse + 0x08) = 0;
  208398:	e0bffe17 	ldw	r2,-8(fp)
  20839c:	10800804 	addi	r2,r2,32
  2083a0:	10000015 	stw	zero,0(r2)

/***************** Initialize the MAC address************************************/
	*(tse + 0x03 ) = 0x0427E360; //mac_0
  2083a4:	e0bffe17 	ldw	r2,-8(fp)
  2083a8:	10c00304 	addi	r3,r2,12
  2083ac:	00810a34 	movhi	r2,1064
  2083b0:	10b8d804 	addi	r2,r2,-7328
  2083b4:	18800015 	stw	r2,0(r3)
	*(tse + 0x04) =  0x0000E3D5; //mac_1
  2083b8:	e0bffe17 	ldw	r2,-8(fp)
  2083bc:	10800404 	addi	r2,r2,16
  2083c0:	00f8f554 	movui	r3,58325
  2083c4:	10c00015 	stw	r3,0(r2)
/****************** MAC function configuration**********************************/
	*(tse + 0x05) = 1518 ;
  2083c8:	e0bffe17 	ldw	r2,-8(fp)
  2083cc:	10800504 	addi	r2,r2,20
  2083d0:	00c17b84 	movi	r3,1518
  2083d4:	10c00015 	stw	r3,0(r2)
	*(tse + 0x17) = 12;
  2083d8:	e0bffe17 	ldw	r2,-8(fp)
  2083dc:	10801704 	addi	r2,r2,92
  2083e0:	00c00304 	movi	r3,12
  2083e4:	10c00015 	stw	r3,0(r2)
	*(tse + 0x06 ) = 0xFFFF;
  2083e8:	e0bffe17 	ldw	r2,-8(fp)
  2083ec:	10800604 	addi	r2,r2,24
  2083f0:	00ffffd4 	movui	r3,65535
  2083f4:	10c00015 	stw	r3,0(r2)
	*(tse + 0x02 ) = 0x00800220; //command config
  2083f8:	e0bffe17 	ldw	r2,-8(fp)
  2083fc:	10c00204 	addi	r3,r2,8
  208400:	00802034 	movhi	r2,128
  208404:	10808804 	addi	r2,r2,544
  208408:	18800015 	stw	r2,0(r3)
//
///*************** Software reset the PHY chip and wait***************************/
	*(tse + 0x02  ) =  0x00802220;
  20840c:	e0bffe17 	ldw	r2,-8(fp)
  208410:	10c00204 	addi	r3,r2,8
  208414:	00802034 	movhi	r2,128
  208418:	10888804 	addi	r2,r2,8736
  20841c:	18800015 	stw	r2,0(r3)
	while ( *(tse + 0x02  ) != ( 0x00800220 ) ) {
  208420:	0001883a 	nop
  208424:	e0bffe17 	ldw	r2,-8(fp)
  208428:	10800204 	addi	r2,r2,8
  20842c:	10c00017 	ldw	r3,0(r2)
  208430:	00802034 	movhi	r2,128
  208434:	10808804 	addi	r2,r2,544
  208438:	18bffa1e 	bne	r3,r2,208424 <_gp+0xffff238c>
		// alt_printf("n1");
		}

/*** Enable read and write transfers, gigabit Ethernet operation and promiscuous mode*/

	*(tse + 0x02 ) = 0x0400022B;//*(tse + 0x02 ) | 0x0080023B;
  20843c:	e0bffe17 	ldw	r2,-8(fp)
  208440:	10c00204 	addi	r3,r2,8
  208444:	00810034 	movhi	r2,1024
  208448:	10808ac4 	addi	r2,r2,555
  20844c:	18800015 	stw	r2,0(r3)
	while ( *(tse + 0x02 ) != ( *(tse + 0x02) | 0x0400022B ) ) {
  208450:	0001883a 	nop
  208454:	e0bffe17 	ldw	r2,-8(fp)
  208458:	10800204 	addi	r2,r2,8
  20845c:	10c00017 	ldw	r3,0(r2)
  208460:	e0bffe17 	ldw	r2,-8(fp)
  208464:	10800204 	addi	r2,r2,8
  208468:	11000017 	ldw	r4,0(r2)
  20846c:	00810034 	movhi	r2,1024
  208470:	10808ac4 	addi	r2,r2,555
  208474:	2084b03a 	or	r2,r4,r2
  208478:	18bff61e 	bne	r3,r2,208454 <_gp+0xffff23bc>
		// alt_printf("n2") ;
	}

///**************** Set interrupts for the sgdma receive device , Create sgdma receive descriptor  & Set up non-blocking transfer of sgdma receive descriptor **********/
	sgdma_int_en();
  20847c:	020852c0 	call	20852c <sgdma_int_en>

}
  208480:	0001883a 	nop
  208484:	e037883a 	mov	sp,fp
  208488:	dfc00117 	ldw	ra,4(sp)
  20848c:	df000017 	ldw	fp,0(sp)
  208490:	dec00204 	addi	sp,sp,8
  208494:	f800283a 	ret

00208498 <send_packet>:

void send_packet(alt_u32 * data, int len){
  208498:	defff804 	addi	sp,sp,-32
  20849c:	dfc00715 	stw	ra,28(sp)
  2084a0:	df000615 	stw	fp,24(sp)
  2084a4:	df000604 	addi	fp,sp,24
  2084a8:	e13ffe15 	stw	r4,-8(fp)
  2084ac:	e17fff15 	stw	r5,-4(fp)
	while (alt_avalon_sgdma_check_descriptor_status(tx_descriptor) != 0);
  2084b0:	0001883a 	nop
  2084b4:	d0a00017 	ldw	r2,-32768(gp)
  2084b8:	1009883a 	mov	r4,r2
  2084bc:	020baec0 	call	20baec <alt_avalon_sgdma_check_descriptor_status>
  2084c0:	103ffc1e 	bne	r2,zero,2084b4 <_gp+0xffff241c>
	alt_avalon_sgdma_construct_mem_to_stream_desc(tx_descriptor, tx_descriptor_end, data, len, 0, 1, 1, 0);
  2084c4:	d0e00017 	ldw	r3,-32768(gp)
  2084c8:	d1200117 	ldw	r4,-32764(gp)
  2084cc:	e0bfff17 	ldw	r2,-4(fp)
  2084d0:	117fffcc 	andi	r5,r2,65535
  2084d4:	d8000315 	stw	zero,12(sp)
  2084d8:	00800044 	movi	r2,1
  2084dc:	d8800215 	stw	r2,8(sp)
  2084e0:	00800044 	movi	r2,1
  2084e4:	d8800115 	stw	r2,4(sp)
  2084e8:	d8000015 	stw	zero,0(sp)
  2084ec:	280f883a 	mov	r7,r5
  2084f0:	e1bffe17 	ldw	r6,-8(fp)
  2084f4:	200b883a 	mov	r5,r4
  2084f8:	1809883a 	mov	r4,r3
  2084fc:	020b8d80 	call	20b8d8 <alt_avalon_sgdma_construct_mem_to_stream_desc>
	alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, tx_descriptor );
  208500:	d0a19a17 	ldw	r2,-31128(gp)
  208504:	d0e00017 	ldw	r3,-32768(gp)
  208508:	180b883a 	mov	r5,r3
  20850c:	1009883a 	mov	r4,r2
  208510:	020b4d40 	call	20b4d4 <alt_avalon_sgdma_do_async_transfer>
}
  208514:	0001883a 	nop
  208518:	e037883a 	mov	sp,fp
  20851c:	dfc00117 	ldw	ra,4(sp)
  208520:	df000017 	ldw	fp,0(sp)
  208524:	dec00204 	addi	sp,sp,8
  208528:	f800283a 	ret

0020852c <sgdma_int_en>:

void send_packet(alt_u32 * data, int len);

void sgdma_int_en(){
  20852c:	defffd04 	addi	sp,sp,-12
  208530:	dfc00215 	stw	ra,8(sp)
  208534:	df000115 	stw	fp,4(sp)
  208538:	df000104 	addi	fp,sp,4
	alt_avalon_sgdma_register_callback( sgdma_rx_dev, (alt_avalon_sgdma_callback) rx_ethernet_isr, 0x00000014, NULL );
  20853c:	d0a19c17 	ldw	r2,-31120(gp)
  208540:	000f883a 	mov	r7,zero
  208544:	01800504 	movi	r6,20
  208548:	01400874 	movhi	r5,33
  20854c:	29624f04 	addi	r5,r5,-30404
  208550:	1009883a 	mov	r4,r2
  208554:	020b9e40 	call	20b9e4 <alt_avalon_sgdma_register_callback>
	alt_avalon_sgdma_construct_stream_to_mem_desc( rx_descriptor, rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  208558:	d0a00217 	ldw	r2,-32760(gp)
  20855c:	d0e00317 	ldw	r3,-32756(gp)
  208560:	d8000015 	stw	zero,0(sp)
  208564:	000f883a 	mov	r7,zero
  208568:	01800874 	movhi	r6,33
  20856c:	31b9cc04 	addi	r6,r6,-6352
  208570:	180b883a 	mov	r5,r3
  208574:	1009883a 	mov	r4,r2
  208578:	020b8000 	call	20b800 <alt_avalon_sgdma_construct_stream_to_mem_desc>
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, rx_descriptor );
  20857c:	d0a19c17 	ldw	r2,-31120(gp)
  208580:	d0e00217 	ldw	r3,-32760(gp)
  208584:	180b883a 	mov	r5,r3
  208588:	1009883a 	mov	r4,r2
  20858c:	020b4d40 	call	20b4d4 <alt_avalon_sgdma_do_async_transfer>
}
  208590:	0001883a 	nop
  208594:	e037883a 	mov	sp,fp
  208598:	dfc00117 	ldw	ra,4(sp)
  20859c:	df000017 	ldw	fp,0(sp)
  2085a0:	dec00204 	addi	sp,sp,8
  2085a4:	f800283a 	ret

002085a8 <checkmac>:



bool checkmac(ipv4_header  * ipv4_recieved){
  2085a8:	defffe04 	addi	sp,sp,-8
  2085ac:	df000115 	stw	fp,4(sp)
  2085b0:	df000104 	addi	fp,sp,4
  2085b4:	e13fff15 	stw	r4,-4(fp)
	if( ipv4_recieved->eth_flds.dest_addr[0] == my_mac[0] &&
  2085b8:	e0bfff17 	ldw	r2,-4(fp)
  2085bc:	10c00003 	ldbu	r3,0(r2)
  2085c0:	d0a00a03 	ldbu	r2,-32728(gp)
  2085c4:	18c03fcc 	andi	r3,r3,255
  2085c8:	10803fcc 	andi	r2,r2,255
  2085cc:	1880201e 	bne	r3,r2,208650 <checkmac+0xa8>
		ipv4_recieved->eth_flds.dest_addr[1] == my_mac[1] &&
  2085d0:	e0bfff17 	ldw	r2,-4(fp)
  2085d4:	10c00043 	ldbu	r3,1(r2)
  2085d8:	d0a00a43 	ldbu	r2,-32727(gp)
}



bool checkmac(ipv4_header  * ipv4_recieved){
	if( ipv4_recieved->eth_flds.dest_addr[0] == my_mac[0] &&
  2085dc:	18c03fcc 	andi	r3,r3,255
  2085e0:	10803fcc 	andi	r2,r2,255
  2085e4:	18801a1e 	bne	r3,r2,208650 <checkmac+0xa8>
		ipv4_recieved->eth_flds.dest_addr[1] == my_mac[1] &&
		ipv4_recieved->eth_flds.dest_addr[2] == my_mac[2] &&
  2085e8:	e0bfff17 	ldw	r2,-4(fp)
  2085ec:	10c00083 	ldbu	r3,2(r2)
  2085f0:	d0a00a83 	ldbu	r2,-32726(gp)



bool checkmac(ipv4_header  * ipv4_recieved){
	if( ipv4_recieved->eth_flds.dest_addr[0] == my_mac[0] &&
		ipv4_recieved->eth_flds.dest_addr[1] == my_mac[1] &&
  2085f4:	18c03fcc 	andi	r3,r3,255
  2085f8:	10803fcc 	andi	r2,r2,255
  2085fc:	1880141e 	bne	r3,r2,208650 <checkmac+0xa8>
		ipv4_recieved->eth_flds.dest_addr[2] == my_mac[2] &&
		ipv4_recieved->eth_flds.dest_addr[3] == my_mac[3] &&
  208600:	e0bfff17 	ldw	r2,-4(fp)
  208604:	10c000c3 	ldbu	r3,3(r2)
  208608:	d0a00ac3 	ldbu	r2,-32725(gp)


bool checkmac(ipv4_header  * ipv4_recieved){
	if( ipv4_recieved->eth_flds.dest_addr[0] == my_mac[0] &&
		ipv4_recieved->eth_flds.dest_addr[1] == my_mac[1] &&
		ipv4_recieved->eth_flds.dest_addr[2] == my_mac[2] &&
  20860c:	18c03fcc 	andi	r3,r3,255
  208610:	10803fcc 	andi	r2,r2,255
  208614:	18800e1e 	bne	r3,r2,208650 <checkmac+0xa8>
		ipv4_recieved->eth_flds.dest_addr[3] == my_mac[3] &&
		ipv4_recieved->eth_flds.dest_addr[4] == my_mac[4] &&
  208618:	e0bfff17 	ldw	r2,-4(fp)
  20861c:	10c00103 	ldbu	r3,4(r2)
  208620:	d0a00b03 	ldbu	r2,-32724(gp)

bool checkmac(ipv4_header  * ipv4_recieved){
	if( ipv4_recieved->eth_flds.dest_addr[0] == my_mac[0] &&
		ipv4_recieved->eth_flds.dest_addr[1] == my_mac[1] &&
		ipv4_recieved->eth_flds.dest_addr[2] == my_mac[2] &&
		ipv4_recieved->eth_flds.dest_addr[3] == my_mac[3] &&
  208624:	18c03fcc 	andi	r3,r3,255
  208628:	10803fcc 	andi	r2,r2,255
  20862c:	1880081e 	bne	r3,r2,208650 <checkmac+0xa8>
		ipv4_recieved->eth_flds.dest_addr[4] == my_mac[4] &&
		ipv4_recieved->eth_flds.dest_addr[5] == my_mac[5])
  208630:	e0bfff17 	ldw	r2,-4(fp)
  208634:	10c00143 	ldbu	r3,5(r2)
  208638:	d0a00b43 	ldbu	r2,-32723(gp)
bool checkmac(ipv4_header  * ipv4_recieved){
	if( ipv4_recieved->eth_flds.dest_addr[0] == my_mac[0] &&
		ipv4_recieved->eth_flds.dest_addr[1] == my_mac[1] &&
		ipv4_recieved->eth_flds.dest_addr[2] == my_mac[2] &&
		ipv4_recieved->eth_flds.dest_addr[3] == my_mac[3] &&
		ipv4_recieved->eth_flds.dest_addr[4] == my_mac[4] &&
  20863c:	18c03fcc 	andi	r3,r3,255
  208640:	10803fcc 	andi	r2,r2,255
  208644:	1880021e 	bne	r3,r2,208650 <checkmac+0xa8>
		ipv4_recieved->eth_flds.dest_addr[5] == my_mac[5])
		return true;
  208648:	00800044 	movi	r2,1
  20864c:	00000106 	br	208654 <checkmac+0xac>
	else
		return false;
  208650:	0005883a 	mov	r2,zero
}
  208654:	e037883a 	mov	sp,fp
  208658:	df000017 	ldw	fp,0(sp)
  20865c:	dec00104 	addi	sp,sp,4
  208660:	f800283a 	ret

00208664 <check_tcp_sender_ip>:

bool check_tcp_sender_ip(ipv4_header  * ipv4_recieved){
  208664:	defffe04 	addi	sp,sp,-8
  208668:	df000115 	stw	fp,4(sp)
  20866c:	df000104 	addi	fp,sp,4
  208670:	e13fff15 	stw	r4,-4(fp)
	if( ipv4_recieved->sender_ip[0] == TCP->dest_ip[0] &&
  208674:	e0bfff17 	ldw	r2,-4(fp)
  208678:	10c00683 	ldbu	r3,26(r2)
  20867c:	d0a19b17 	ldw	r2,-31124(gp)
  208680:	10800443 	ldbu	r2,17(r2)
  208684:	18c03fcc 	andi	r3,r3,255
  208688:	10803fcc 	andi	r2,r2,255
  20868c:	1880171e 	bne	r3,r2,2086ec <check_tcp_sender_ip+0x88>
		ipv4_recieved->sender_ip[1] == TCP->dest_ip[1] &&
  208690:	e0bfff17 	ldw	r2,-4(fp)
  208694:	10c006c3 	ldbu	r3,27(r2)
  208698:	d0a19b17 	ldw	r2,-31124(gp)
  20869c:	10800483 	ldbu	r2,18(r2)
	else
		return false;
}

bool check_tcp_sender_ip(ipv4_header  * ipv4_recieved){
	if( ipv4_recieved->sender_ip[0] == TCP->dest_ip[0] &&
  2086a0:	18c03fcc 	andi	r3,r3,255
  2086a4:	10803fcc 	andi	r2,r2,255
  2086a8:	1880101e 	bne	r3,r2,2086ec <check_tcp_sender_ip+0x88>
		ipv4_recieved->sender_ip[1] == TCP->dest_ip[1] &&
		ipv4_recieved->sender_ip[2] == TCP->dest_ip[2] &&
  2086ac:	e0bfff17 	ldw	r2,-4(fp)
  2086b0:	10c00703 	ldbu	r3,28(r2)
  2086b4:	d0a19b17 	ldw	r2,-31124(gp)
  2086b8:	108004c3 	ldbu	r2,19(r2)
		return false;
}

bool check_tcp_sender_ip(ipv4_header  * ipv4_recieved){
	if( ipv4_recieved->sender_ip[0] == TCP->dest_ip[0] &&
		ipv4_recieved->sender_ip[1] == TCP->dest_ip[1] &&
  2086bc:	18c03fcc 	andi	r3,r3,255
  2086c0:	10803fcc 	andi	r2,r2,255
  2086c4:	1880091e 	bne	r3,r2,2086ec <check_tcp_sender_ip+0x88>
		ipv4_recieved->sender_ip[2] == TCP->dest_ip[2] &&
		ipv4_recieved->sender_ip[3] == TCP->dest_ip[3] )
  2086c8:	e0bfff17 	ldw	r2,-4(fp)
  2086cc:	10c00743 	ldbu	r3,29(r2)
  2086d0:	d0a19b17 	ldw	r2,-31124(gp)
  2086d4:	10800503 	ldbu	r2,20(r2)
}

bool check_tcp_sender_ip(ipv4_header  * ipv4_recieved){
	if( ipv4_recieved->sender_ip[0] == TCP->dest_ip[0] &&
		ipv4_recieved->sender_ip[1] == TCP->dest_ip[1] &&
		ipv4_recieved->sender_ip[2] == TCP->dest_ip[2] &&
  2086d8:	18c03fcc 	andi	r3,r3,255
  2086dc:	10803fcc 	andi	r2,r2,255
  2086e0:	1880021e 	bne	r3,r2,2086ec <check_tcp_sender_ip+0x88>
		ipv4_recieved->sender_ip[3] == TCP->dest_ip[3] )
		return true;
  2086e4:	00800044 	movi	r2,1
  2086e8:	00000106 	br	2086f0 <check_tcp_sender_ip+0x8c>
	else
		return false;
  2086ec:	0005883a 	mov	r2,zero
}
  2086f0:	e037883a 	mov	sp,fp
  2086f4:	df000017 	ldw	fp,0(sp)
  2086f8:	dec00104 	addi	sp,sp,4
  2086fc:	f800283a 	ret

00208700 <get_seq_num>:

alt_u32 get_seq_num(tcp_packet * tcp_recieved){
  208700:	defffe04 	addi	sp,sp,-8
  208704:	df000115 	stw	fp,4(sp)
  208708:	df000104 	addi	fp,sp,4
  20870c:	e13fff15 	stw	r4,-4(fp)
	return tcp_recieved->seq_num[0]<<24 | tcp_recieved->seq_num[1]<<16 | tcp_recieved->seq_num[2]<<8  | tcp_recieved->seq_num[3];
  208710:	e0bfff17 	ldw	r2,-4(fp)
  208714:	10800103 	ldbu	r2,4(r2)
  208718:	10803fcc 	andi	r2,r2,255
  20871c:	1006963a 	slli	r3,r2,24
  208720:	e0bfff17 	ldw	r2,-4(fp)
  208724:	10800143 	ldbu	r2,5(r2)
  208728:	10803fcc 	andi	r2,r2,255
  20872c:	1004943a 	slli	r2,r2,16
  208730:	1886b03a 	or	r3,r3,r2
  208734:	e0bfff17 	ldw	r2,-4(fp)
  208738:	10800183 	ldbu	r2,6(r2)
  20873c:	10803fcc 	andi	r2,r2,255
  208740:	1004923a 	slli	r2,r2,8
  208744:	1886b03a 	or	r3,r3,r2
  208748:	e0bfff17 	ldw	r2,-4(fp)
  20874c:	108001c3 	ldbu	r2,7(r2)
  208750:	10803fcc 	andi	r2,r2,255
  208754:	1884b03a 	or	r2,r3,r2
}
  208758:	e037883a 	mov	sp,fp
  20875c:	df000017 	ldw	fp,0(sp)
  208760:	dec00104 	addi	sp,sp,4
  208764:	f800283a 	ret

00208768 <check_checksumm>:

bool check_checksumm(){
  208768:	deffff04 	addi	sp,sp,-4
  20876c:	df000015 	stw	fp,0(sp)
  208770:	d839883a 	mov	fp,sp
	/* dog in - dog out*/
	return true;
  208774:	00800044 	movi	r2,1
};
  208778:	e037883a 	mov	sp,fp
  20877c:	df000017 	ldw	fp,0(sp)
  208780:	dec00104 	addi	sp,sp,4
  208784:	f800283a 	ret

00208788 <get_payload_len>:

alt_u32 get_payload_len(){
  208788:	defffe04 	addi	sp,sp,-8
  20878c:	df000115 	stw	fp,4(sp)
  208790:	df000104 	addi	fp,sp,4
	alt_u32 ip_len = ipv4_recieved->total_len[1] + (ipv4_recieved->total_len[0]<<8);
  208794:	d0a00617 	ldw	r2,-32744(gp)
  208798:	10800443 	ldbu	r2,17(r2)
  20879c:	10c03fcc 	andi	r3,r2,255
  2087a0:	d0a00617 	ldw	r2,-32744(gp)
  2087a4:	10800403 	ldbu	r2,16(r2)
  2087a8:	10803fcc 	andi	r2,r2,255
  2087ac:	1004923a 	slli	r2,r2,8
  2087b0:	1885883a 	add	r2,r3,r2
  2087b4:	e0bfff15 	stw	r2,-4(fp)
	ip_len -=  (tcp_recieved->header_len>>4) * 4;
  2087b8:	d0a00817 	ldw	r2,-32736(gp)
  2087bc:	10800303 	ldbu	r2,12(r2)
  2087c0:	10803fcc 	andi	r2,r2,255
  2087c4:	1004d13a 	srli	r2,r2,4
  2087c8:	10803fcc 	andi	r2,r2,255
  2087cc:	1085883a 	add	r2,r2,r2
  2087d0:	1085883a 	add	r2,r2,r2
  2087d4:	1007883a 	mov	r3,r2
  2087d8:	e0bfff17 	ldw	r2,-4(fp)
  2087dc:	10c5c83a 	sub	r2,r2,r3
  2087e0:	e0bfff15 	stw	r2,-4(fp)
	ip_len -=  (ipv4_recieved->ver_ihl&0xf) * 4;
  2087e4:	d0a00617 	ldw	r2,-32744(gp)
  2087e8:	10800383 	ldbu	r2,14(r2)
  2087ec:	10803fcc 	andi	r2,r2,255
  2087f0:	108003cc 	andi	r2,r2,15
  2087f4:	1085883a 	add	r2,r2,r2
  2087f8:	1085883a 	add	r2,r2,r2
  2087fc:	1007883a 	mov	r3,r2
  208800:	e0bfff17 	ldw	r2,-4(fp)
  208804:	10c5c83a 	sub	r2,r2,r3
  208808:	e0bfff15 	stw	r2,-4(fp)
	return ip_len;
  20880c:	e0bfff17 	ldw	r2,-4(fp)
}
  208810:	e037883a 	mov	sp,fp
  208814:	df000017 	ldw	fp,0(sp)
  208818:	dec00104 	addi	sp,sp,4
  20881c:	f800283a 	ret

00208820 <ack_check>:



void ack_check(){
  208820:	defffe04 	addi	sp,sp,-8
  208824:	df000115 	stw	fp,4(sp)
  208828:	df000104 	addi	fp,sp,4
	if(tcp_recieved->flags.ack){
  20882c:	d0a00817 	ldw	r2,-32736(gp)
  208830:	1080030b 	ldhu	r2,12(r2)
  208834:	1084000c 	andi	r2,r2,4096
  208838:	10bfffcc 	andi	r2,r2,65535
  20883c:	10003826 	beq	r2,zero,208920 <ack_check+0x100>
		alt_u32 acked_num = tcp_recieved->ack_num[0]<<24 | tcp_recieved->ack_num[1]<<16 | tcp_recieved->ack_num[2]<<8  | tcp_recieved->ack_num[3];
  208840:	d0a00817 	ldw	r2,-32736(gp)
  208844:	10800203 	ldbu	r2,8(r2)
  208848:	10803fcc 	andi	r2,r2,255
  20884c:	1006963a 	slli	r3,r2,24
  208850:	d0a00817 	ldw	r2,-32736(gp)
  208854:	10800243 	ldbu	r2,9(r2)
  208858:	10803fcc 	andi	r2,r2,255
  20885c:	1004943a 	slli	r2,r2,16
  208860:	1886b03a 	or	r3,r3,r2
  208864:	d0a00817 	ldw	r2,-32736(gp)
  208868:	10800283 	ldbu	r2,10(r2)
  20886c:	10803fcc 	andi	r2,r2,255
  208870:	1004923a 	slli	r2,r2,8
  208874:	1886b03a 	or	r3,r3,r2
  208878:	d0a00817 	ldw	r2,-32736(gp)
  20887c:	108002c3 	ldbu	r2,11(r2)
  208880:	10803fcc 	andi	r2,r2,255
  208884:	1884b03a 	or	r2,r3,r2
  208888:	e0bfff15 	stw	r2,-4(fp)
		if(acked_num == ( TCP->last_acked + TCP->last_sended_len + 1 )){
  20888c:	d0a19b17 	ldw	r2,-31124(gp)
  208890:	10c00817 	ldw	r3,32(r2)
  208894:	d0a19b17 	ldw	r2,-31124(gp)
  208898:	1080090b 	ldhu	r2,36(r2)
  20889c:	10bfffcc 	andi	r2,r2,65535
  2088a0:	1885883a 	add	r2,r3,r2
  2088a4:	10c00044 	addi	r3,r2,1
  2088a8:	e0bfff17 	ldw	r2,-4(fp)
  2088ac:	1880191e 	bne	r3,r2,208914 <ack_check+0xf4>
			if(TCP->last_sended_len != 0)
  2088b0:	d0a19b17 	ldw	r2,-31124(gp)
  2088b4:	1080090b 	ldhu	r2,36(r2)
  2088b8:	10bfffcc 	andi	r2,r2,65535
  2088bc:	10000926 	beq	r2,zero,2088e4 <ack_check+0xc4>
				TCP->last_acked += TCP->last_sended_len + 1;
  2088c0:	d0a19b17 	ldw	r2,-31124(gp)
  2088c4:	d0e19b17 	ldw	r3,-31124(gp)
  2088c8:	19000817 	ldw	r4,32(r3)
  2088cc:	d0e19b17 	ldw	r3,-31124(gp)
  2088d0:	18c0090b 	ldhu	r3,36(r3)
  2088d4:	18ffffcc 	andi	r3,r3,65535
  2088d8:	20c7883a 	add	r3,r4,r3
  2088dc:	18c00044 	addi	r3,r3,1
  2088e0:	10c00815 	stw	r3,32(r2)
			TCP->last_acked += TCP->command_sent;
  2088e4:	d0a19b17 	ldw	r2,-31124(gp)
  2088e8:	d0e19b17 	ldw	r3,-31124(gp)
  2088ec:	19000817 	ldw	r4,32(r3)
  2088f0:	d0e19b17 	ldw	r3,-31124(gp)
  2088f4:	18c00ac3 	ldbu	r3,43(r3)
  2088f8:	18c03fcc 	andi	r3,r3,255
  2088fc:	20c7883a 	add	r3,r4,r3
  208900:	10c00815 	stw	r3,32(r2)
			TCP->acked = true;
  208904:	d0a19b17 	ldw	r2,-31124(gp)
  208908:	00c00044 	movi	r3,1
  20890c:	10c00a85 	stb	r3,42(r2)
		else
			TCP->acked = false;
	}
	else
			TCP->acked = false;
}
  208910:	00000506 	br	208928 <ack_check+0x108>
				TCP->last_acked += TCP->last_sended_len + 1;
			TCP->last_acked += TCP->command_sent;
			TCP->acked = true;
		}
		else
			TCP->acked = false;
  208914:	d0a19b17 	ldw	r2,-31124(gp)
  208918:	10000a85 	stb	zero,42(r2)
	}
	else
			TCP->acked = false;
}
  20891c:	00000206 	br	208928 <ack_check+0x108>
		}
		else
			TCP->acked = false;
	}
	else
			TCP->acked = false;
  208920:	d0a19b17 	ldw	r2,-31124(gp)
  208924:	10000a85 	stb	zero,42(r2)
}
  208928:	0001883a 	nop
  20892c:	e037883a 	mov	sp,fp
  208930:	df000017 	ldw	fp,0(sp)
  208934:	dec00104 	addi	sp,sp,4
  208938:	f800283a 	ret

0020893c <rx_ethernet_isr>:
 * Subroutine to read incoming Ethernet frames  *
****************************************************************************************/
bool set_timer_zero = false;

void rx_ethernet_isr (void *context)
{
  20893c:	defff804 	addi	sp,sp,-32
  208940:	dfc00715 	stw	ra,28(sp)
  208944:	df000615 	stw	fp,24(sp)
  208948:	dc000515 	stw	r16,20(sp)
  20894c:	df000604 	addi	fp,sp,24
  208950:	e13ffe15 	stw	r4,-8(fp)

	///Check if ARP
	if( arp_recieved->eth_flds.type == 0x0608 ){
  208954:	d0a00517 	ldw	r2,-32748(gp)
  208958:	1080030b 	ldhu	r2,12(r2)
  20895c:	10bfffcc 	andi	r2,r2,65535
  208960:	10818218 	cmpnei	r2,r2,1544
  208964:	1000651e 	bne	r2,zero,208afc <rx_ethernet_isr+0x1c0>
		if( arp_recieved->target_ip[0] == my_ip[0] && arp_recieved->target_ip[1] == my_ip[1] && arp_recieved->target_ip[2] == my_ip[2] && arp_recieved->target_ip[3] == my_ip[3]){
  208968:	d0a00517 	ldw	r2,-32748(gp)
  20896c:	10c00983 	ldbu	r3,38(r2)
  208970:	d0a00903 	ldbu	r2,-32732(gp)
  208974:	18c03fcc 	andi	r3,r3,255
  208978:	10803fcc 	andi	r2,r2,255
  20897c:	18805f1e 	bne	r3,r2,208afc <rx_ethernet_isr+0x1c0>
  208980:	d0a00517 	ldw	r2,-32748(gp)
  208984:	10c009c3 	ldbu	r3,39(r2)
  208988:	d0a00943 	ldbu	r2,-32731(gp)
  20898c:	18c03fcc 	andi	r3,r3,255
  208990:	10803fcc 	andi	r2,r2,255
  208994:	1880591e 	bne	r3,r2,208afc <rx_ethernet_isr+0x1c0>
  208998:	d0a00517 	ldw	r2,-32748(gp)
  20899c:	10c00a03 	ldbu	r3,40(r2)
  2089a0:	d0a00983 	ldbu	r2,-32730(gp)
  2089a4:	18c03fcc 	andi	r3,r3,255
  2089a8:	10803fcc 	andi	r2,r2,255
  2089ac:	1880531e 	bne	r3,r2,208afc <rx_ethernet_isr+0x1c0>
  2089b0:	d0a00517 	ldw	r2,-32748(gp)
  2089b4:	10c00a43 	ldbu	r3,41(r2)
  2089b8:	d0a009c3 	ldbu	r2,-32729(gp)
  2089bc:	18c03fcc 	andi	r3,r3,255
  2089c0:	10803fcc 	andi	r2,r2,255
  2089c4:	18804d1e 	bne	r3,r2,208afc <rx_ethernet_isr+0x1c0>
			arp_packet->eth_flds.dest_addr[0] = arp_recieved->sender_hard_addr[0];
  2089c8:	d0a00417 	ldw	r2,-32752(gp)
  2089cc:	d0e00517 	ldw	r3,-32748(gp)
  2089d0:	18c00583 	ldbu	r3,22(r3)
  2089d4:	10c00005 	stb	r3,0(r2)
			arp_packet->eth_flds.dest_addr[1] = arp_recieved->sender_hard_addr[1];
  2089d8:	d0a00417 	ldw	r2,-32752(gp)
  2089dc:	d0e00517 	ldw	r3,-32748(gp)
  2089e0:	18c005c3 	ldbu	r3,23(r3)
  2089e4:	10c00045 	stb	r3,1(r2)
			arp_packet->eth_flds.dest_addr[2] = arp_recieved->sender_hard_addr[2];
  2089e8:	d0a00417 	ldw	r2,-32752(gp)
  2089ec:	d0e00517 	ldw	r3,-32748(gp)
  2089f0:	18c00603 	ldbu	r3,24(r3)
  2089f4:	10c00085 	stb	r3,2(r2)
			arp_packet->eth_flds.dest_addr[3] = arp_recieved->sender_hard_addr[3];
  2089f8:	d0a00417 	ldw	r2,-32752(gp)
  2089fc:	d0e00517 	ldw	r3,-32748(gp)
  208a00:	18c00643 	ldbu	r3,25(r3)
  208a04:	10c000c5 	stb	r3,3(r2)
			arp_packet->eth_flds.dest_addr[4] = arp_recieved->sender_hard_addr[4];
  208a08:	d0a00417 	ldw	r2,-32752(gp)
  208a0c:	d0e00517 	ldw	r3,-32748(gp)
  208a10:	18c00683 	ldbu	r3,26(r3)
  208a14:	10c00105 	stb	r3,4(r2)
			arp_packet->eth_flds.dest_addr[5] = arp_recieved->sender_hard_addr[5];
  208a18:	d0a00417 	ldw	r2,-32752(gp)
  208a1c:	d0e00517 	ldw	r3,-32748(gp)
  208a20:	18c006c3 	ldbu	r3,27(r3)
  208a24:	10c00145 	stb	r3,5(r2)


			memmove(arp_packet->eth_flds.source_addr,my_mac,6);
  208a28:	d0a00417 	ldw	r2,-32752(gp)
  208a2c:	10800184 	addi	r2,r2,6
  208a30:	01800184 	movi	r6,6
  208a34:	d1600a04 	addi	r5,gp,-32728
  208a38:	1009883a 	mov	r4,r2
  208a3c:	0209d5c0 	call	209d5c <memmove>
			arp_packet->eth_flds.type  = 0x0608;
  208a40:	d0a00417 	ldw	r2,-32752(gp)
  208a44:	00c18204 	movi	r3,1544
  208a48:	10c0030d 	sth	r3,12(r2)
			arp_packet->htype = 0x0100;
  208a4c:	d0a00417 	ldw	r2,-32752(gp)
  208a50:	00c04004 	movi	r3,256
  208a54:	10c0038d 	sth	r3,14(r2)
			arp_packet->ptype = 0x0008;
  208a58:	d0a00417 	ldw	r2,-32752(gp)
  208a5c:	00c00204 	movi	r3,8
  208a60:	10c0040d 	sth	r3,16(r2)
			arp_packet->hlen_plen = 0x0406;
  208a64:	d0a00417 	ldw	r2,-32752(gp)
  208a68:	00c10184 	movi	r3,1030
  208a6c:	10c0048d 	sth	r3,18(r2)
			arp_packet->oper = 0x0200;
  208a70:	d0a00417 	ldw	r2,-32752(gp)
  208a74:	00c08004 	movi	r3,512
  208a78:	10c0050d 	sth	r3,20(r2)
			memmove(arp_packet->sender_hard_addr,my_mac,6);
  208a7c:	d0a00417 	ldw	r2,-32752(gp)
  208a80:	10800584 	addi	r2,r2,22
  208a84:	01800184 	movi	r6,6
  208a88:	d1600a04 	addi	r5,gp,-32728
  208a8c:	1009883a 	mov	r4,r2
  208a90:	0209d5c0 	call	209d5c <memmove>
			memmove(arp_packet->sender_ip, my_ip, 4);
  208a94:	d0a00417 	ldw	r2,-32752(gp)
  208a98:	10800704 	addi	r2,r2,28
  208a9c:	01800104 	movi	r6,4
  208aa0:	d1600904 	addi	r5,gp,-32732
  208aa4:	1009883a 	mov	r4,r2
  208aa8:	0209d5c0 	call	209d5c <memmove>
			memmove(arp_packet->target_hard_addr,arp_recieved->sender_hard_addr,6);
  208aac:	d0a00417 	ldw	r2,-32752(gp)
  208ab0:	10c00804 	addi	r3,r2,32
  208ab4:	d0a00517 	ldw	r2,-32748(gp)
  208ab8:	10800584 	addi	r2,r2,22
  208abc:	01800184 	movi	r6,6
  208ac0:	100b883a 	mov	r5,r2
  208ac4:	1809883a 	mov	r4,r3
  208ac8:	0209d5c0 	call	209d5c <memmove>
			memmove(arp_packet->target_ip, arp_recieved->sender_ip, 4);
  208acc:	d0a00417 	ldw	r2,-32752(gp)
  208ad0:	10c00984 	addi	r3,r2,38
  208ad4:	d0a00517 	ldw	r2,-32748(gp)
  208ad8:	10800704 	addi	r2,r2,28
  208adc:	01800104 	movi	r6,4
  208ae0:	100b883a 	mov	r5,r2
  208ae4:	1809883a 	mov	r4,r3
  208ae8:	0209d5c0 	call	209d5c <memmove>
			send_packet( (alt_u32 *)tx_frame, 44);
  208aec:	01400b04 	movi	r5,44
  208af0:	01000874 	movhi	r4,33
  208af4:	213b4784 	addi	r4,r4,-4834
  208af8:	02084980 	call	208498 <send_packet>
		}
	}

	if( ipv4_recieved->eth_flds.type == 0x0008 && ipv4_recieved->protocol == 0x06){ // if ip-packet and TCP
  208afc:	d0a00617 	ldw	r2,-32744(gp)
  208b00:	1080030b 	ldhu	r2,12(r2)
  208b04:	10bfffcc 	andi	r2,r2,65535
  208b08:	10800218 	cmpnei	r2,r2,8
  208b0c:	10017e1e 	bne	r2,zero,209108 <rx_ethernet_isr+0x7cc>
  208b10:	d0a00617 	ldw	r2,-32744(gp)
  208b14:	108005c3 	ldbu	r2,23(r2)
  208b18:	10803fcc 	andi	r2,r2,255
  208b1c:	10800198 	cmpnei	r2,r2,6
  208b20:	1001791e 	bne	r2,zero,209108 <rx_ethernet_isr+0x7cc>

		if( checkmac(ipv4_recieved) && check_checksumm(ipv4_recieved) ){
  208b24:	d0a00617 	ldw	r2,-32744(gp)
  208b28:	1009883a 	mov	r4,r2
  208b2c:	02085a80 	call	2085a8 <checkmac>
  208b30:	10803fcc 	andi	r2,r2,255
  208b34:	10017426 	beq	r2,zero,209108 <rx_ethernet_isr+0x7cc>
  208b38:	d0a00617 	ldw	r2,-32744(gp)
  208b3c:	1009883a 	mov	r4,r2
  208b40:	02087680 	call	208768 <check_checksumm>
  208b44:	10803fcc 	andi	r2,r2,255
  208b48:	10016f26 	beq	r2,zero,209108 <rx_ethernet_isr+0x7cc>
			int tcp_start_point = (ipv4_recieved->ver_ihl&0xf) * 4 + 14;
  208b4c:	d0a00617 	ldw	r2,-32744(gp)
  208b50:	10800383 	ldbu	r2,14(r2)
  208b54:	10803fcc 	andi	r2,r2,255
  208b58:	108003cc 	andi	r2,r2,15
  208b5c:	1085883a 	add	r2,r2,r2
  208b60:	1085883a 	add	r2,r2,r2
  208b64:	10800384 	addi	r2,r2,14
  208b68:	e0bffb15 	stw	r2,-20(fp)
			tcp_recieved = (int)ipv4_recieved + tcp_start_point;
  208b6c:	d0a00617 	ldw	r2,-32744(gp)
  208b70:	1007883a 	mov	r3,r2
  208b74:	e0bffb17 	ldw	r2,-20(fp)
  208b78:	1885883a 	add	r2,r3,r2
  208b7c:	d0a00815 	stw	r2,-32736(gp)
			if (tcp_recieved->destination_port == 0x5000) // port = 80
  208b80:	d0a00817 	ldw	r2,-32736(gp)
  208b84:	1080008b 	ldhu	r2,2(r2)
  208b88:	10bfffcc 	andi	r2,r2,65535
  208b8c:	10940018 	cmpnei	r2,r2,20480
  208b90:	10015d1e 	bne	r2,zero,209108 <rx_ethernet_isr+0x7cc>
			{
				switch (TCP->state)
  208b94:	d0a19b17 	ldw	r2,-31124(gp)
  208b98:	10800017 	ldw	r2,0(r2)
  208b9c:	10c002e8 	cmpgeui	r3,r2,11
  208ba0:	18014e1e 	bne	r3,zero,2090dc <rx_ethernet_isr+0x7a0>
  208ba4:	100690ba 	slli	r3,r2,2
  208ba8:	00800874 	movhi	r2,33
  208bac:	10a2ef04 	addi	r2,r2,-29764
  208bb0:	1885883a 	add	r2,r3,r2
  208bb4:	10800017 	ldw	r2,0(r2)
  208bb8:	1000683a 	jmp	r2
  208bbc:	002090dc 	xori	zero,zero,33347
  208bc0:	002090dc 	xori	zero,zero,33347
  208bc4:	00208be8 	cmpgeui	zero,zero,33327
  208bc8:	002090dc 	xori	zero,zero,33347
  208bcc:	00208d04 	movi	zero,-32204
  208bd0:	00208d74 	movhi	zero,33333
  208bd4:	002090dc 	xori	zero,zero,33347
  208bd8:	00209054 	movui	zero,33345
  208bdc:	00208f84 	movi	zero,-32194
  208be0:	002090dc 	xori	zero,zero,33347
  208be4:	002090dc 	xori	zero,zero,33347
				{
				case LISTEN:
					TCP->command_sent = false;
  208be8:	d0a19b17 	ldw	r2,-31124(gp)
  208bec:	10000ac5 	stb	zero,43(r2)
					if(tcp_recieved->flags.syn){
  208bf0:	d0a00817 	ldw	r2,-32736(gp)
  208bf4:	1080030b 	ldhu	r2,12(r2)
  208bf8:	1080800c 	andi	r2,r2,512
  208bfc:	10bfffcc 	andi	r2,r2,65535
  208c00:	10013826 	beq	r2,zero,2090e4 <rx_ethernet_isr+0x7a8>
						memmove(TCP->dest_mac,ipv4_recieved->eth_flds.source_addr,6);
  208c04:	d0a19b17 	ldw	r2,-31124(gp)
  208c08:	10c00144 	addi	r3,r2,5
  208c0c:	d0a00617 	ldw	r2,-32744(gp)
  208c10:	10800184 	addi	r2,r2,6
  208c14:	01800184 	movi	r6,6
  208c18:	100b883a 	mov	r5,r2
  208c1c:	1809883a 	mov	r4,r3
  208c20:	0209d5c0 	call	209d5c <memmove>
						TCP->dest_port = tcp_recieved->sender_port;
  208c24:	d0a19b17 	ldw	r2,-31124(gp)
  208c28:	d0e00817 	ldw	r3,-32736(gp)
  208c2c:	18c0000b 	ldhu	r3,0(r3)
  208c30:	10c0060d 	sth	r3,24(r2)
						memmove(TCP->dest_ip, ipv4_recieved->sender_ip, 4);
  208c34:	d0a19b17 	ldw	r2,-31124(gp)
  208c38:	10c00444 	addi	r3,r2,17
  208c3c:	d0a00617 	ldw	r2,-32744(gp)
  208c40:	10800684 	addi	r2,r2,26
  208c44:	01800104 	movi	r6,4
  208c48:	100b883a 	mov	r5,r2
  208c4c:	1809883a 	mov	r4,r3
  208c50:	0209d5c0 	call	209d5c <memmove>
						TCP->seq_num = get_seq_num(tcp_recieved);
  208c54:	d4219b17 	ldw	r16,-31124(gp)
  208c58:	d0a00817 	ldw	r2,-32736(gp)
  208c5c:	1009883a 	mov	r4,r2
  208c60:	02087000 	call	208700 <get_seq_num>
  208c64:	80800715 	stw	r2,28(r16)
						TCP->rec_payload_len = get_payload_len();
  208c68:	d4219b17 	ldw	r16,-31124(gp)
  208c6c:	02087880 	call	208788 <get_payload_len>
  208c70:	80800a0d 	sth	r2,40(r16)
						TCP->window = tcp_recieved->window;
  208c74:	d0a19b17 	ldw	r2,-31124(gp)
  208c78:	d0e00817 	ldw	r3,-32736(gp)
  208c7c:	18c0038b 	ldhu	r3,14(r3)
  208c80:	10c0098d 	sth	r3,38(r2)
						TCP->last_acked = 0x13370000;
  208c84:	d0a19b17 	ldw	r2,-31124(gp)
  208c88:	00c4cdf4 	movhi	r3,4919
  208c8c:	10c00815 	stw	r3,32(r2)
						memmove(TCP->payload, tcp_recieved->payload,24);
  208c90:	d0a19b17 	ldw	r2,-31124(gp)
  208c94:	10c00b44 	addi	r3,r2,45
  208c98:	d0a00817 	ldw	r2,-32736(gp)
  208c9c:	10800504 	addi	r2,r2,20
  208ca0:	01800604 	movi	r6,24
  208ca4:	100b883a 	mov	r5,r2
  208ca8:	1809883a 	mov	r4,r3
  208cac:	0209d5c0 	call	209d5c <memmove>
						create_tcp_pkt(0x12, TCP->payload, 32, 12);
  208cb0:	d0a19b17 	ldw	r2,-31124(gp)
  208cb4:	10800b44 	addi	r2,r2,45
  208cb8:	01c00304 	movi	r7,12
  208cbc:	01800804 	movi	r6,32
  208cc0:	100b883a 	mov	r5,r2
  208cc4:	01000484 	movi	r4,18
  208cc8:	02096dc0 	call	2096dc <create_tcp_pkt>
						TCP->last_sended_len = 0;
  208ccc:	d0a19b17 	ldw	r2,-31124(gp)
  208cd0:	1000090d 	sth	zero,36(r2)
						send_packet( (alt_u32 *)tx_frame, 66 + 2);
  208cd4:	01401104 	movi	r5,68
  208cd8:	01000874 	movhi	r4,33
  208cdc:	213b4784 	addi	r4,r4,-4834
  208ce0:	02084980 	call	208498 <send_packet>
						TCP->state = SYN_RECEIVED;
  208ce4:	d0a19b17 	ldw	r2,-31124(gp)
  208ce8:	00c00104 	movi	r3,4
  208cec:	10c00015 	stw	r3,0(r2)
						IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
  208cf0:	00c001c4 	movi	r3,7
  208cf4:	00800874 	movhi	r2,33
  208cf8:	10892104 	addi	r2,r2,9348
  208cfc:	10c00035 	stwio	r3,0(r2)

					}
					break;
  208d00:	0000f806 	br	2090e4 <rx_ethernet_isr+0x7a8>
				case SYN_RECEIVED:
					if(tcp_recieved->flags.ack){
  208d04:	d0a00817 	ldw	r2,-32736(gp)
  208d08:	1080030b 	ldhu	r2,12(r2)
  208d0c:	1084000c 	andi	r2,r2,4096
  208d10:	10bfffcc 	andi	r2,r2,65535
  208d14:	1000f526 	beq	r2,zero,2090ec <rx_ethernet_isr+0x7b0>
						if( check_tcp_sender_ip( ipv4_recieved ) ){
  208d18:	d0a00617 	ldw	r2,-32744(gp)
  208d1c:	1009883a 	mov	r4,r2
  208d20:	02086640 	call	208664 <check_tcp_sender_ip>
  208d24:	10803fcc 	andi	r2,r2,255
  208d28:	1000f026 	beq	r2,zero,2090ec <rx_ethernet_isr+0x7b0>
							if(TCP->dest_port == tcp_recieved->sender_port){
  208d2c:	d0a19b17 	ldw	r2,-31124(gp)
  208d30:	10c0060b 	ldhu	r3,24(r2)
  208d34:	d0a00817 	ldw	r2,-32736(gp)
  208d38:	1080000b 	ldhu	r2,0(r2)
  208d3c:	18ffffcc 	andi	r3,r3,65535
  208d40:	10bfffcc 	andi	r2,r2,65535
  208d44:	1880e91e 	bne	r3,r2,2090ec <rx_ethernet_isr+0x7b0>
								ack_check();
  208d48:	02088200 	call	208820 <ack_check>
								if(TCP->acked){
  208d4c:	d0a19b17 	ldw	r2,-31124(gp)
  208d50:	10800a83 	ldbu	r2,42(r2)
  208d54:	10803fcc 	andi	r2,r2,255
  208d58:	1000e426 	beq	r2,zero,2090ec <rx_ethernet_isr+0x7b0>
									TCP->state = ESTABLISHED;
  208d5c:	d0a19b17 	ldw	r2,-31124(gp)
  208d60:	00c00144 	movi	r3,5
  208d64:	10c00015 	stw	r3,0(r2)
									set_timer_zero = true;
  208d68:	00800044 	movi	r2,1
  208d6c:	d0a19805 	stb	r2,-31136(gp)
								}
							}
						}
					}
					break;
  208d70:	0000de06 	br	2090ec <rx_ethernet_isr+0x7b0>
				case ESTABLISHED:
					if(tcp_recieved->flags.ack){
  208d74:	d0a00817 	ldw	r2,-32736(gp)
  208d78:	1080030b 	ldhu	r2,12(r2)
  208d7c:	1084000c 	andi	r2,r2,4096
  208d80:	10bfffcc 	andi	r2,r2,65535
  208d84:	1000db26 	beq	r2,zero,2090f4 <rx_ethernet_isr+0x7b8>
						if( check_tcp_sender_ip( ipv4_recieved ) ){
  208d88:	d0a00617 	ldw	r2,-32744(gp)
  208d8c:	1009883a 	mov	r4,r2
  208d90:	02086640 	call	208664 <check_tcp_sender_ip>
  208d94:	10803fcc 	andi	r2,r2,255
  208d98:	1000d626 	beq	r2,zero,2090f4 <rx_ethernet_isr+0x7b8>
							if(TCP->dest_port == tcp_recieved->sender_port){
  208d9c:	d0a19b17 	ldw	r2,-31124(gp)
  208da0:	10c0060b 	ldhu	r3,24(r2)
  208da4:	d0a00817 	ldw	r2,-32736(gp)
  208da8:	1080000b 	ldhu	r2,0(r2)
  208dac:	18ffffcc 	andi	r3,r3,65535
  208db0:	10bfffcc 	andi	r2,r2,65535
  208db4:	1880cf1e 	bne	r3,r2,2090f4 <rx_ethernet_isr+0x7b8>
								ack_check();
  208db8:	02088200 	call	208820 <ack_check>
								TCP->seq_num = get_seq_num(tcp_recieved);
  208dbc:	d4219b17 	ldw	r16,-31124(gp)
  208dc0:	d0a00817 	ldw	r2,-32736(gp)
  208dc4:	1009883a 	mov	r4,r2
  208dc8:	02087000 	call	208700 <get_seq_num>
  208dcc:	80800715 	stw	r2,28(r16)
								TCP->rec_payload_len = get_payload_len();
  208dd0:	d4219b17 	ldw	r16,-31124(gp)
  208dd4:	02087880 	call	208788 <get_payload_len>
  208dd8:	80800a0d 	sth	r2,40(r16)
								if(TCP->acked){
  208ddc:	d0a19b17 	ldw	r2,-31124(gp)
  208de0:	10800a83 	ldbu	r2,42(r2)
  208de4:	10803fcc 	andi	r2,r2,255
  208de8:	1000c226 	beq	r2,zero,2090f4 <rx_ethernet_isr+0x7b8>
									set_timer_zero = true;
  208dec:	00800044 	movi	r2,1
  208df0:	d0a19805 	stb	r2,-31136(gp)
									if(TCP->rec_payload_len > 1){
  208df4:	d0a19b17 	ldw	r2,-31124(gp)
  208df8:	10800a0b 	ldhu	r2,40(r2)
  208dfc:	10bfffcc 	andi	r2,r2,65535
  208e00:	108000b0 	cmpltui	r2,r2,2
  208e04:	1000391e 	bne	r2,zero,208eec <rx_ethernet_isr+0x5b0>
										char message[3];
										char ref_message[] = "GET";
  208e08:	008011c4 	movi	r2,71
  208e0c:	e0bffcc5 	stb	r2,-13(fp)
  208e10:	00801144 	movi	r2,69
  208e14:	e0bffd05 	stb	r2,-12(fp)
  208e18:	00801504 	movi	r2,84
  208e1c:	e0bffd45 	stb	r2,-11(fp)
  208e20:	e03ffd85 	stb	zero,-10(fp)
										memmove(message, tcp_recieved->payload, 3);
  208e24:	d0a00817 	ldw	r2,-32736(gp)
  208e28:	10c00504 	addi	r3,r2,20
  208e2c:	e0bffc04 	addi	r2,fp,-16
  208e30:	018000c4 	movi	r6,3
  208e34:	180b883a 	mov	r5,r3
  208e38:	1009883a 	mov	r4,r2
  208e3c:	0209d5c0 	call	209d5c <memmove>
										if(strncmp(message, ref_message, sizeof(message)) == 0){
  208e40:	e0fffcc4 	addi	r3,fp,-13
  208e44:	e0bffc04 	addi	r2,fp,-16
  208e48:	018000c4 	movi	r6,3
  208e4c:	180b883a 	mov	r5,r3
  208e50:	1009883a 	mov	r4,r2
  208e54:	0209dbc0 	call	209dbc <strncmp>
  208e58:	1000241e 	bne	r2,zero,208eec <rx_ethernet_isr+0x5b0>
											TCP->window = tcp_recieved->window;
  208e5c:	d0a19b17 	ldw	r2,-31124(gp)
  208e60:	d0e00817 	ldw	r3,-32736(gp)
  208e64:	18c0038b 	ldhu	r3,14(r3)
  208e68:	10c0098d 	sth	r3,38(r2)
											create_tcp_pkt(0x11, html_page, 20, HTML_PAGE_LEN);
  208e6c:	01c09ac4 	movi	r7,619
  208e70:	01800504 	movi	r6,20
  208e74:	01400874 	movhi	r5,33
  208e78:	2976c604 	addi	r5,r5,-9448
  208e7c:	01000444 	movi	r4,17
  208e80:	02096dc0 	call	2096dc <create_tcp_pkt>
											TCP->last_sended_len = HTML_PAGE_LEN;
  208e84:	d0a19b17 	ldw	r2,-31124(gp)
  208e88:	00c09ac4 	movi	r3,619
  208e8c:	10c0090d 	sth	r3,36(r2)
											send_packet( (alt_u32 *)tx_frame, 54 + TCP->last_sended_len + 2);
  208e90:	d0a19b17 	ldw	r2,-31124(gp)
  208e94:	1080090b 	ldhu	r2,36(r2)
  208e98:	10bfffcc 	andi	r2,r2,65535
  208e9c:	10800e04 	addi	r2,r2,56
  208ea0:	100b883a 	mov	r5,r2
  208ea4:	01000874 	movhi	r4,33
  208ea8:	213b4784 	addi	r4,r4,-4834
  208eac:	02084980 	call	208498 <send_packet>
											TCP->state = FIN_WAIT;
  208eb0:	d0a19b17 	ldw	r2,-31124(gp)
  208eb4:	00c00204 	movi	r3,8
  208eb8:	10c00015 	stw	r3,0(r2)
											memmove(TCP->payload, tcp_recieved->payload,64);
  208ebc:	d0a19b17 	ldw	r2,-31124(gp)
  208ec0:	10c00b44 	addi	r3,r2,45
  208ec4:	d0a00817 	ldw	r2,-32736(gp)
  208ec8:	10800504 	addi	r2,r2,20
  208ecc:	01801004 	movi	r6,64
  208ed0:	100b883a 	mov	r5,r2
  208ed4:	1809883a 	mov	r4,r3
  208ed8:	0209d5c0 	call	209d5c <memmove>
											TCP->got_html_req = true;
  208edc:	d0a19b17 	ldw	r2,-31124(gp)
  208ee0:	00c00044 	movi	r3,1
  208ee4:	10c00b05 	stb	r3,44(r2)
  208ee8:	00008706 	br	209108 <rx_ethernet_isr+0x7cc>
											break;
										}
									}

									if(tcp_recieved->flags.fin){
  208eec:	d0a00817 	ldw	r2,-32736(gp)
  208ef0:	1080030b 	ldhu	r2,12(r2)
  208ef4:	1080400c 	andi	r2,r2,256
  208ef8:	10bfffcc 	andi	r2,r2,65535
  208efc:	10001326 	beq	r2,zero,208f4c <rx_ethernet_isr+0x610>
										TCP->last_acked++;
  208f00:	d0a19b17 	ldw	r2,-31124(gp)
  208f04:	10c00817 	ldw	r3,32(r2)
  208f08:	18c00044 	addi	r3,r3,1
  208f0c:	10c00815 	stw	r3,32(r2)
										create_tcp_pkt(0x11, TCP->payload, 20, 0);
  208f10:	d0a19b17 	ldw	r2,-31124(gp)
  208f14:	10800b44 	addi	r2,r2,45
  208f18:	000f883a 	mov	r7,zero
  208f1c:	01800504 	movi	r6,20
  208f20:	100b883a 	mov	r5,r2
  208f24:	01000444 	movi	r4,17
  208f28:	02096dc0 	call	2096dc <create_tcp_pkt>
										send_packet( (alt_u32 *)tx_frame, 54 + 2);
  208f2c:	01400e04 	movi	r5,56
  208f30:	01000874 	movhi	r4,33
  208f34:	213b4784 	addi	r4,r4,-4834
  208f38:	02084980 	call	208498 <send_packet>
										TCP->state = LAST_ACK;//CLOSE_WAIT
  208f3c:	d0a19b17 	ldw	r2,-31124(gp)
  208f40:	00c001c4 	movi	r3,7
  208f44:	10c00015 	stw	r3,0(r2)

							}
						}
					}

					break;
  208f48:	00006a06 	br	2090f4 <rx_ethernet_isr+0x7b8>
										create_tcp_pkt(0x11, TCP->payload, 20, 0);
										send_packet( (alt_u32 *)tx_frame, 54 + 2);
										TCP->state = LAST_ACK;//CLOSE_WAIT
									}
									else{
										create_tcp_pkt(0x10, TCP->payload, 20, 0);
  208f4c:	d0a19b17 	ldw	r2,-31124(gp)
  208f50:	10800b44 	addi	r2,r2,45
  208f54:	000f883a 	mov	r7,zero
  208f58:	01800504 	movi	r6,20
  208f5c:	100b883a 	mov	r5,r2
  208f60:	01000404 	movi	r4,16
  208f64:	02096dc0 	call	2096dc <create_tcp_pkt>
										TCP->last_sended_len = 0;
  208f68:	d0a19b17 	ldw	r2,-31124(gp)
  208f6c:	1000090d 	sth	zero,36(r2)
										send_packet( (alt_u32 *)tx_frame, 54 + 2);
  208f70:	01400e04 	movi	r5,56
  208f74:	01000874 	movhi	r4,33
  208f78:	213b4784 	addi	r4,r4,-4834
  208f7c:	02084980 	call	208498 <send_packet>

							}
						}
					}

					break;
  208f80:	00005c06 	br	2090f4 <rx_ethernet_isr+0x7b8>
				case FIN_WAIT:
					if(tcp_recieved->flags.ack && tcp_recieved->flags.fin){
  208f84:	d0a00817 	ldw	r2,-32736(gp)
  208f88:	1080030b 	ldhu	r2,12(r2)
  208f8c:	1084000c 	andi	r2,r2,4096
  208f90:	10bfffcc 	andi	r2,r2,65535
  208f94:	10005926 	beq	r2,zero,2090fc <rx_ethernet_isr+0x7c0>
  208f98:	d0a00817 	ldw	r2,-32736(gp)
  208f9c:	1080030b 	ldhu	r2,12(r2)
  208fa0:	1080400c 	andi	r2,r2,256
  208fa4:	10bfffcc 	andi	r2,r2,65535
  208fa8:	10005426 	beq	r2,zero,2090fc <rx_ethernet_isr+0x7c0>
						if( check_tcp_sender_ip( ipv4_recieved ) ){
  208fac:	d0a00617 	ldw	r2,-32744(gp)
  208fb0:	1009883a 	mov	r4,r2
  208fb4:	02086640 	call	208664 <check_tcp_sender_ip>
  208fb8:	10803fcc 	andi	r2,r2,255
  208fbc:	10004f26 	beq	r2,zero,2090fc <rx_ethernet_isr+0x7c0>
							if(TCP->dest_port == tcp_recieved->sender_port){
  208fc0:	d0a19b17 	ldw	r2,-31124(gp)
  208fc4:	10c0060b 	ldhu	r3,24(r2)
  208fc8:	d0a00817 	ldw	r2,-32736(gp)
  208fcc:	1080000b 	ldhu	r2,0(r2)
  208fd0:	18ffffcc 	andi	r3,r3,65535
  208fd4:	10bfffcc 	andi	r2,r2,65535
  208fd8:	1880481e 	bne	r3,r2,2090fc <rx_ethernet_isr+0x7c0>
								TCP->seq_num = get_seq_num(tcp_recieved);
  208fdc:	d4219b17 	ldw	r16,-31124(gp)
  208fe0:	d0a00817 	ldw	r2,-32736(gp)
  208fe4:	1009883a 	mov	r4,r2
  208fe8:	02087000 	call	208700 <get_seq_num>
  208fec:	80800715 	stw	r2,28(r16)
								TCP->rec_payload_len = get_payload_len();
  208ff0:	d4219b17 	ldw	r16,-31124(gp)
  208ff4:	02087880 	call	208788 <get_payload_len>
  208ff8:	80800a0d 	sth	r2,40(r16)
								ack_check();
  208ffc:	02088200 	call	208820 <ack_check>
								if(TCP->acked){
  209000:	d0a19b17 	ldw	r2,-31124(gp)
  209004:	10800a83 	ldbu	r2,42(r2)
  209008:	10803fcc 	andi	r2,r2,255
  20900c:	10003b26 	beq	r2,zero,2090fc <rx_ethernet_isr+0x7c0>
									create_tcp_pkt(0x10, TCP->payload, 20, 0);
  209010:	d0a19b17 	ldw	r2,-31124(gp)
  209014:	10800b44 	addi	r2,r2,45
  209018:	000f883a 	mov	r7,zero
  20901c:	01800504 	movi	r6,20
  209020:	100b883a 	mov	r5,r2
  209024:	01000404 	movi	r4,16
  209028:	02096dc0 	call	2096dc <create_tcp_pkt>
									TCP->last_sended_len = 0;
  20902c:	d0a19b17 	ldw	r2,-31124(gp)
  209030:	1000090d 	sth	zero,36(r2)
									send_packet( (alt_u32 *)tx_frame, 54 + 2);
  209034:	01400e04 	movi	r5,56
  209038:	01000874 	movhi	r4,33
  20903c:	213b4784 	addi	r4,r4,-4834
  209040:	02084980 	call	208498 <send_packet>
									// TCP.state = TIME_WAIT;
										TCP->state = LISTEN;
  209044:	d0a19b17 	ldw	r2,-31124(gp)
  209048:	00c00084 	movi	r3,2
  20904c:	10c00015 	stw	r3,0(r2)
								}
							}
						}
					}
					break;
  209050:	00002a06 	br	2090fc <rx_ethernet_isr+0x7c0>
				case CLOSE_WAIT:
					break;
				case TIME_WAIT:
					break;
				case LAST_ACK:
					if(tcp_recieved->flags.ack ){
  209054:	d0a00817 	ldw	r2,-32736(gp)
  209058:	1080030b 	ldhu	r2,12(r2)
  20905c:	1084000c 	andi	r2,r2,4096
  209060:	10bfffcc 	andi	r2,r2,65535
  209064:	10002726 	beq	r2,zero,209104 <rx_ethernet_isr+0x7c8>
						if( check_tcp_sender_ip( ipv4_recieved ) ){
  209068:	d0a00617 	ldw	r2,-32744(gp)
  20906c:	1009883a 	mov	r4,r2
  209070:	02086640 	call	208664 <check_tcp_sender_ip>
  209074:	10803fcc 	andi	r2,r2,255
  209078:	10002226 	beq	r2,zero,209104 <rx_ethernet_isr+0x7c8>
							if(TCP->dest_port == tcp_recieved->sender_port){
  20907c:	d0a19b17 	ldw	r2,-31124(gp)
  209080:	10c0060b 	ldhu	r3,24(r2)
  209084:	d0a00817 	ldw	r2,-32736(gp)
  209088:	1080000b 	ldhu	r2,0(r2)
  20908c:	18ffffcc 	andi	r3,r3,65535
  209090:	10bfffcc 	andi	r2,r2,65535
  209094:	18801b1e 	bne	r3,r2,209104 <rx_ethernet_isr+0x7c8>
								TCP->seq_num = get_seq_num(tcp_recieved);
  209098:	d4219b17 	ldw	r16,-31124(gp)
  20909c:	d0a00817 	ldw	r2,-32736(gp)
  2090a0:	1009883a 	mov	r4,r2
  2090a4:	02087000 	call	208700 <get_seq_num>
  2090a8:	80800715 	stw	r2,28(r16)
								TCP->rec_payload_len = get_payload_len();
  2090ac:	d4219b17 	ldw	r16,-31124(gp)
  2090b0:	02087880 	call	208788 <get_payload_len>
  2090b4:	80800a0d 	sth	r2,40(r16)
								ack_check();
  2090b8:	02088200 	call	208820 <ack_check>
								if(TCP->acked){
  2090bc:	d0a19b17 	ldw	r2,-31124(gp)
  2090c0:	10800a83 	ldbu	r2,42(r2)
  2090c4:	10803fcc 	andi	r2,r2,255
  2090c8:	10000e26 	beq	r2,zero,209104 <rx_ethernet_isr+0x7c8>
									TCP->state = LISTEN;
  2090cc:	d0a19b17 	ldw	r2,-31124(gp)
  2090d0:	00c00084 	movi	r3,2
  2090d4:	10c00015 	stw	r3,0(r2)
								}
							}
						}
					}
					break;
  2090d8:	00000a06 	br	209104 <rx_ethernet_isr+0x7c8>

				default:
					break;
  2090dc:	0001883a 	nop
  2090e0:	00000906 	br	209108 <rx_ethernet_isr+0x7cc>
						send_packet( (alt_u32 *)tx_frame, 66 + 2);
						TCP->state = SYN_RECEIVED;
						IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);

					}
					break;
  2090e4:	0001883a 	nop
  2090e8:	00000706 	br	209108 <rx_ethernet_isr+0x7cc>
									set_timer_zero = true;
								}
							}
						}
					}
					break;
  2090ec:	0001883a 	nop
  2090f0:	00000506 	br	209108 <rx_ethernet_isr+0x7cc>

							}
						}
					}

					break;
  2090f4:	0001883a 	nop
  2090f8:	00000306 	br	209108 <rx_ethernet_isr+0x7cc>
										TCP->state = LISTEN;
								}
							}
						}
					}
					break;
  2090fc:	0001883a 	nop
  209100:	00000106 	br	209108 <rx_ethernet_isr+0x7cc>
									TCP->state = LISTEN;
								}
							}
						}
					}
					break;
  209104:	0001883a 	nop

		}
	}

	// Wait until receive descriptor transfer is complete
	while (alt_avalon_sgdma_check_descriptor_status(rx_descriptor) != 0);
  209108:	0001883a 	nop
  20910c:	d0a00217 	ldw	r2,-32760(gp)
  209110:	1009883a 	mov	r4,r2
  209114:	020baec0 	call	20baec <alt_avalon_sgdma_check_descriptor_status>
  209118:	103ffc1e 	bne	r2,zero,20910c <_gp+0xffff3074>
	// Create new receive sgdma descriptor
	alt_avalon_sgdma_construct_stream_to_mem_desc( rx_descriptor, rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  20911c:	d0a00217 	ldw	r2,-32760(gp)
  209120:	d0e00317 	ldw	r3,-32756(gp)
  209124:	d8000015 	stw	zero,0(sp)
  209128:	000f883a 	mov	r7,zero
  20912c:	01800874 	movhi	r6,33
  209130:	31b9cc04 	addi	r6,r6,-6352
  209134:	180b883a 	mov	r5,r3
  209138:	1009883a 	mov	r4,r2
  20913c:	020b8000 	call	20b800 <alt_avalon_sgdma_construct_stream_to_mem_desc>
	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, rx_descriptor );
  209140:	d0a19c17 	ldw	r2,-31120(gp)
  209144:	d0e00217 	ldw	r3,-32760(gp)
  209148:	180b883a 	mov	r5,r3
  20914c:	1009883a 	mov	r4,r2
  209150:	020b4d40 	call	20b4d4 <alt_avalon_sgdma_do_async_transfer>

}
  209154:	0001883a 	nop
  209158:	e6ffff04 	addi	sp,fp,-4
  20915c:	dfc00217 	ldw	ra,8(sp)
  209160:	df000117 	ldw	fp,4(sp)
  209164:	dc000017 	ldw	r16,0(sp)
  209168:	dec00304 	addi	sp,sp,12
  20916c:	f800283a 	ret

00209170 <timeout_isr>:

void timeout_isr (timer_struct * tmr)
{
  209170:	defffd04 	addi	sp,sp,-12
  209174:	dfc00215 	stw	ra,8(sp)
  209178:	df000115 	stw	fp,4(sp)
  20917c:	df000104 	addi	fp,sp,4
  209180:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE, 0);
  209184:	0007883a 	mov	r3,zero
  209188:	00800874 	movhi	r2,33
  20918c:	10892004 	addi	r2,r2,9344
  209190:	10c00035 	stwio	r3,0(r2)

	static int secs=0;

	if(tmr->set_timer_zero == true){
  209194:	e0bfff17 	ldw	r2,-4(fp)
  209198:	10800303 	ldbu	r2,12(r2)
  20919c:	10803fcc 	andi	r2,r2,255
  2091a0:	10000326 	beq	r2,zero,2091b0 <timeout_isr+0x40>
		secs = 0;
  2091a4:	d0219915 	stw	zero,-31132(gp)
		tmr->set_timer_zero = false;
  2091a8:	e0bfff17 	ldw	r2,-4(fp)
  2091ac:	10000305 	stb	zero,12(r2)
	}

	switch (TCP->state)
  2091b0:	d0a19b17 	ldw	r2,-31124(gp)
  2091b4:	10800017 	ldw	r2,0(r2)
  2091b8:	10c00160 	cmpeqi	r3,r2,5
  2091bc:	18000a1e 	bne	r3,zero,2091e8 <timeout_isr+0x78>
  2091c0:	10c001a8 	cmpgeui	r3,r2,6
  2091c4:	1800031e 	bne	r3,zero,2091d4 <timeout_isr+0x64>
  2091c8:	10800120 	cmpeqi	r2,r2,4
  2091cc:	1000271e 	bne	r2,zero,20926c <timeout_isr+0xfc>
  2091d0:	00005906 	br	209338 <timeout_isr+0x1c8>
  2091d4:	10c001e0 	cmpeqi	r3,r2,7
  2091d8:	1800461e 	bne	r3,zero,2092f4 <timeout_isr+0x184>
  2091dc:	10800220 	cmpeqi	r2,r2,8
  2091e0:	1000331e 	bne	r2,zero,2092b0 <timeout_isr+0x140>
  2091e4:	00005406 	br	209338 <timeout_isr+0x1c8>
	{
	case ESTABLISHED:
		if( ++secs == 10){
  2091e8:	d0a19917 	ldw	r2,-31132(gp)
  2091ec:	10800044 	addi	r2,r2,1
  2091f0:	d0a19915 	stw	r2,-31132(gp)
  2091f4:	d0a19917 	ldw	r2,-31132(gp)
  2091f8:	10800298 	cmpnei	r2,r2,10
  2091fc:	1000561e 	bne	r2,zero,209358 <timeout_isr+0x1e8>
			TCP->seq_num--;
  209200:	d0a19b17 	ldw	r2,-31124(gp)
  209204:	10c00717 	ldw	r3,28(r2)
  209208:	18ffffc4 	addi	r3,r3,-1
  20920c:	10c00715 	stw	r3,28(r2)
			TCP->last_acked++;
  209210:	d0a19b17 	ldw	r2,-31124(gp)
  209214:	10c00817 	ldw	r3,32(r2)
  209218:	18c00044 	addi	r3,r3,1
  20921c:	10c00815 	stw	r3,32(r2)
			create_tcp_pkt(0x11, TCP->payload, 20, 0);
  209220:	d0a19b17 	ldw	r2,-31124(gp)
  209224:	10800b44 	addi	r2,r2,45
  209228:	000f883a 	mov	r7,zero
  20922c:	01800504 	movi	r6,20
  209230:	100b883a 	mov	r5,r2
  209234:	01000444 	movi	r4,17
  209238:	02096dc0 	call	2096dc <create_tcp_pkt>
			send_packet( (alt_u32 *)tx_frame, 54 + 2);
  20923c:	01400e04 	movi	r5,56
  209240:	01000874 	movhi	r4,33
  209244:	213b4784 	addi	r4,r4,-4834
  209248:	02084980 	call	208498 <send_packet>
			TCP->state = FIN_WAIT;
  20924c:	d0a19b17 	ldw	r2,-31124(gp)
  209250:	00c00204 	movi	r3,8
  209254:	10c00015 	stw	r3,0(r2)
			TCP->command_sent = true;
  209258:	d0a19b17 	ldw	r2,-31124(gp)
  20925c:	00c00044 	movi	r3,1
  209260:	10c00ac5 	stb	r3,43(r2)
			secs = 0;
  209264:	d0219915 	stw	zero,-31132(gp)
		}

		break;
  209268:	00003b06 	br	209358 <timeout_isr+0x1e8>
	case SYN_RECEIVED:
		if( ++secs == 60){
  20926c:	d0a19917 	ldw	r2,-31132(gp)
  209270:	10800044 	addi	r2,r2,1
  209274:	d0a19915 	stw	r2,-31132(gp)
  209278:	d0a19917 	ldw	r2,-31132(gp)
  20927c:	10800f18 	cmpnei	r2,r2,60
  209280:	1000371e 	bne	r2,zero,209360 <timeout_isr+0x1f0>
			TCP->state = LISTEN;
  209284:	d0a19b17 	ldw	r2,-31124(gp)
  209288:	00c00084 	movi	r3,2
  20928c:	10c00015 	stw	r3,0(r2)
			IOWR_ALTERA_AVALON_TIMER_CONTROL(tmr->base, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_STOP_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
  209290:	e0bfff17 	ldw	r2,-4(fp)
  209294:	10800217 	ldw	r2,8(r2)
  209298:	10800104 	addi	r2,r2,4
  20929c:	1007883a 	mov	r3,r2
  2092a0:	008002c4 	movi	r2,11
  2092a4:	18800035 	stwio	r2,0(r3)
			secs = 0;
  2092a8:	d0219915 	stw	zero,-31132(gp)
		}
		break;
  2092ac:	00002c06 	br	209360 <timeout_isr+0x1f0>
	case FIN_WAIT:
		if( ++secs == 60){
  2092b0:	d0a19917 	ldw	r2,-31132(gp)
  2092b4:	10800044 	addi	r2,r2,1
  2092b8:	d0a19915 	stw	r2,-31132(gp)
  2092bc:	d0a19917 	ldw	r2,-31132(gp)
  2092c0:	10800f18 	cmpnei	r2,r2,60
  2092c4:	1000281e 	bne	r2,zero,209368 <timeout_isr+0x1f8>
			TCP->state = LISTEN;
  2092c8:	d0a19b17 	ldw	r2,-31124(gp)
  2092cc:	00c00084 	movi	r3,2
  2092d0:	10c00015 	stw	r3,0(r2)
			IOWR_ALTERA_AVALON_TIMER_CONTROL(tmr->base, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_STOP_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
  2092d4:	e0bfff17 	ldw	r2,-4(fp)
  2092d8:	10800217 	ldw	r2,8(r2)
  2092dc:	10800104 	addi	r2,r2,4
  2092e0:	1007883a 	mov	r3,r2
  2092e4:	008002c4 	movi	r2,11
  2092e8:	18800035 	stwio	r2,0(r3)
			secs = 0;
  2092ec:	d0219915 	stw	zero,-31132(gp)
		}
		break;
  2092f0:	00001d06 	br	209368 <timeout_isr+0x1f8>
	case LAST_ACK:
		if( ++secs == 60){
  2092f4:	d0a19917 	ldw	r2,-31132(gp)
  2092f8:	10800044 	addi	r2,r2,1
  2092fc:	d0a19915 	stw	r2,-31132(gp)
  209300:	d0a19917 	ldw	r2,-31132(gp)
  209304:	10800f18 	cmpnei	r2,r2,60
  209308:	1000191e 	bne	r2,zero,209370 <timeout_isr+0x200>
			TCP->state = LISTEN;
  20930c:	d0a19b17 	ldw	r2,-31124(gp)
  209310:	00c00084 	movi	r3,2
  209314:	10c00015 	stw	r3,0(r2)
			IOWR_ALTERA_AVALON_TIMER_CONTROL(tmr->base, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_STOP_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
  209318:	e0bfff17 	ldw	r2,-4(fp)
  20931c:	10800217 	ldw	r2,8(r2)
  209320:	10800104 	addi	r2,r2,4
  209324:	1007883a 	mov	r3,r2
  209328:	008002c4 	movi	r2,11
  20932c:	18800035 	stwio	r2,0(r3)
			secs = 0;
  209330:	d0219915 	stw	zero,-31132(gp)
		}
		break;
  209334:	00000e06 	br	209370 <timeout_isr+0x200>

	default:
		IOWR_ALTERA_AVALON_TIMER_CONTROL(tmr->base, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_STOP_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
  209338:	e0bfff17 	ldw	r2,-4(fp)
  20933c:	10800217 	ldw	r2,8(r2)
  209340:	10800104 	addi	r2,r2,4
  209344:	1007883a 	mov	r3,r2
  209348:	008002c4 	movi	r2,11
  20934c:	18800035 	stwio	r2,0(r3)
		secs = 0;
  209350:	d0219915 	stw	zero,-31132(gp)
		break;
  209354:	00000706 	br	209374 <timeout_isr+0x204>
			TCP->state = FIN_WAIT;
			TCP->command_sent = true;
			secs = 0;
		}

		break;
  209358:	0001883a 	nop
  20935c:	00000506 	br	209374 <timeout_isr+0x204>
		if( ++secs == 60){
			TCP->state = LISTEN;
			IOWR_ALTERA_AVALON_TIMER_CONTROL(tmr->base, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_STOP_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
			secs = 0;
		}
		break;
  209360:	0001883a 	nop
  209364:	00000306 	br	209374 <timeout_isr+0x204>
		if( ++secs == 60){
			TCP->state = LISTEN;
			IOWR_ALTERA_AVALON_TIMER_CONTROL(tmr->base, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_STOP_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
			secs = 0;
		}
		break;
  209368:	0001883a 	nop
  20936c:	00000106 	br	209374 <timeout_isr+0x204>
		if( ++secs == 60){
			TCP->state = LISTEN;
			IOWR_ALTERA_AVALON_TIMER_CONTROL(tmr->base, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_STOP_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
			secs = 0;
		}
		break;
  209370:	0001883a 	nop
		secs = 0;
		break;
	}


}
  209374:	0001883a 	nop
  209378:	e037883a 	mov	sp,fp
  20937c:	dfc00117 	ldw	ra,4(sp)
  209380:	df000017 	ldw	fp,0(sp)
  209384:	dec00204 	addi	sp,sp,8
  209388:	f800283a 	ret

0020938c <timer_int_en>:

void timer_int_en(timer_struct * tmr){
  20938c:	defffc04 	addi	sp,sp,-16
  209390:	dfc00315 	stw	ra,12(sp)
  209394:	df000215 	stw	fp,8(sp)
  209398:	df000204 	addi	fp,sp,8
  20939c:	e13fff15 	stw	r4,-4(fp)
	alt_ic_isr_register(tmr->id, tmr->irq, (void *)timeout_isr, tmr, 0x00);
  2093a0:	e0bfff17 	ldw	r2,-4(fp)
  2093a4:	10c00017 	ldw	r3,0(r2)
  2093a8:	e0bfff17 	ldw	r2,-4(fp)
  2093ac:	10800117 	ldw	r2,4(r2)
  2093b0:	d8000015 	stw	zero,0(sp)
  2093b4:	e1ffff17 	ldw	r7,-4(fp)
  2093b8:	01800874 	movhi	r6,33
  2093bc:	31a45c04 	addi	r6,r6,-28304
  2093c0:	100b883a 	mov	r5,r2
  2093c4:	1809883a 	mov	r4,r3
  2093c8:	0209e1c0 	call	209e1c <alt_ic_isr_register>
	IOWR_ALTERA_AVALON_TIMER_PERIODL(tmr->base, TIMEOUT_PERIOD);
  2093cc:	e0bfff17 	ldw	r2,-4(fp)
  2093d0:	10800217 	ldw	r2,8(r2)
  2093d4:	10800204 	addi	r2,r2,8
  2093d8:	1007883a 	mov	r3,r2
  2093dc:	00817db4 	movhi	r2,1526
  2093e0:	10b84004 	addi	r2,r2,-7936
  2093e4:	18800035 	stwio	r2,0(r3)
	IOWR_ALTERA_AVALON_TIMER_PERIODH(tmr->base, TIMEOUT_PERIOD>>16);
  2093e8:	e0bfff17 	ldw	r2,-4(fp)
  2093ec:	10800217 	ldw	r2,8(r2)
  2093f0:	10800304 	addi	r2,r2,12
  2093f4:	1007883a 	mov	r3,r2
  2093f8:	00817d44 	movi	r2,1525
  2093fc:	18800035 	stwio	r2,0(r3)
}
  209400:	0001883a 	nop
  209404:	e037883a 	mov	sp,fp
  209408:	dfc00117 	ldw	ra,4(sp)
  20940c:	df000017 	ldw	fp,0(sp)
  209410:	dec00204 	addi	sp,sp,8
  209414:	f800283a 	ret

00209418 <get_ipv4_checksumm>:

alt_u16 get_ipv4_checksumm(alt_u8 * data, alt_u8 len){
  209418:	defffa04 	addi	sp,sp,-24
  20941c:	df000515 	stw	fp,20(sp)
  209420:	df000504 	addi	fp,sp,20
  209424:	e13ffe15 	stw	r4,-8(fp)
  209428:	2805883a 	mov	r2,r5
  20942c:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 sum = 0;
  209430:	e03ffb15 	stw	zero,-20(fp)
//	int addr = data;// +  0xe;

	for(alt_u8 i = 0; i < len; i = i + 2){
  209434:	e03ffc05 	stb	zero,-16(fp)
  209438:	00001606 	br	209494 <get_ipv4_checksumm+0x7c>
		alt_u8 a = data[i];
  20943c:	e0bffc03 	ldbu	r2,-16(fp)
  209440:	e0fffe17 	ldw	r3,-8(fp)
  209444:	1885883a 	add	r2,r3,r2
  209448:	10800003 	ldbu	r2,0(r2)
  20944c:	e0bffc45 	stb	r2,-15(fp)
		alt_u8 b = data[i+1];
  209450:	e0bffc03 	ldbu	r2,-16(fp)
  209454:	10800044 	addi	r2,r2,1
  209458:	e0fffe17 	ldw	r3,-8(fp)
  20945c:	1885883a 	add	r2,r3,r2
  209460:	10800003 	ldbu	r2,0(r2)
  209464:	e0bffc85 	stb	r2,-14(fp)
		sum += a<<8 | b;
  209468:	e0bffc43 	ldbu	r2,-15(fp)
  20946c:	1006923a 	slli	r3,r2,8
  209470:	e0bffc83 	ldbu	r2,-14(fp)
  209474:	1884b03a 	or	r2,r3,r2
  209478:	1007883a 	mov	r3,r2
  20947c:	e0bffb17 	ldw	r2,-20(fp)
  209480:	10c5883a 	add	r2,r2,r3
  209484:	e0bffb15 	stw	r2,-20(fp)
alt_u16 get_ipv4_checksumm(alt_u8 * data, alt_u8 len){

	alt_u32 sum = 0;
//	int addr = data;// +  0xe;

	for(alt_u8 i = 0; i < len; i = i + 2){
  209488:	e0bffc03 	ldbu	r2,-16(fp)
  20948c:	10800084 	addi	r2,r2,2
  209490:	e0bffc05 	stb	r2,-16(fp)
  209494:	e0fffc03 	ldbu	r3,-16(fp)
  209498:	e0bfff03 	ldbu	r2,-4(fp)
  20949c:	18bfe736 	bltu	r3,r2,20943c <_gp+0xffff33a4>
//    /*  Add left-over byte, if any */
//    if ( count > 0 )
//        sum += * (alt_u8 *) addr;

	/*  Fold 32-bit sum to 16 bits */
	while (sum>>16)
  2094a0:	00000606 	br	2094bc <get_ipv4_checksumm+0xa4>
		sum = (sum & 0xffff) + (sum >> 16);
  2094a4:	e0bffb17 	ldw	r2,-20(fp)
  2094a8:	10ffffcc 	andi	r3,r2,65535
  2094ac:	e0bffb17 	ldw	r2,-20(fp)
  2094b0:	1004d43a 	srli	r2,r2,16
  2094b4:	1885883a 	add	r2,r3,r2
  2094b8:	e0bffb15 	stw	r2,-20(fp)
//    /*  Add left-over byte, if any */
//    if ( count > 0 )
//        sum += * (alt_u8 *) addr;

	/*  Fold 32-bit sum to 16 bits */
	while (sum>>16)
  2094bc:	e0bffb17 	ldw	r2,-20(fp)
  2094c0:	1004d43a 	srli	r2,r2,16
  2094c4:	103ff71e 	bne	r2,zero,2094a4 <_gp+0xffff340c>
		sum = (sum & 0xffff) + (sum >> 16);

	alt_u16 rev = ~sum;
  2094c8:	e0bffb17 	ldw	r2,-20(fp)
  2094cc:	0084303a 	nor	r2,zero,r2
  2094d0:	e0bffd0d 	sth	r2,-12(fp)
	return rev>>8 | rev<<8;
  2094d4:	e0bffd0b 	ldhu	r2,-12(fp)
  2094d8:	1004d23a 	srli	r2,r2,8
  2094dc:	1007883a 	mov	r3,r2
  2094e0:	e0bffd0b 	ldhu	r2,-12(fp)
  2094e4:	1004923a 	slli	r2,r2,8
  2094e8:	1884b03a 	or	r2,r3,r2
}
  2094ec:	e037883a 	mov	sp,fp
  2094f0:	df000017 	ldw	fp,0(sp)
  2094f4:	dec00104 	addi	sp,sp,4
  2094f8:	f800283a 	ret

002094fc <get_tcp_checksumm>:
alt_u16 get_tcp_checksumm(alt_u8 * source_ip, alt_u8 * dest_ip,  alt_u8 * tcp_data, alt_u16 len){
  2094fc:	defff704 	addi	sp,sp,-36
  209500:	df000815 	stw	fp,32(sp)
  209504:	df000804 	addi	fp,sp,32
  209508:	e13ffc15 	stw	r4,-16(fp)
  20950c:	e17ffd15 	stw	r5,-12(fp)
  209510:	e1bffe15 	stw	r6,-8(fp)
  209514:	3805883a 	mov	r2,r7
  209518:	e0bfff0d 	sth	r2,-4(fp)

	alt_u32 sum = 0;
  20951c:	e03ff815 	stw	zero,-32(fp)
	for(alt_u8 i = 0; i < 4; i = i + 2){
  209520:	e03ff905 	stb	zero,-28(fp)
  209524:	00001606 	br	209580 <get_tcp_checksumm+0x84>
		alt_u8 a = source_ip[i];
  209528:	e0bff903 	ldbu	r2,-28(fp)
  20952c:	e0fffc17 	ldw	r3,-16(fp)
  209530:	1885883a 	add	r2,r3,r2
  209534:	10800003 	ldbu	r2,0(r2)
  209538:	e0bffa05 	stb	r2,-24(fp)
		alt_u8 b = source_ip[i+1];
  20953c:	e0bff903 	ldbu	r2,-28(fp)
  209540:	10800044 	addi	r2,r2,1
  209544:	e0fffc17 	ldw	r3,-16(fp)
  209548:	1885883a 	add	r2,r3,r2
  20954c:	10800003 	ldbu	r2,0(r2)
  209550:	e0bffa45 	stb	r2,-23(fp)
		sum += a<<8 | b;
  209554:	e0bffa03 	ldbu	r2,-24(fp)
  209558:	1006923a 	slli	r3,r2,8
  20955c:	e0bffa43 	ldbu	r2,-23(fp)
  209560:	1884b03a 	or	r2,r3,r2
  209564:	1007883a 	mov	r3,r2
  209568:	e0bff817 	ldw	r2,-32(fp)
  20956c:	10c5883a 	add	r2,r2,r3
  209570:	e0bff815 	stw	r2,-32(fp)
	return rev>>8 | rev<<8;
}
alt_u16 get_tcp_checksumm(alt_u8 * source_ip, alt_u8 * dest_ip,  alt_u8 * tcp_data, alt_u16 len){

	alt_u32 sum = 0;
	for(alt_u8 i = 0; i < 4; i = i + 2){
  209574:	e0bff903 	ldbu	r2,-28(fp)
  209578:	10800084 	addi	r2,r2,2
  20957c:	e0bff905 	stb	r2,-28(fp)
  209580:	e0bff903 	ldbu	r2,-28(fp)
  209584:	10800130 	cmpltui	r2,r2,4
  209588:	103fe71e 	bne	r2,zero,209528 <_gp+0xffff3490>
		alt_u8 a = source_ip[i];
		alt_u8 b = source_ip[i+1];
		sum += a<<8 | b;
	}

	for(alt_u8 i = 0; i < 4; i = i + 2){
  20958c:	e03ff945 	stb	zero,-27(fp)
  209590:	00001606 	br	2095ec <get_tcp_checksumm+0xf0>
		alt_u8 a = dest_ip[i];
  209594:	e0bff943 	ldbu	r2,-27(fp)
  209598:	e0fffd17 	ldw	r3,-12(fp)
  20959c:	1885883a 	add	r2,r3,r2
  2095a0:	10800003 	ldbu	r2,0(r2)
  2095a4:	e0bffa85 	stb	r2,-22(fp)
		alt_u8 b = dest_ip[i+1];
  2095a8:	e0bff943 	ldbu	r2,-27(fp)
  2095ac:	10800044 	addi	r2,r2,1
  2095b0:	e0fffd17 	ldw	r3,-12(fp)
  2095b4:	1885883a 	add	r2,r3,r2
  2095b8:	10800003 	ldbu	r2,0(r2)
  2095bc:	e0bffac5 	stb	r2,-21(fp)
		sum += a<<8 | b;
  2095c0:	e0bffa83 	ldbu	r2,-22(fp)
  2095c4:	1006923a 	slli	r3,r2,8
  2095c8:	e0bffac3 	ldbu	r2,-21(fp)
  2095cc:	1884b03a 	or	r2,r3,r2
  2095d0:	1007883a 	mov	r3,r2
  2095d4:	e0bff817 	ldw	r2,-32(fp)
  2095d8:	10c5883a 	add	r2,r2,r3
  2095dc:	e0bff815 	stw	r2,-32(fp)
		alt_u8 a = source_ip[i];
		alt_u8 b = source_ip[i+1];
		sum += a<<8 | b;
	}

	for(alt_u8 i = 0; i < 4; i = i + 2){
  2095e0:	e0bff943 	ldbu	r2,-27(fp)
  2095e4:	10800084 	addi	r2,r2,2
  2095e8:	e0bff945 	stb	r2,-27(fp)
  2095ec:	e0bff943 	ldbu	r2,-27(fp)
  2095f0:	10800130 	cmpltui	r2,r2,4
  2095f4:	103fe71e 	bne	r2,zero,209594 <_gp+0xffff34fc>
		alt_u8 a = dest_ip[i];
		alt_u8 b = dest_ip[i+1];
		sum += a<<8 | b;
	}
	sum += 0x6;
  2095f8:	e0bff817 	ldw	r2,-32(fp)
  2095fc:	10800184 	addi	r2,r2,6
  209600:	e0bff815 	stw	r2,-32(fp)
	sum += len;
  209604:	e0bfff0b 	ldhu	r2,-4(fp)
  209608:	e0fff817 	ldw	r3,-32(fp)
  20960c:	1885883a 	add	r2,r3,r2
  209610:	e0bff815 	stw	r2,-32(fp)

	for(alt_u16 i = 0; i < len; i = i + 2){
  209614:	e03ff98d 	sth	zero,-26(fp)
  209618:	00001606 	br	209674 <get_tcp_checksumm+0x178>
		alt_u8 a = tcp_data[i];
  20961c:	e0bff98b 	ldhu	r2,-26(fp)
  209620:	e0fffe17 	ldw	r3,-8(fp)
  209624:	1885883a 	add	r2,r3,r2
  209628:	10800003 	ldbu	r2,0(r2)
  20962c:	e0bffb05 	stb	r2,-20(fp)
		alt_u8 b = tcp_data[i+1];
  209630:	e0bff98b 	ldhu	r2,-26(fp)
  209634:	10800044 	addi	r2,r2,1
  209638:	e0fffe17 	ldw	r3,-8(fp)
  20963c:	1885883a 	add	r2,r3,r2
  209640:	10800003 	ldbu	r2,0(r2)
  209644:	e0bffb45 	stb	r2,-19(fp)
		sum += a<<8 | b;
  209648:	e0bffb03 	ldbu	r2,-20(fp)
  20964c:	1006923a 	slli	r3,r2,8
  209650:	e0bffb43 	ldbu	r2,-19(fp)
  209654:	1884b03a 	or	r2,r3,r2
  209658:	1007883a 	mov	r3,r2
  20965c:	e0bff817 	ldw	r2,-32(fp)
  209660:	10c5883a 	add	r2,r2,r3
  209664:	e0bff815 	stw	r2,-32(fp)
		sum += a<<8 | b;
	}
	sum += 0x6;
	sum += len;

	for(alt_u16 i = 0; i < len; i = i + 2){
  209668:	e0bff98b 	ldhu	r2,-26(fp)
  20966c:	10800084 	addi	r2,r2,2
  209670:	e0bff98d 	sth	r2,-26(fp)
  209674:	e0fff98b 	ldhu	r3,-26(fp)
  209678:	e0bfff0b 	ldhu	r2,-4(fp)
  20967c:	18bfe736 	bltu	r3,r2,20961c <_gp+0xffff3584>
//    /*  Add left-over byte, if any */
//    if ( count > 0 )
//        sum += * (alt_u8 *) addr;

	/*  Fold 32-bit sum to 16 bits */
	while (sum>>16)
  209680:	00000606 	br	20969c <get_tcp_checksumm+0x1a0>
		sum = (sum & 0xffff) + (sum >> 16);
  209684:	e0bff817 	ldw	r2,-32(fp)
  209688:	10ffffcc 	andi	r3,r2,65535
  20968c:	e0bff817 	ldw	r2,-32(fp)
  209690:	1004d43a 	srli	r2,r2,16
  209694:	1885883a 	add	r2,r3,r2
  209698:	e0bff815 	stw	r2,-32(fp)
//    /*  Add left-over byte, if any */
//    if ( count > 0 )
//        sum += * (alt_u8 *) addr;

	/*  Fold 32-bit sum to 16 bits */
	while (sum>>16)
  20969c:	e0bff817 	ldw	r2,-32(fp)
  2096a0:	1004d43a 	srli	r2,r2,16
  2096a4:	103ff71e 	bne	r2,zero,209684 <_gp+0xffff35ec>
		sum = (sum & 0xffff) + (sum >> 16);

	alt_u16 rev = ~sum;
  2096a8:	e0bff817 	ldw	r2,-32(fp)
  2096ac:	0084303a 	nor	r2,zero,r2
  2096b0:	e0bffb8d 	sth	r2,-18(fp)
	return rev>>8 | rev<<8;
  2096b4:	e0bffb8b 	ldhu	r2,-18(fp)
  2096b8:	1004d23a 	srli	r2,r2,8
  2096bc:	1007883a 	mov	r3,r2
  2096c0:	e0bffb8b 	ldhu	r2,-18(fp)
  2096c4:	1004923a 	slli	r2,r2,8
  2096c8:	1884b03a 	or	r2,r3,r2
}
  2096cc:	e037883a 	mov	sp,fp
  2096d0:	df000017 	ldw	fp,0(sp)
  2096d4:	dec00104 	addi	sp,sp,4
  2096d8:	f800283a 	ret

002096dc <create_tcp_pkt>:


/********* Function for Creating Packet before transmission ***********************/
void create_tcp_pkt( alt_u8 flags, alt_u8 * payload, alt_u8 header_len, alt_u16 payload_len){
  2096dc:	defff804 	addi	sp,sp,-32
  2096e0:	dfc00715 	stw	ra,28(sp)
  2096e4:	df000615 	stw	fp,24(sp)
  2096e8:	dc000515 	stw	r16,20(sp)
  2096ec:	df000604 	addi	fp,sp,24
  2096f0:	e17ffc15 	stw	r5,-16(fp)
  2096f4:	3007883a 	mov	r3,r6
  2096f8:	3805883a 	mov	r2,r7
  2096fc:	e13ffb05 	stb	r4,-20(fp)
  209700:	e0fffd05 	stb	r3,-12(fp)
  209704:	e0bffe0d 	sth	r2,-8(fp)
	///ip fields
	memmove(tcp_out->ipv4.eth_flds.dest_addr, &TCP->dest_mac, 6);
  209708:	d0a00717 	ldw	r2,-32740(gp)
  20970c:	1007883a 	mov	r3,r2
  209710:	d0a19b17 	ldw	r2,-31124(gp)
  209714:	10800144 	addi	r2,r2,5
  209718:	01800184 	movi	r6,6
  20971c:	100b883a 	mov	r5,r2
  209720:	1809883a 	mov	r4,r3
  209724:	0209d5c0 	call	209d5c <memmove>
	memmove(tcp_out->ipv4.eth_flds.source_addr,&my_mac,6);
  209728:	d0a00717 	ldw	r2,-32740(gp)
  20972c:	10800184 	addi	r2,r2,6
  209730:	01800184 	movi	r6,6
  209734:	d1600a04 	addi	r5,gp,-32728
  209738:	1009883a 	mov	r4,r2
  20973c:	0209d5c0 	call	209d5c <memmove>
	tcp_out->ipv4.eth_flds.type = 0x0008;
  209740:	d0a00717 	ldw	r2,-32740(gp)
  209744:	00c00204 	movi	r3,8
  209748:	10c0030d 	sth	r3,12(r2)
	tcp_out->ipv4.ver_ihl = 0x45;
  20974c:	d0a00717 	ldw	r2,-32740(gp)
  209750:	00c01144 	movi	r3,69
  209754:	10c00385 	stb	r3,14(r2)
	tcp_out->ipv4.dscp = 0x0;
  209758:	d0a00717 	ldw	r2,-32740(gp)
  20975c:	100003c5 	stb	zero,15(r2)
	tcp_out->ipv4.flags_frag_ofset = 0x0040;
  209760:	d0a00717 	ldw	r2,-32740(gp)
  209764:	00c01004 	movi	r3,64
  209768:	10c0050d 	sth	r3,20(r2)
	tcp_out->ipv4.id = 0xe117; //???
  20976c:	d0a00717 	ldw	r2,-32740(gp)
  209770:	00f845c4 	movi	r3,-7913
  209774:	10c0048d 	sth	r3,18(r2)
	tcp_out->ipv4.ttl = 0x80;
  209778:	d0a00717 	ldw	r2,-32740(gp)
  20977c:	00ffe004 	movi	r3,-128
  209780:	10c00585 	stb	r3,22(r2)
	tcp_out->ipv4.protocol = 06;
  209784:	d0a00717 	ldw	r2,-32740(gp)
  209788:	00c00184 	movi	r3,6
  20978c:	10c005c5 	stb	r3,23(r2)
	memmove(tcp_out->ipv4.sender_ip, my_ip, 6);
  209790:	d0a00717 	ldw	r2,-32740(gp)
  209794:	10800684 	addi	r2,r2,26
  209798:	01800184 	movi	r6,6
  20979c:	d1600904 	addi	r5,gp,-32732
  2097a0:	1009883a 	mov	r4,r2
  2097a4:	0209d5c0 	call	209d5c <memmove>
	memmove(tcp_out->ipv4.dest_ip, TCP->dest_ip, 4);
  2097a8:	d0a00717 	ldw	r2,-32740(gp)
  2097ac:	10c00784 	addi	r3,r2,30
  2097b0:	d0a19b17 	ldw	r2,-31124(gp)
  2097b4:	10800444 	addi	r2,r2,17
  2097b8:	01800104 	movi	r6,4
  2097bc:	100b883a 	mov	r5,r2
  2097c0:	1809883a 	mov	r4,r3
  2097c4:	0209d5c0 	call	209d5c <memmove>
	alt_u16 full_len = 20 + 20 + payload_len;
  2097c8:	e0bffe0b 	ldhu	r2,-8(fp)
  2097cc:	10800a04 	addi	r2,r2,40
  2097d0:	e0bffa0d 	sth	r2,-24(fp)
	tcp_out->ipv4.total_len[0] = full_len>>8;
  2097d4:	d0a00717 	ldw	r2,-32740(gp)
  2097d8:	e0fffa0b 	ldhu	r3,-24(fp)
  2097dc:	1806d23a 	srli	r3,r3,8
  2097e0:	10c00405 	stb	r3,16(r2)
	tcp_out->ipv4.total_len[1] = full_len;
  2097e4:	d0a00717 	ldw	r2,-32740(gp)
  2097e8:	e0fffa0b 	ldhu	r3,-24(fp)
  2097ec:	10c00445 	stb	r3,17(r2)

	//TCP fields
	tcp_out->sender_port = 0x5000;
  2097f0:	d0a00717 	ldw	r2,-32740(gp)
  2097f4:	00d40004 	movi	r3,20480
  2097f8:	10c0088d 	sth	r3,34(r2)
	tcp_out->destination_port = TCP->dest_port;
  2097fc:	d0a00717 	ldw	r2,-32740(gp)
  209800:	d0e19b17 	ldw	r3,-31124(gp)
  209804:	18c0060b 	ldhu	r3,24(r3)
  209808:	10c0090d 	sth	r3,36(r2)

	tcp_out->seq_num[0] = TCP->last_acked>>24;
  20980c:	d0a00717 	ldw	r2,-32740(gp)
  209810:	d0e19b17 	ldw	r3,-31124(gp)
  209814:	18c00817 	ldw	r3,32(r3)
  209818:	1806d63a 	srli	r3,r3,24
  20981c:	10c00985 	stb	r3,38(r2)
	tcp_out->seq_num[1] = TCP->last_acked>>16;
  209820:	d0a00717 	ldw	r2,-32740(gp)
  209824:	d0e19b17 	ldw	r3,-31124(gp)
  209828:	18c00817 	ldw	r3,32(r3)
  20982c:	1806d43a 	srli	r3,r3,16
  209830:	10c009c5 	stb	r3,39(r2)
	tcp_out->seq_num[2] = TCP->last_acked>>8;
  209834:	d0a00717 	ldw	r2,-32740(gp)
  209838:	d0e19b17 	ldw	r3,-31124(gp)
  20983c:	18c00817 	ldw	r3,32(r3)
  209840:	1806d23a 	srli	r3,r3,8
  209844:	10c00a05 	stb	r3,40(r2)
	tcp_out->seq_num[3] = TCP->last_acked;
  209848:	d0a00717 	ldw	r2,-32740(gp)
  20984c:	d0e19b17 	ldw	r3,-31124(gp)
  209850:	18c00817 	ldw	r3,32(r3)
  209854:	10c00a45 	stb	r3,41(r2)

	TCP->seq_num += TCP->rec_payload_len + ( TCP->rec_payload_len == 0);
  209858:	d0a19b17 	ldw	r2,-31124(gp)
  20985c:	d0e19b17 	ldw	r3,-31124(gp)
  209860:	18c00717 	ldw	r3,28(r3)
  209864:	d1219b17 	ldw	r4,-31124(gp)
  209868:	21000a0b 	ldhu	r4,40(r4)
  20986c:	217fffcc 	andi	r5,r4,65535
  209870:	d1219b17 	ldw	r4,-31124(gp)
  209874:	21000a0b 	ldhu	r4,40(r4)
  209878:	213fffcc 	andi	r4,r4,65535
  20987c:	2009003a 	cmpeq	r4,r4,zero
  209880:	21003fcc 	andi	r4,r4,255
  209884:	2909883a 	add	r4,r5,r4
  209888:	1907883a 	add	r3,r3,r4
  20988c:	10c00715 	stw	r3,28(r2)

	tcp_out->ack_num[0] = TCP->seq_num>>24;
  209890:	d0a00717 	ldw	r2,-32740(gp)
  209894:	d0e19b17 	ldw	r3,-31124(gp)
  209898:	18c00717 	ldw	r3,28(r3)
  20989c:	1806d63a 	srli	r3,r3,24
  2098a0:	10c00a85 	stb	r3,42(r2)
	tcp_out->ack_num[1] = TCP->seq_num>>16;
  2098a4:	d0a00717 	ldw	r2,-32740(gp)
  2098a8:	d0e19b17 	ldw	r3,-31124(gp)
  2098ac:	18c00717 	ldw	r3,28(r3)
  2098b0:	1806d43a 	srli	r3,r3,16
  2098b4:	10c00ac5 	stb	r3,43(r2)
	tcp_out->ack_num[2] = TCP->seq_num>>8;
  2098b8:	d0a00717 	ldw	r2,-32740(gp)
  2098bc:	d0e19b17 	ldw	r3,-31124(gp)
  2098c0:	18c00717 	ldw	r3,28(r3)
  2098c4:	1806d23a 	srli	r3,r3,8
  2098c8:	10c00b05 	stb	r3,44(r2)
	tcp_out->ack_num[3] = TCP->seq_num;
  2098cc:	d0a00717 	ldw	r2,-32740(gp)
  2098d0:	d0e19b17 	ldw	r3,-31124(gp)
  2098d4:	18c00717 	ldw	r3,28(r3)
  2098d8:	10c00b45 	stb	r3,45(r2)

	tcp_out->header_len = (header_len/4)<<4;
  2098dc:	d0a00717 	ldw	r2,-32740(gp)
  2098e0:	e0fffd03 	ldbu	r3,-12(fp)
  2098e4:	1806d0ba 	srli	r3,r3,2
  2098e8:	1806913a 	slli	r3,r3,4
  2098ec:	10c00b85 	stb	r3,46(r2)
	tcp_out->flags = flags;
  2098f0:	d0a00717 	ldw	r2,-32740(gp)
  2098f4:	e0fffb03 	ldbu	r3,-20(fp)
  2098f8:	10c00bc5 	stb	r3,47(r2)
	tcp_out->window = 0xf0fa;
  2098fc:	d0a00717 	ldw	r2,-32740(gp)
  209900:	00fc3e84 	movi	r3,-3846
  209904:	10c00c0d 	sth	r3,48(r2)
	tcp_out->urgent_data_pntr = 0x0;
  209908:	d0a00717 	ldw	r2,-32740(gp)
  20990c:	10000d0d 	sth	zero,52(r2)

	memmove(tcp_out->payload, payload,payload_len);
  209910:	d0a00717 	ldw	r2,-32740(gp)
  209914:	10800d84 	addi	r2,r2,54
  209918:	e0fffe0b 	ldhu	r3,-8(fp)
  20991c:	180d883a 	mov	r6,r3
  209920:	e17ffc17 	ldw	r5,-16(fp)
  209924:	1009883a 	mov	r4,r2
  209928:	0209d5c0 	call	209d5c <memmove>


	///checksums
	tcp_out->ipv4.checksum =0;
  20992c:	d0a00717 	ldw	r2,-32740(gp)
  209930:	1000060d 	sth	zero,24(r2)
	tcp_out->ipv4.checksum = get_ipv4_checksumm((alt_u8*)&tcp_out->ipv4.ver_ihl, 20);
  209934:	d4200717 	ldw	r16,-32740(gp)
  209938:	d0a00717 	ldw	r2,-32740(gp)
  20993c:	10800384 	addi	r2,r2,14
  209940:	01400504 	movi	r5,20
  209944:	1009883a 	mov	r4,r2
  209948:	02094180 	call	209418 <get_ipv4_checksumm>
  20994c:	8080060d 	sth	r2,24(r16)
	tcp_out->checksumm = 0;
  209950:	d0a00717 	ldw	r2,-32740(gp)
  209954:	10000c8d 	sth	zero,50(r2)
	tcp_out->checksumm = get_tcp_checksumm(my_ip, TCP->dest_ip, (alt_u8*)&tcp_out->sender_port, 20 + payload_len);
  209958:	d4200717 	ldw	r16,-32740(gp)
  20995c:	d0a19b17 	ldw	r2,-31124(gp)
  209960:	10c00444 	addi	r3,r2,17
  209964:	d0a00717 	ldw	r2,-32740(gp)
  209968:	11000884 	addi	r4,r2,34
  20996c:	e0bffe0b 	ldhu	r2,-8(fp)
  209970:	10800504 	addi	r2,r2,20
  209974:	10bfffcc 	andi	r2,r2,65535
  209978:	100f883a 	mov	r7,r2
  20997c:	200d883a 	mov	r6,r4
  209980:	180b883a 	mov	r5,r3
  209984:	d1200904 	addi	r4,gp,-32732
  209988:	02094fc0 	call	2094fc <get_tcp_checksumm>
  20998c:	80800c8d 	sth	r2,50(r16)

}
  209990:	0001883a 	nop
  209994:	e6ffff04 	addi	sp,fp,-4
  209998:	dfc00217 	ldw	ra,8(sp)
  20999c:	df000117 	ldw	fp,4(sp)
  2099a0:	dc000017 	ldw	r16,0(sp)
  2099a4:	dec00304 	addi	sp,sp,12
  2099a8:	f800283a 	ret

002099ac <main>:
/********** Function Prototypes ******************/
void tse_init();
alt_u8 get_command(char* data);

/******* MAIN BLOCK STARTS HERE ********************************/
int main(void){
  2099ac:	deff9e04 	addi	sp,sp,-392
  2099b0:	dfc06115 	stw	ra,388(sp)
  2099b4:	df006015 	stw	fp,384(sp)
  2099b8:	df006004 	addi	fp,sp,384
	/************* Tcp connection structures *********************/
	struct tcp_conn TCP;
	struct timer_struct tmr;

	TCP.state = LISTEN;
  2099bc:	00800084 	movi	r2,2
  2099c0:	e0bfa215 	stw	r2,-376(fp)

	altera_avalon_lcd_16207_state lcd_obj;
	altera_avalon_lcd_16207_state * lcd = &lcd_obj;
  2099c4:	e0bfc204 	addi	r2,fp,-248
  2099c8:	e0bfa115 	stw	r2,-380(fp)
	lcd->base = LCD_16207_0_BASE;
  2099cc:	e0ffa117 	ldw	r3,-380(fp)
  2099d0:	00800874 	movhi	r2,33
  2099d4:	10893004 	addi	r2,r2,9408
  2099d8:	18800015 	stw	r2,0(r3)
	altera_avalon_lcd_16207_init(lcd);
  2099dc:	e13fa117 	ldw	r4,-380(fp)
  2099e0:	020b3640 	call	20b364 <altera_avalon_lcd_16207_init>
	altera_avalon_lcd_16207_write(lcd, "My IP is: \n",sizeof("My IP is: \n") , 0);
  2099e4:	000f883a 	mov	r7,zero
  2099e8:	01800304 	movi	r6,12
  2099ec:	01400874 	movhi	r5,33
  2099f0:	29760904 	addi	r5,r5,-10204
  2099f4:	e13fa117 	ldw	r4,-380(fp)
  2099f8:	020ad980 	call	20ad98 <altera_avalon_lcd_16207_write>
	altera_avalon_lcd_16207_write(lcd, "169.254.229.14 \n",sizeof("169.254.229.14 \n") , 0);
  2099fc:	000f883a 	mov	r7,zero
  209a00:	01800444 	movi	r6,17
  209a04:	01400874 	movhi	r5,33
  209a08:	29760c04 	addi	r5,r5,-10192
  209a0c:	e13fa117 	ldw	r4,-380(fp)
  209a10:	020ad980 	call	20ad98 <altera_avalon_lcd_16207_write>

/**** Initializing timer status and control values *************/
	tmr.base = TIMER_0_BASE;
  209a14:	00800874 	movhi	r2,33
  209a18:	10892004 	addi	r2,r2,9344
  209a1c:	e0bfc015 	stw	r2,-256(fp)
	tmr.id = TIMER_0_IRQ_INTERRUPT_CONTROLLER_ID;
  209a20:	e03fbe15 	stw	zero,-264(fp)
	tmr.irq = TIMER_0_IRQ;
  209a24:	00800084 	movi	r2,2
  209a28:	e0bfbf15 	stw	r2,-260(fp)
	tmr.set_timer_zero = false;
  209a2c:	e03fc105 	stb	zero,-252(fp)
	timer_int_en(&tmr);
  209a30:	e0bfbe04 	addi	r2,fp,-264
  209a34:	1009883a 	mov	r4,r2
  209a38:	020938c0 	call	20938c <timer_int_en>
	tse_init(tse, &TCP);
  209a3c:	d0a00c17 	ldw	r2,-32720(gp)
  209a40:	e0ffa204 	addi	r3,fp,-376
  209a44:	180b883a 	mov	r5,r3
  209a48:	1009883a 	mov	r4,r2
  209a4c:	020828c0 	call	20828c <tse_init>


	while (1) {
		in =  IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE); //read the input from the switch
  209a50:	00800874 	movhi	r2,33
  209a54:	10892c04 	addi	r2,r2,9392
  209a58:	10800037 	ldwio	r2,0(r2)
  209a5c:	d0a19d45 	stb	r2,-31115(gp)
		if(TCP.got_html_req == true){
  209a60:	e0bfad03 	ldbu	r2,-332(fp)
  209a64:	10803fcc 	andi	r2,r2,255
  209a68:	10002626 	beq	r2,zero,209b04 <main+0x158>
			TCP.got_html_req = false;
  209a6c:	e03fad05 	stb	zero,-332(fp)
			if(TCP.payload[5] == '?'){
  209a70:	e0bfae83 	ldbu	r2,-326(fp)
  209a74:	10803fcc 	andi	r2,r2,255
  209a78:	10800fd8 	cmpnei	r2,r2,63
  209a7c:	1000211e 	bne	r2,zero,209b04 <main+0x158>
				leds = 0x0;
  209a80:	d0219dc5 	stb	zero,-31113(gp)
				for (alt_u8 i = 0; i < 4; i++)
  209a84:	e03fa005 	stb	zero,-384(fp)
  209a88:	00001906 	br	209af0 <main+0x144>
				{
					leds |= get_command(TCP.payload + 6 + ( i*8 ));
  209a8c:	e0bfa003 	ldbu	r2,-384(fp)
  209a90:	100490fa 	slli	r2,r2,3
  209a94:	10800184 	addi	r2,r2,6
  209a98:	e0ffa204 	addi	r3,fp,-376
  209a9c:	18c00b44 	addi	r3,r3,45
  209aa0:	1885883a 	add	r2,r3,r2
  209aa4:	1009883a 	mov	r4,r2
  209aa8:	0209b500 	call	209b50 <get_command>
  209aac:	1007883a 	mov	r3,r2
  209ab0:	d0a19dc3 	ldbu	r2,-31113(gp)
  209ab4:	1884b03a 	or	r2,r3,r2
  209ab8:	d0a19dc5 	stb	r2,-31113(gp)
					if(TCP.payload[5 + ( ( i + 1 )*8 )] != '&')
  209abc:	e0bfa003 	ldbu	r2,-384(fp)
  209ac0:	10800044 	addi	r2,r2,1
  209ac4:	100490fa 	slli	r2,r2,3
  209ac8:	10800144 	addi	r2,r2,5
  209acc:	e0ffad44 	addi	r3,fp,-331
  209ad0:	1885883a 	add	r2,r3,r2
  209ad4:	10800003 	ldbu	r2,0(r2)
  209ad8:	10803fcc 	andi	r2,r2,255
  209adc:	108009a0 	cmpeqi	r2,r2,38
  209ae0:	10000726 	beq	r2,zero,209b00 <main+0x154>
		in =  IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE); //read the input from the switch
		if(TCP.got_html_req == true){
			TCP.got_html_req = false;
			if(TCP.payload[5] == '?'){
				leds = 0x0;
				for (alt_u8 i = 0; i < 4; i++)
  209ae4:	e0bfa003 	ldbu	r2,-384(fp)
  209ae8:	10800044 	addi	r2,r2,1
  209aec:	e0bfa005 	stb	r2,-384(fp)
  209af0:	e0bfa003 	ldbu	r2,-384(fp)
  209af4:	10800130 	cmpltui	r2,r2,4
  209af8:	103fe41e 	bne	r2,zero,209a8c <_gp+0xffff39f4>
  209afc:	00000106 	br	209b04 <main+0x158>
				{
					leds |= get_command(TCP.payload + 6 + ( i*8 ));
					if(TCP.payload[5 + ( ( i + 1 )*8 )] != '&')
						break;
  209b00:	0001883a 	nop
				}
			}
		}
		IOWR_ALTERA_AVALON_PIO_DATA(PIO_1_BASE, ~leds);
  209b04:	d0a19dc3 	ldbu	r2,-31113(gp)
  209b08:	10803fcc 	andi	r2,r2,255
  209b0c:	0086303a 	nor	r3,zero,r2
  209b10:	00800874 	movhi	r2,33
  209b14:	10892804 	addi	r2,r2,9376
  209b18:	10c00035 	stwio	r3,0(r2)
		if(lcd_string_changed){
  209b1c:	d0a19d03 	ldbu	r2,-31116(gp)
  209b20:	10803fcc 	andi	r2,r2,255
  209b24:	103fca26 	beq	r2,zero,209a50 <_gp+0xffff39b8>
			altera_avalon_lcd_16207_write(lcd, lcd_string, lcd_string_len , 0);
  209b28:	d0a19d83 	ldbu	r2,-31114(gp)
  209b2c:	10803fcc 	andi	r2,r2,255
  209b30:	000f883a 	mov	r7,zero
  209b34:	100d883a 	mov	r6,r2
  209b38:	01400874 	movhi	r5,33
  209b3c:	297cc304 	addi	r5,r5,-3316
  209b40:	e13fa117 	ldw	r4,-380(fp)
  209b44:	020ad980 	call	20ad98 <altera_avalon_lcd_16207_write>
			lcd_string_changed = false;
  209b48:	d0219d05 	stb	zero,-31116(gp)
		}
	}
  209b4c:	003fc006 	br	209a50 <_gp+0xffff39b8>

00209b50 <get_command>:
	return 0;
}

alt_u8 get_command(char* data){
  209b50:	defffa04 	addi	sp,sp,-24
  209b54:	dfc00515 	stw	ra,20(sp)
  209b58:	df000415 	stw	fp,16(sp)
  209b5c:	df000404 	addi	fp,sp,16
  209b60:	e13fff15 	stw	r4,-4(fp)
	char led_ch[] = "led";
  209b64:	00801b04 	movi	r2,108
  209b68:	e0bffc45 	stb	r2,-15(fp)
  209b6c:	00801944 	movi	r2,101
  209b70:	e0bffc85 	stb	r2,-14(fp)
  209b74:	00801904 	movi	r2,100
  209b78:	e0bffcc5 	stb	r2,-13(fp)
  209b7c:	e03ffd05 	stb	zero,-12(fp)
	char lcd_ch[] = "lcd";
  209b80:	00801b04 	movi	r2,108
  209b84:	e0bffd45 	stb	r2,-11(fp)
  209b88:	008018c4 	movi	r2,99
  209b8c:	e0bffd85 	stb	r2,-10(fp)
  209b90:	00801904 	movi	r2,100
  209b94:	e0bffdc5 	stb	r2,-9(fp)
  209b98:	e03ffe05 	stb	zero,-8(fp)
	char message[3];
	memmove(message, data, 3);
  209b9c:	e0bffe44 	addi	r2,fp,-7
  209ba0:	018000c4 	movi	r6,3
  209ba4:	e17fff17 	ldw	r5,-4(fp)
  209ba8:	1009883a 	mov	r4,r2
  209bac:	0209d5c0 	call	209d5c <memmove>
	if(strncmp(message, led_ch, sizeof(message)) == 0){
  209bb0:	e0fffc44 	addi	r3,fp,-15
  209bb4:	e0bffe44 	addi	r2,fp,-7
  209bb8:	018000c4 	movi	r6,3
  209bbc:	180b883a 	mov	r5,r3
  209bc0:	1009883a 	mov	r4,r2
  209bc4:	0209dbc0 	call	209dbc <strncmp>
  209bc8:	1000141e 	bne	r2,zero,209c1c <get_command+0xcc>
		switch(data[3]){
  209bcc:	e0bfff17 	ldw	r2,-4(fp)
  209bd0:	108000c4 	addi	r2,r2,3
  209bd4:	10800003 	ldbu	r2,0(r2)
  209bd8:	10803fcc 	andi	r2,r2,255
  209bdc:	1080201c 	xori	r2,r2,128
  209be0:	10bfe004 	addi	r2,r2,-128
  209be4:	10c00ca0 	cmpeqi	r3,r2,50
  209be8:	1800061e 	bne	r3,zero,209c04 <get_command+0xb4>
  209bec:	10c00ce0 	cmpeqi	r3,r2,51
  209bf0:	1800061e 	bne	r3,zero,209c0c <get_command+0xbc>
  209bf4:	10800c60 	cmpeqi	r2,r2,49
  209bf8:	10000626 	beq	r2,zero,209c14 <get_command+0xc4>
		case '1':
			return 0x1;
  209bfc:	00800044 	movi	r2,1
  209c00:	00005106 	br	209d48 <get_command+0x1f8>
		case '2':
			return 0x2;
  209c04:	00800084 	movi	r2,2
  209c08:	00004f06 	br	209d48 <get_command+0x1f8>
		case '3':
			return 0x4;
  209c0c:	00800104 	movi	r2,4
  209c10:	00004d06 	br	209d48 <get_command+0x1f8>
		default:
			return 0x0;
  209c14:	0005883a 	mov	r2,zero
  209c18:	00004b06 	br	209d48 <get_command+0x1f8>
		}
	}
	else if(strncmp(message, lcd_ch, sizeof(message)) == 0){
  209c1c:	e0fffd44 	addi	r3,fp,-11
  209c20:	e0bffe44 	addi	r2,fp,-7
  209c24:	018000c4 	movi	r6,3
  209c28:	180b883a 	mov	r5,r3
  209c2c:	1009883a 	mov	r4,r2
  209c30:	0209dbc0 	call	209dbc <strncmp>
  209c34:	1000431e 	bne	r2,zero,209d44 <get_command+0x1f4>
		alt_u8 n = 4;
  209c38:	00800104 	movi	r2,4
  209c3c:	e0bffc05 	stb	r2,-16(fp)
		while (data[n]!=' ' && n<64)
  209c40:	00002106 	br	209cc8 <get_command+0x178>
		{
			if(data[n] == '+'){
  209c44:	e0bffc03 	ldbu	r2,-16(fp)
  209c48:	e0ffff17 	ldw	r3,-4(fp)
  209c4c:	1885883a 	add	r2,r3,r2
  209c50:	10800003 	ldbu	r2,0(r2)
  209c54:	10803fcc 	andi	r2,r2,255
  209c58:	1080201c 	xori	r2,r2,128
  209c5c:	10bfe004 	addi	r2,r2,-128
  209c60:	10800ad8 	cmpnei	r2,r2,43
  209c64:	10000b1e 	bne	r2,zero,209c94 <get_command+0x144>
				lcd_string[n-4] = ' ';
  209c68:	e0bffc03 	ldbu	r2,-16(fp)
  209c6c:	10ffff04 	addi	r3,r2,-4
  209c70:	00800874 	movhi	r2,33
  209c74:	10bcc304 	addi	r2,r2,-3316
  209c78:	10c5883a 	add	r2,r2,r3
  209c7c:	00c00804 	movi	r3,32
  209c80:	10c00005 	stb	r3,0(r2)
				n++;
  209c84:	e0bffc03 	ldbu	r2,-16(fp)
  209c88:	10800044 	addi	r2,r2,1
  209c8c:	e0bffc05 	stb	r2,-16(fp)
  209c90:	00000d06 	br	209cc8 <get_command+0x178>
			}
			else
				lcd_string[n-4] = data[n++];
  209c94:	e0bffc03 	ldbu	r2,-16(fp)
  209c98:	113fff04 	addi	r4,r2,-4
  209c9c:	e0bffc03 	ldbu	r2,-16(fp)
  209ca0:	10c00044 	addi	r3,r2,1
  209ca4:	e0fffc05 	stb	r3,-16(fp)
  209ca8:	10803fcc 	andi	r2,r2,255
  209cac:	e0ffff17 	ldw	r3,-4(fp)
  209cb0:	1885883a 	add	r2,r3,r2
  209cb4:	10c00003 	ldbu	r3,0(r2)
  209cb8:	00800874 	movhi	r2,33
  209cbc:	10bcc304 	addi	r2,r2,-3316
  209cc0:	1105883a 	add	r2,r2,r4
  209cc4:	10c00005 	stb	r3,0(r2)
			return 0x0;
		}
	}
	else if(strncmp(message, lcd_ch, sizeof(message)) == 0){
		alt_u8 n = 4;
		while (data[n]!=' ' && n<64)
  209cc8:	e0bffc03 	ldbu	r2,-16(fp)
  209ccc:	e0ffff17 	ldw	r3,-4(fp)
  209cd0:	1885883a 	add	r2,r3,r2
  209cd4:	10800003 	ldbu	r2,0(r2)
  209cd8:	10803fcc 	andi	r2,r2,255
  209cdc:	1080201c 	xori	r2,r2,128
  209ce0:	10bfe004 	addi	r2,r2,-128
  209ce4:	10800820 	cmpeqi	r2,r2,32
  209ce8:	1000031e 	bne	r2,zero,209cf8 <get_command+0x1a8>
  209cec:	e0bffc03 	ldbu	r2,-16(fp)
  209cf0:	10801030 	cmpltui	r2,r2,64
  209cf4:	103fd31e 	bne	r2,zero,209c44 <_gp+0xffff3bac>
				n++;
			}
			else
				lcd_string[n-4] = data[n++];
		}
		lcd_string_len = n-4;
  209cf8:	e0bffc03 	ldbu	r2,-16(fp)
  209cfc:	10bfff04 	addi	r2,r2,-4
  209d00:	d0a19d85 	stb	r2,-31114(gp)
		if(lcd_string_len > 0)
  209d04:	d0a19d83 	ldbu	r2,-31114(gp)
  209d08:	10803fcc 	andi	r2,r2,255
  209d0c:	10000926 	beq	r2,zero,209d34 <get_command+0x1e4>
			lcd_string[lcd_string_len++] = '\n';
  209d10:	d0a19d83 	ldbu	r2,-31114(gp)
  209d14:	10c00044 	addi	r3,r2,1
  209d18:	d0e19d85 	stb	r3,-31114(gp)
  209d1c:	10c03fcc 	andi	r3,r2,255
  209d20:	00800874 	movhi	r2,33
  209d24:	10bcc304 	addi	r2,r2,-3316
  209d28:	10c5883a 	add	r2,r2,r3
  209d2c:	00c00284 	movi	r3,10
  209d30:	10c00005 	stb	r3,0(r2)
			lcd_string_changed = true;
  209d34:	00800044 	movi	r2,1
  209d38:	d0a19d05 	stb	r2,-31116(gp)
		return 0x0;
  209d3c:	0005883a 	mov	r2,zero
  209d40:	00000106 	br	209d48 <get_command+0x1f8>
	}
	else
		return 0x0;
  209d44:	0005883a 	mov	r2,zero
}
  209d48:	e037883a 	mov	sp,fp
  209d4c:	dfc00117 	ldw	ra,4(sp)
  209d50:	df000017 	ldw	fp,0(sp)
  209d54:	dec00204 	addi	sp,sp,8
  209d58:	f800283a 	ret

00209d5c <memmove>:
  209d5c:	2005883a 	mov	r2,r4
  209d60:	218f883a 	add	r7,r4,r6
  209d64:	29000236 	bltu	r5,r4,209d70 <memmove+0x14>
  209d68:	1007883a 	mov	r3,r2
  209d6c:	00000c06 	br	209da0 <memmove+0x44>
  209d70:	2987883a 	add	r3,r5,r6
  209d74:	20fffc2e 	bgeu	r4,r3,209d68 <_gp+0xffff3cd0>
  209d78:	380b883a 	mov	r5,r7
  209d7c:	30cdc83a 	sub	r6,r6,r3
  209d80:	1989883a 	add	r4,r3,r6
  209d84:	20000526 	beq	r4,zero,209d9c <memmove+0x40>
  209d88:	18ffffc4 	addi	r3,r3,-1
  209d8c:	19000003 	ldbu	r4,0(r3)
  209d90:	297fffc4 	addi	r5,r5,-1
  209d94:	29000005 	stb	r4,0(r5)
  209d98:	003ff906 	br	209d80 <_gp+0xffff3ce8>
  209d9c:	f800283a 	ret
  209da0:	19c00526 	beq	r3,r7,209db8 <memmove+0x5c>
  209da4:	29000003 	ldbu	r4,0(r5)
  209da8:	18c00044 	addi	r3,r3,1
  209dac:	29400044 	addi	r5,r5,1
  209db0:	193fffc5 	stb	r4,-1(r3)
  209db4:	003ffa06 	br	209da0 <_gp+0xffff3d08>
  209db8:	f800283a 	ret

00209dbc <strncmp>:
  209dbc:	30001526 	beq	r6,zero,209e14 <strncmp+0x58>
  209dc0:	31bfffc4 	addi	r6,r6,-1
  209dc4:	218d883a 	add	r6,r4,r6
  209dc8:	20800003 	ldbu	r2,0(r4)
  209dcc:	28c00003 	ldbu	r3,0(r5)
  209dd0:	11c03fcc 	andi	r7,r2,255
  209dd4:	1a003fcc 	andi	r8,r3,255
  209dd8:	39c0201c 	xori	r7,r7,128
  209ddc:	4200201c 	xori	r8,r8,128
  209de0:	39ffe004 	addi	r7,r7,-128
  209de4:	423fe004 	addi	r8,r8,-128
  209de8:	3a00061e 	bne	r7,r8,209e04 <strncmp+0x48>
  209dec:	21800426 	beq	r4,r6,209e00 <strncmp+0x44>
  209df0:	38000326 	beq	r7,zero,209e00 <strncmp+0x44>
  209df4:	21000044 	addi	r4,r4,1
  209df8:	29400044 	addi	r5,r5,1
  209dfc:	003ff206 	br	209dc8 <_gp+0xffff3d30>
  209e00:	1007883a 	mov	r3,r2
  209e04:	18c03fcc 	andi	r3,r3,255
  209e08:	10803fcc 	andi	r2,r2,255
  209e0c:	10c5c83a 	sub	r2,r2,r3
  209e10:	f800283a 	ret
  209e14:	0005883a 	mov	r2,zero
  209e18:	f800283a 	ret

00209e1c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  209e1c:	defff904 	addi	sp,sp,-28
  209e20:	dfc00615 	stw	ra,24(sp)
  209e24:	df000515 	stw	fp,20(sp)
  209e28:	df000504 	addi	fp,sp,20
  209e2c:	e13ffc15 	stw	r4,-16(fp)
  209e30:	e17ffd15 	stw	r5,-12(fp)
  209e34:	e1bffe15 	stw	r6,-8(fp)
  209e38:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  209e3c:	e0800217 	ldw	r2,8(fp)
  209e40:	d8800015 	stw	r2,0(sp)
  209e44:	e1ffff17 	ldw	r7,-4(fp)
  209e48:	e1bffe17 	ldw	r6,-8(fp)
  209e4c:	e17ffd17 	ldw	r5,-12(fp)
  209e50:	e13ffc17 	ldw	r4,-16(fp)
  209e54:	0209fcc0 	call	209fcc <alt_iic_isr_register>
}  
  209e58:	e037883a 	mov	sp,fp
  209e5c:	dfc00117 	ldw	ra,4(sp)
  209e60:	df000017 	ldw	fp,0(sp)
  209e64:	dec00204 	addi	sp,sp,8
  209e68:	f800283a 	ret

00209e6c <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  209e6c:	defff904 	addi	sp,sp,-28
  209e70:	df000615 	stw	fp,24(sp)
  209e74:	df000604 	addi	fp,sp,24
  209e78:	e13ffe15 	stw	r4,-8(fp)
  209e7c:	e17fff15 	stw	r5,-4(fp)
  209e80:	e0bfff17 	ldw	r2,-4(fp)
  209e84:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  209e88:	0005303a 	rdctl	r2,status
  209e8c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  209e90:	e0fffb17 	ldw	r3,-20(fp)
  209e94:	00bfff84 	movi	r2,-2
  209e98:	1884703a 	and	r2,r3,r2
  209e9c:	1001703a 	wrctl	status,r2
  
  return context;
  209ea0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  209ea4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  209ea8:	00c00044 	movi	r3,1
  209eac:	e0bffa17 	ldw	r2,-24(fp)
  209eb0:	1884983a 	sll	r2,r3,r2
  209eb4:	1007883a 	mov	r3,r2
  209eb8:	d0a19e17 	ldw	r2,-31112(gp)
  209ebc:	1884b03a 	or	r2,r3,r2
  209ec0:	d0a19e15 	stw	r2,-31112(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  209ec4:	d0a19e17 	ldw	r2,-31112(gp)
  209ec8:	100170fa 	wrctl	ienable,r2
  209ecc:	e0bffc17 	ldw	r2,-16(fp)
  209ed0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  209ed4:	e0bffd17 	ldw	r2,-12(fp)
  209ed8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  209edc:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
  209ee0:	0001883a 	nop
}
  209ee4:	e037883a 	mov	sp,fp
  209ee8:	df000017 	ldw	fp,0(sp)
  209eec:	dec00104 	addi	sp,sp,4
  209ef0:	f800283a 	ret

00209ef4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  209ef4:	defff904 	addi	sp,sp,-28
  209ef8:	df000615 	stw	fp,24(sp)
  209efc:	df000604 	addi	fp,sp,24
  209f00:	e13ffe15 	stw	r4,-8(fp)
  209f04:	e17fff15 	stw	r5,-4(fp)
  209f08:	e0bfff17 	ldw	r2,-4(fp)
  209f0c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  209f10:	0005303a 	rdctl	r2,status
  209f14:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  209f18:	e0fffb17 	ldw	r3,-20(fp)
  209f1c:	00bfff84 	movi	r2,-2
  209f20:	1884703a 	and	r2,r3,r2
  209f24:	1001703a 	wrctl	status,r2
  
  return context;
  209f28:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  209f2c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  209f30:	00c00044 	movi	r3,1
  209f34:	e0bffa17 	ldw	r2,-24(fp)
  209f38:	1884983a 	sll	r2,r3,r2
  209f3c:	0084303a 	nor	r2,zero,r2
  209f40:	1007883a 	mov	r3,r2
  209f44:	d0a19e17 	ldw	r2,-31112(gp)
  209f48:	1884703a 	and	r2,r3,r2
  209f4c:	d0a19e15 	stw	r2,-31112(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  209f50:	d0a19e17 	ldw	r2,-31112(gp)
  209f54:	100170fa 	wrctl	ienable,r2
  209f58:	e0bffc17 	ldw	r2,-16(fp)
  209f5c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  209f60:	e0bffd17 	ldw	r2,-12(fp)
  209f64:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  209f68:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
  209f6c:	0001883a 	nop
}
  209f70:	e037883a 	mov	sp,fp
  209f74:	df000017 	ldw	fp,0(sp)
  209f78:	dec00104 	addi	sp,sp,4
  209f7c:	f800283a 	ret

00209f80 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  209f80:	defffc04 	addi	sp,sp,-16
  209f84:	df000315 	stw	fp,12(sp)
  209f88:	df000304 	addi	fp,sp,12
  209f8c:	e13ffe15 	stw	r4,-8(fp)
  209f90:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  209f94:	000530fa 	rdctl	r2,ienable
  209f98:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  209f9c:	00c00044 	movi	r3,1
  209fa0:	e0bfff17 	ldw	r2,-4(fp)
  209fa4:	1884983a 	sll	r2,r3,r2
  209fa8:	1007883a 	mov	r3,r2
  209fac:	e0bffd17 	ldw	r2,-12(fp)
  209fb0:	1884703a 	and	r2,r3,r2
  209fb4:	1004c03a 	cmpne	r2,r2,zero
  209fb8:	10803fcc 	andi	r2,r2,255
}
  209fbc:	e037883a 	mov	sp,fp
  209fc0:	df000017 	ldw	fp,0(sp)
  209fc4:	dec00104 	addi	sp,sp,4
  209fc8:	f800283a 	ret

00209fcc <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  209fcc:	defff504 	addi	sp,sp,-44
  209fd0:	dfc00a15 	stw	ra,40(sp)
  209fd4:	df000915 	stw	fp,36(sp)
  209fd8:	df000904 	addi	fp,sp,36
  209fdc:	e13ffc15 	stw	r4,-16(fp)
  209fe0:	e17ffd15 	stw	r5,-12(fp)
  209fe4:	e1bffe15 	stw	r6,-8(fp)
  209fe8:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  209fec:	00bffa84 	movi	r2,-22
  209ff0:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  209ff4:	e0bffd17 	ldw	r2,-12(fp)
  209ff8:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  209ffc:	e0bff817 	ldw	r2,-32(fp)
  20a000:	10800808 	cmpgei	r2,r2,32
  20a004:	1000271e 	bne	r2,zero,20a0a4 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20a008:	0005303a 	rdctl	r2,status
  20a00c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20a010:	e0fffb17 	ldw	r3,-20(fp)
  20a014:	00bfff84 	movi	r2,-2
  20a018:	1884703a 	and	r2,r3,r2
  20a01c:	1001703a 	wrctl	status,r2
  
  return context;
  20a020:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  20a024:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
  20a028:	00800874 	movhi	r2,33
  20a02c:	10bcd304 	addi	r2,r2,-3252
  20a030:	e0fff817 	ldw	r3,-32(fp)
  20a034:	180690fa 	slli	r3,r3,3
  20a038:	10c5883a 	add	r2,r2,r3
  20a03c:	e0fffe17 	ldw	r3,-8(fp)
  20a040:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  20a044:	00800874 	movhi	r2,33
  20a048:	10bcd304 	addi	r2,r2,-3252
  20a04c:	e0fff817 	ldw	r3,-32(fp)
  20a050:	180690fa 	slli	r3,r3,3
  20a054:	10c5883a 	add	r2,r2,r3
  20a058:	10800104 	addi	r2,r2,4
  20a05c:	e0ffff17 	ldw	r3,-4(fp)
  20a060:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  20a064:	e0bffe17 	ldw	r2,-8(fp)
  20a068:	10000526 	beq	r2,zero,20a080 <alt_iic_isr_register+0xb4>
  20a06c:	e0bff817 	ldw	r2,-32(fp)
  20a070:	100b883a 	mov	r5,r2
  20a074:	e13ffc17 	ldw	r4,-16(fp)
  20a078:	0209e6c0 	call	209e6c <alt_ic_irq_enable>
  20a07c:	00000406 	br	20a090 <alt_iic_isr_register+0xc4>
  20a080:	e0bff817 	ldw	r2,-32(fp)
  20a084:	100b883a 	mov	r5,r2
  20a088:	e13ffc17 	ldw	r4,-16(fp)
  20a08c:	0209ef40 	call	209ef4 <alt_ic_irq_disable>
  20a090:	e0bff715 	stw	r2,-36(fp)
  20a094:	e0bffa17 	ldw	r2,-24(fp)
  20a098:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20a09c:	e0bff917 	ldw	r2,-28(fp)
  20a0a0:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  20a0a4:	e0bff717 	ldw	r2,-36(fp)
}
  20a0a8:	e037883a 	mov	sp,fp
  20a0ac:	dfc00117 	ldw	ra,4(sp)
  20a0b0:	df000017 	ldw	fp,0(sp)
  20a0b4:	dec00204 	addi	sp,sp,8
  20a0b8:	f800283a 	ret

0020a0bc <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  20a0bc:	defffc04 	addi	sp,sp,-16
  20a0c0:	df000315 	stw	fp,12(sp)
  20a0c4:	df000304 	addi	fp,sp,12
  20a0c8:	e13ffd15 	stw	r4,-12(fp)
  20a0cc:	e17ffe15 	stw	r5,-8(fp)
  20a0d0:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  20a0d4:	e0fffe17 	ldw	r3,-8(fp)
  20a0d8:	e0bffd17 	ldw	r2,-12(fp)
  20a0dc:	18800c26 	beq	r3,r2,20a110 <alt_load_section+0x54>
  {
    while( to != end )
  20a0e0:	00000806 	br	20a104 <alt_load_section+0x48>
    {
      *to++ = *from++;
  20a0e4:	e0bffe17 	ldw	r2,-8(fp)
  20a0e8:	10c00104 	addi	r3,r2,4
  20a0ec:	e0fffe15 	stw	r3,-8(fp)
  20a0f0:	e0fffd17 	ldw	r3,-12(fp)
  20a0f4:	19000104 	addi	r4,r3,4
  20a0f8:	e13ffd15 	stw	r4,-12(fp)
  20a0fc:	18c00017 	ldw	r3,0(r3)
  20a100:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  20a104:	e0fffe17 	ldw	r3,-8(fp)
  20a108:	e0bfff17 	ldw	r2,-4(fp)
  20a10c:	18bff51e 	bne	r3,r2,20a0e4 <_gp+0xffff404c>
    {
      *to++ = *from++;
    }
  }
}
  20a110:	0001883a 	nop
  20a114:	e037883a 	mov	sp,fp
  20a118:	df000017 	ldw	fp,0(sp)
  20a11c:	dec00104 	addi	sp,sp,4
  20a120:	f800283a 	ret

0020a124 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  20a124:	defffe04 	addi	sp,sp,-8
  20a128:	dfc00115 	stw	ra,4(sp)
  20a12c:	df000015 	stw	fp,0(sp)
  20a130:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  20a134:	01800874 	movhi	r6,33
  20a138:	31b84204 	addi	r6,r6,-7928
  20a13c:	01400874 	movhi	r5,33
  20a140:	2976c604 	addi	r5,r5,-9448
  20a144:	01000874 	movhi	r4,33
  20a148:	21384204 	addi	r4,r4,-7928
  20a14c:	020a0bc0 	call	20a0bc <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  20a150:	01800874 	movhi	r6,33
  20a154:	31a08c04 	addi	r6,r6,-32208
  20a158:	01400874 	movhi	r5,33
  20a15c:	29600804 	addi	r5,r5,-32736
  20a160:	01000874 	movhi	r4,33
  20a164:	21200804 	addi	r4,r4,-32736
  20a168:	020a0bc0 	call	20a0bc <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  20a16c:	01800874 	movhi	r6,33
  20a170:	31b6c604 	addi	r6,r6,-9448
  20a174:	01400874 	movhi	r5,33
  20a178:	29760104 	addi	r5,r5,-10236
  20a17c:	01000874 	movhi	r4,33
  20a180:	21360104 	addi	r4,r4,-10236
  20a184:	020a0bc0 	call	20a0bc <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  20a188:	020c5880 	call	20c588 <alt_dcache_flush_all>
  alt_icache_flush_all();
  20a18c:	020c8040 	call	20c804 <alt_icache_flush_all>
}
  20a190:	0001883a 	nop
  20a194:	e037883a 	mov	sp,fp
  20a198:	dfc00117 	ldw	ra,4(sp)
  20a19c:	df000017 	ldw	fp,0(sp)
  20a1a0:	dec00204 	addi	sp,sp,8
  20a1a4:	f800283a 	ret

0020a1a8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  20a1a8:	defffd04 	addi	sp,sp,-12
  20a1ac:	dfc00215 	stw	ra,8(sp)
  20a1b0:	df000115 	stw	fp,4(sp)
  20a1b4:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  20a1b8:	0009883a 	mov	r4,zero
  20a1bc:	020a2580 	call	20a258 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  20a1c0:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  20a1c4:	020a2900 	call	20a290 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  20a1c8:	01800874 	movhi	r6,33
  20a1cc:	31b61104 	addi	r6,r6,-10172
  20a1d0:	01400874 	movhi	r5,33
  20a1d4:	29761104 	addi	r5,r5,-10172
  20a1d8:	01000874 	movhi	r4,33
  20a1dc:	21361104 	addi	r4,r4,-10172
  20a1e0:	020c9a40 	call	20c9a4 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  20a1e4:	020c6b40 	call	20c6b4 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  20a1e8:	01000874 	movhi	r4,33
  20a1ec:	2131c504 	addi	r4,r4,-14572
  20a1f0:	020d2440 	call	20d244 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  20a1f4:	d0a19f17 	ldw	r2,-31108(gp)
  20a1f8:	d0e1a017 	ldw	r3,-31104(gp)
  20a1fc:	d121a117 	ldw	r4,-31100(gp)
  20a200:	200d883a 	mov	r6,r4
  20a204:	180b883a 	mov	r5,r3
  20a208:	1009883a 	mov	r4,r2
  20a20c:	02099ac0 	call	2099ac <main>
  20a210:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  20a214:	01000044 	movi	r4,1
  20a218:	020c4880 	call	20c488 <close>
  exit (result);
  20a21c:	e13fff17 	ldw	r4,-4(fp)
  20a220:	020d2580 	call	20d258 <exit>

0020a224 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  20a224:	defffd04 	addi	sp,sp,-12
  20a228:	dfc00215 	stw	ra,8(sp)
  20a22c:	df000115 	stw	fp,4(sp)
  20a230:	df000104 	addi	fp,sp,4
  20a234:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  20a238:	d1601304 	addi	r5,gp,-32692
  20a23c:	e13fff17 	ldw	r4,-4(fp)
  20a240:	020c6100 	call	20c610 <alt_dev_llist_insert>
}
  20a244:	e037883a 	mov	sp,fp
  20a248:	dfc00117 	ldw	ra,4(sp)
  20a24c:	df000017 	ldw	fp,0(sp)
  20a250:	dec00204 	addi	sp,sp,8
  20a254:	f800283a 	ret

0020a258 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  20a258:	defffd04 	addi	sp,sp,-12
  20a25c:	dfc00215 	stw	ra,8(sp)
  20a260:	df000115 	stw	fp,4(sp)
  20a264:	df000104 	addi	fp,sp,4
  20a268:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
  20a26c:	020cefc0 	call	20cefc <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  20a270:	00800044 	movi	r2,1
  20a274:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  20a278:	0001883a 	nop
  20a27c:	e037883a 	mov	sp,fp
  20a280:	dfc00117 	ldw	ra,4(sp)
  20a284:	df000017 	ldw	fp,0(sp)
  20a288:	dec00204 	addi	sp,sp,8
  20a28c:	f800283a 	ret

0020a290 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  20a290:	defffe04 	addi	sp,sp,-8
  20a294:	dfc00115 	stw	ra,4(sp)
  20a298:	df000015 	stw	fp,0(sp)
  20a29c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
  20a2a0:	01e08d94 	movui	r7,33334
  20a2a4:	01800084 	movi	r6,2
  20a2a8:	000b883a 	mov	r5,zero
  20a2ac:	01000874 	movhi	r4,33
  20a2b0:	21092004 	addi	r4,r4,9344
  20a2b4:	020c2a40 	call	20c2a4 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
  20a2b8:	01000874 	movhi	r4,33
  20a2bc:	21376104 	addi	r4,r4,-8828
  20a2c0:	020a2240 	call	20a224 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD_16207_0, lcd_16207_0);
  20a2c4:	0001883a 	nop
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_0, sgdma_0);
  20a2c8:	01800044 	movi	r6,1
  20a2cc:	000b883a 	mov	r5,zero
  20a2d0:	01000874 	movhi	r4,33
  20a2d4:	21376c04 	addi	r4,r4,-8784
  20a2d8:	020c1840 	call	20c184 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_1, sgdma_1);
  20a2dc:	000d883a 	mov	r6,zero
  20a2e0:	000b883a 	mov	r5,zero
  20a2e4:	01000874 	movhi	r4,33
  20a2e8:	21377804 	addi	r4,r4,-8736
  20a2ec:	020c1840 	call	20c184 <alt_avalon_sgdma_init>
    ALTERA_ETH_TSE_INIT ( ETH_TSE_0, eth_tse_0);
  20a2f0:	0001883a 	nop
}
  20a2f4:	0001883a 	nop
  20a2f8:	e037883a 	mov	sp,fp
  20a2fc:	dfc00117 	ldw	ra,4(sp)
  20a300:	df000017 	ldw	fp,0(sp)
  20a304:	dec00204 	addi	sp,sp,8
  20a308:	f800283a 	ret

0020a30c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  20a30c:	defffa04 	addi	sp,sp,-24
  20a310:	dfc00515 	stw	ra,20(sp)
  20a314:	df000415 	stw	fp,16(sp)
  20a318:	df000404 	addi	fp,sp,16
  20a31c:	e13ffd15 	stw	r4,-12(fp)
  20a320:	e17ffe15 	stw	r5,-8(fp)
  20a324:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  20a328:	e0bffd17 	ldw	r2,-12(fp)
  20a32c:	10800017 	ldw	r2,0(r2)
  20a330:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  20a334:	e0bffc17 	ldw	r2,-16(fp)
  20a338:	10c00a04 	addi	r3,r2,40
  20a33c:	e0bffd17 	ldw	r2,-12(fp)
  20a340:	10800217 	ldw	r2,8(r2)
  20a344:	100f883a 	mov	r7,r2
  20a348:	e1bfff17 	ldw	r6,-4(fp)
  20a34c:	e17ffe17 	ldw	r5,-8(fp)
  20a350:	1809883a 	mov	r4,r3
  20a354:	020a3cc0 	call	20a3cc <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  20a358:	e037883a 	mov	sp,fp
  20a35c:	dfc00117 	ldw	ra,4(sp)
  20a360:	df000017 	ldw	fp,0(sp)
  20a364:	dec00204 	addi	sp,sp,8
  20a368:	f800283a 	ret

0020a36c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  20a36c:	defffa04 	addi	sp,sp,-24
  20a370:	dfc00515 	stw	ra,20(sp)
  20a374:	df000415 	stw	fp,16(sp)
  20a378:	df000404 	addi	fp,sp,16
  20a37c:	e13ffd15 	stw	r4,-12(fp)
  20a380:	e17ffe15 	stw	r5,-8(fp)
  20a384:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  20a388:	e0bffd17 	ldw	r2,-12(fp)
  20a38c:	10800017 	ldw	r2,0(r2)
  20a390:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  20a394:	e0bffc17 	ldw	r2,-16(fp)
  20a398:	10c00a04 	addi	r3,r2,40
  20a39c:	e0bffd17 	ldw	r2,-12(fp)
  20a3a0:	10800217 	ldw	r2,8(r2)
  20a3a4:	100f883a 	mov	r7,r2
  20a3a8:	e1bfff17 	ldw	r6,-4(fp)
  20a3ac:	e17ffe17 	ldw	r5,-8(fp)
  20a3b0:	1809883a 	mov	r4,r3
  20a3b4:	020a4b80 	call	20a4b8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  20a3b8:	e037883a 	mov	sp,fp
  20a3bc:	dfc00117 	ldw	ra,4(sp)
  20a3c0:	df000017 	ldw	fp,0(sp)
  20a3c4:	dec00204 	addi	sp,sp,8
  20a3c8:	f800283a 	ret

0020a3cc <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
  20a3cc:	defff704 	addi	sp,sp,-36
  20a3d0:	df000815 	stw	fp,32(sp)
  20a3d4:	df000804 	addi	fp,sp,32
  20a3d8:	e13ffc15 	stw	r4,-16(fp)
  20a3dc:	e17ffd15 	stw	r5,-12(fp)
  20a3e0:	e1bffe15 	stw	r6,-8(fp)
  20a3e4:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
  20a3e8:	e0bffc17 	ldw	r2,-16(fp)
  20a3ec:	10800017 	ldw	r2,0(r2)
  20a3f0:	e0bff915 	stw	r2,-28(fp)

  char * ptr = buffer;
  20a3f4:	e0bffd17 	ldw	r2,-12(fp)
  20a3f8:	e0bff815 	stw	r2,-32(fp)
  char * end = buffer + space;
  20a3fc:	e0bffe17 	ldw	r2,-8(fp)
  20a400:	e0fffd17 	ldw	r3,-12(fp)
  20a404:	1885883a 	add	r2,r3,r2
  20a408:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
  20a40c:	00001206 	br	20a458 <altera_avalon_jtag_uart_read+0x8c>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  20a410:	e0bff917 	ldw	r2,-28(fp)
  20a414:	10800037 	ldwio	r2,0(r2)
  20a418:	e0bffb15 	stw	r2,-20(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
  20a41c:	e0bffb17 	ldw	r2,-20(fp)
  20a420:	10a0000c 	andi	r2,r2,32768
  20a424:	10000626 	beq	r2,zero,20a440 <altera_avalon_jtag_uart_read+0x74>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  20a428:	e0bff817 	ldw	r2,-32(fp)
  20a42c:	10c00044 	addi	r3,r2,1
  20a430:	e0fff815 	stw	r3,-32(fp)
  20a434:	e0fffb17 	ldw	r3,-20(fp)
  20a438:	10c00005 	stb	r3,0(r2)
  20a43c:	00000606 	br	20a458 <altera_avalon_jtag_uart_read+0x8c>
    else if (ptr != buffer)
  20a440:	e0fff817 	ldw	r3,-32(fp)
  20a444:	e0bffd17 	ldw	r2,-12(fp)
  20a448:	1880071e 	bne	r3,r2,20a468 <altera_avalon_jtag_uart_read+0x9c>
      break;
    else if(flags & O_NONBLOCK)
  20a44c:	e0bfff17 	ldw	r2,-4(fp)
  20a450:	1090000c 	andi	r2,r2,16384
  20a454:	1000061e 	bne	r2,zero,20a470 <altera_avalon_jtag_uart_read+0xa4>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
  20a458:	e0fff817 	ldw	r3,-32(fp)
  20a45c:	e0bffa17 	ldw	r2,-24(fp)
  20a460:	18bfeb36 	bltu	r3,r2,20a410 <_gp+0xffff4378>
  20a464:	00000306 	br	20a474 <altera_avalon_jtag_uart_read+0xa8>
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
  20a468:	0001883a 	nop
  20a46c:	00000106 	br	20a474 <altera_avalon_jtag_uart_read+0xa8>
    else if(flags & O_NONBLOCK)
      break;   
  20a470:	0001883a 	nop
    
  }

  if (ptr != buffer)
  20a474:	e0fff817 	ldw	r3,-32(fp)
  20a478:	e0bffd17 	ldw	r2,-12(fp)
  20a47c:	18800426 	beq	r3,r2,20a490 <altera_avalon_jtag_uart_read+0xc4>
    return ptr - buffer;
  20a480:	e0fff817 	ldw	r3,-32(fp)
  20a484:	e0bffd17 	ldw	r2,-12(fp)
  20a488:	1885c83a 	sub	r2,r3,r2
  20a48c:	00000606 	br	20a4a8 <altera_avalon_jtag_uart_read+0xdc>
  else if (flags & O_NONBLOCK)
  20a490:	e0bfff17 	ldw	r2,-4(fp)
  20a494:	1090000c 	andi	r2,r2,16384
  20a498:	10000226 	beq	r2,zero,20a4a4 <altera_avalon_jtag_uart_read+0xd8>
    return -EWOULDBLOCK;
  20a49c:	00bffd44 	movi	r2,-11
  20a4a0:	00000106 	br	20a4a8 <altera_avalon_jtag_uart_read+0xdc>
  else
    return -EIO;
  20a4a4:	00bffec4 	movi	r2,-5
}
  20a4a8:	e037883a 	mov	sp,fp
  20a4ac:	df000017 	ldw	fp,0(sp)
  20a4b0:	dec00104 	addi	sp,sp,4
  20a4b4:	f800283a 	ret

0020a4b8 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  20a4b8:	defff904 	addi	sp,sp,-28
  20a4bc:	df000615 	stw	fp,24(sp)
  20a4c0:	df000604 	addi	fp,sp,24
  20a4c4:	e13ffc15 	stw	r4,-16(fp)
  20a4c8:	e17ffd15 	stw	r5,-12(fp)
  20a4cc:	e1bffe15 	stw	r6,-8(fp)
  20a4d0:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
  20a4d4:	e0bffc17 	ldw	r2,-16(fp)
  20a4d8:	10800017 	ldw	r2,0(r2)
  20a4dc:	e0bffa15 	stw	r2,-24(fp)

  const char * end = ptr + count;
  20a4e0:	e0bffe17 	ldw	r2,-8(fp)
  20a4e4:	e0fffd17 	ldw	r3,-12(fp)
  20a4e8:	1885883a 	add	r2,r3,r2
  20a4ec:	e0bffb15 	stw	r2,-20(fp)

  while (ptr < end)
  20a4f0:	00000e06 	br	20a52c <altera_avalon_jtag_uart_write+0x74>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  20a4f4:	e0bffa17 	ldw	r2,-24(fp)
  20a4f8:	10800104 	addi	r2,r2,4
  20a4fc:	10800037 	ldwio	r2,0(r2)
  20a500:	10bfffec 	andhi	r2,r2,65535
  20a504:	10000926 	beq	r2,zero,20a52c <altera_avalon_jtag_uart_write+0x74>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
  20a508:	e0fffa17 	ldw	r3,-24(fp)
  20a50c:	e0bffd17 	ldw	r2,-12(fp)
  20a510:	11000044 	addi	r4,r2,1
  20a514:	e13ffd15 	stw	r4,-12(fp)
  20a518:	10800003 	ldbu	r2,0(r2)
  20a51c:	10803fcc 	andi	r2,r2,255
  20a520:	1080201c 	xori	r2,r2,128
  20a524:	10bfe004 	addi	r2,r2,-128
  20a528:	18800035 	stwio	r2,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
  20a52c:	e0fffd17 	ldw	r3,-12(fp)
  20a530:	e0bffb17 	ldw	r2,-20(fp)
  20a534:	18bfef36 	bltu	r3,r2,20a4f4 <_gp+0xffff445c>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
  20a538:	e0bffe17 	ldw	r2,-8(fp)
}
  20a53c:	e037883a 	mov	sp,fp
  20a540:	df000017 	ldw	fp,0(sp)
  20a544:	dec00104 	addi	sp,sp,4
  20a548:	f800283a 	ret

0020a54c <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
  20a54c:	defffa04 	addi	sp,sp,-24
  20a550:	dfc00515 	stw	ra,20(sp)
  20a554:	df000415 	stw	fp,16(sp)
  20a558:	df000404 	addi	fp,sp,16
  20a55c:	e13ffe15 	stw	r4,-8(fp)
  20a560:	2805883a 	mov	r2,r5
  20a564:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
  20a568:	e0bffe17 	ldw	r2,-8(fp)
  20a56c:	10800017 	ldw	r2,0(r2)
  20a570:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
  20a574:	008003f4 	movhi	r2,15
  20a578:	10909004 	addi	r2,r2,16960
  20a57c:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
  20a580:	e0bffe17 	ldw	r2,-8(fp)
  20a584:	10800803 	ldbu	r2,32(r2)
  20a588:	10803fcc 	andi	r2,r2,255
  20a58c:	1080201c 	xori	r2,r2,128
  20a590:	10bfe004 	addi	r2,r2,-128
  20a594:	1000151e 	bne	r2,zero,20a5ec <lcd_write_command+0xa0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
  20a598:	00000906 	br	20a5c0 <lcd_write_command+0x74>
    if (--i == 0)
  20a59c:	e0bffc17 	ldw	r2,-16(fp)
  20a5a0:	10bfffc4 	addi	r2,r2,-1
  20a5a4:	e0bffc15 	stw	r2,-16(fp)
  20a5a8:	e0bffc17 	ldw	r2,-16(fp)
  20a5ac:	1000041e 	bne	r2,zero,20a5c0 <lcd_write_command+0x74>
    {
      sp->broken = 1;
  20a5b0:	e0bffe17 	ldw	r2,-8(fp)
  20a5b4:	00c00044 	movi	r3,1
  20a5b8:	10c00805 	stb	r3,32(r2)
      return;
  20a5bc:	00000c06 	br	20a5f0 <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
  20a5c0:	e0bffd17 	ldw	r2,-12(fp)
  20a5c4:	10800104 	addi	r2,r2,4
  20a5c8:	10800037 	ldwio	r2,0(r2)
  20a5cc:	1080200c 	andi	r2,r2,128
  20a5d0:	103ff21e 	bne	r2,zero,20a59c <_gp+0xffff4504>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
  20a5d4:	01001904 	movi	r4,100
  20a5d8:	020cecc0 	call	20cecc <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
  20a5dc:	e0bffd17 	ldw	r2,-12(fp)
  20a5e0:	e0ffff03 	ldbu	r3,-4(fp)
  20a5e4:	10c00035 	stwio	r3,0(r2)
  20a5e8:	00000106 	br	20a5f0 <lcd_write_command+0xa4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
  20a5ec:	0001883a 	nop
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
}
  20a5f0:	e037883a 	mov	sp,fp
  20a5f4:	dfc00117 	ldw	ra,4(sp)
  20a5f8:	df000017 	ldw	fp,0(sp)
  20a5fc:	dec00204 	addi	sp,sp,8
  20a600:	f800283a 	ret

0020a604 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
  20a604:	defffa04 	addi	sp,sp,-24
  20a608:	dfc00515 	stw	ra,20(sp)
  20a60c:	df000415 	stw	fp,16(sp)
  20a610:	df000404 	addi	fp,sp,16
  20a614:	e13ffe15 	stw	r4,-8(fp)
  20a618:	2805883a 	mov	r2,r5
  20a61c:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
  20a620:	e0bffe17 	ldw	r2,-8(fp)
  20a624:	10800017 	ldw	r2,0(r2)
  20a628:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
  20a62c:	008003f4 	movhi	r2,15
  20a630:	10909004 	addi	r2,r2,16960
  20a634:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
  20a638:	e0bffe17 	ldw	r2,-8(fp)
  20a63c:	10800803 	ldbu	r2,32(r2)
  20a640:	10803fcc 	andi	r2,r2,255
  20a644:	1080201c 	xori	r2,r2,128
  20a648:	10bfe004 	addi	r2,r2,-128
  20a64c:	10001d1e 	bne	r2,zero,20a6c4 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
  20a650:	00000906 	br	20a678 <lcd_write_data+0x74>
    if (--i == 0)
  20a654:	e0bffc17 	ldw	r2,-16(fp)
  20a658:	10bfffc4 	addi	r2,r2,-1
  20a65c:	e0bffc15 	stw	r2,-16(fp)
  20a660:	e0bffc17 	ldw	r2,-16(fp)
  20a664:	1000041e 	bne	r2,zero,20a678 <lcd_write_data+0x74>
    {
      sp->broken = 1;
  20a668:	e0bffe17 	ldw	r2,-8(fp)
  20a66c:	00c00044 	movi	r3,1
  20a670:	10c00805 	stb	r3,32(r2)
      return;
  20a674:	00001406 	br	20a6c8 <lcd_write_data+0xc4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
  20a678:	e0bffd17 	ldw	r2,-12(fp)
  20a67c:	10800104 	addi	r2,r2,4
  20a680:	10800037 	ldwio	r2,0(r2)
  20a684:	1080200c 	andi	r2,r2,128
  20a688:	103ff21e 	bne	r2,zero,20a654 <_gp+0xffff45bc>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
  20a68c:	01001904 	movi	r4,100
  20a690:	020cecc0 	call	20cecc <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
  20a694:	e0bffd17 	ldw	r2,-12(fp)
  20a698:	10800204 	addi	r2,r2,8
  20a69c:	1007883a 	mov	r3,r2
  20a6a0:	e0bfff03 	ldbu	r2,-4(fp)
  20a6a4:	18800035 	stwio	r2,0(r3)

  sp->address++;
  20a6a8:	e0bffe17 	ldw	r2,-8(fp)
  20a6ac:	108008c3 	ldbu	r2,35(r2)
  20a6b0:	10800044 	addi	r2,r2,1
  20a6b4:	1007883a 	mov	r3,r2
  20a6b8:	e0bffe17 	ldw	r2,-8(fp)
  20a6bc:	10c008c5 	stb	r3,35(r2)
  20a6c0:	00000106 	br	20a6c8 <lcd_write_data+0xc4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
  20a6c4:	0001883a 	nop
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);

  sp->address++;
}
  20a6c8:	e037883a 	mov	sp,fp
  20a6cc:	dfc00117 	ldw	ra,4(sp)
  20a6d0:	df000017 	ldw	fp,0(sp)
  20a6d4:	dec00204 	addi	sp,sp,8
  20a6d8:	f800283a 	ret

0020a6dc <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
  20a6dc:	defffb04 	addi	sp,sp,-20
  20a6e0:	dfc00415 	stw	ra,16(sp)
  20a6e4:	df000315 	stw	fp,12(sp)
  20a6e8:	dc000215 	stw	r16,8(sp)
  20a6ec:	df000304 	addi	fp,sp,12
  20a6f0:	e13ffe15 	stw	r4,-8(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
  20a6f4:	01400044 	movi	r5,1
  20a6f8:	e13ffe17 	ldw	r4,-8(fp)
  20a6fc:	020a54c0 	call	20a54c <lcd_write_command>

  sp->x = 0;
  20a700:	e0bffe17 	ldw	r2,-8(fp)
  20a704:	10000845 	stb	zero,33(r2)
  sp->y = 0;
  20a708:	e0bffe17 	ldw	r2,-8(fp)
  20a70c:	10000885 	stb	zero,34(r2)
  sp->address = 0;
  20a710:	e0bffe17 	ldw	r2,-8(fp)
  20a714:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20a718:	e03ffd15 	stw	zero,-12(fp)
  20a71c:	00001f06 	br	20a79c <lcd_clear_screen+0xc0>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
  20a720:	014018c4 	movi	r5,99
  20a724:	e13ffd17 	ldw	r4,-12(fp)
  20a728:	020d7a80 	call	20d7a8 <__mulsi3>
  20a72c:	10801004 	addi	r2,r2,64
  20a730:	e0fffe17 	ldw	r3,-8(fp)
  20a734:	1885883a 	add	r2,r3,r2
  20a738:	01801444 	movi	r6,81
  20a73c:	01400804 	movi	r5,32
  20a740:	1009883a 	mov	r4,r2
  20a744:	020d2d00 	call	20d2d0 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
  20a748:	014018c4 	movi	r5,99
  20a74c:	e13ffd17 	ldw	r4,-12(fp)
  20a750:	020d7a80 	call	20d7a8 <__mulsi3>
  20a754:	10800c04 	addi	r2,r2,48
  20a758:	e0fffe17 	ldw	r3,-8(fp)
  20a75c:	1885883a 	add	r2,r3,r2
  20a760:	01800404 	movi	r6,16
  20a764:	01400804 	movi	r5,32
  20a768:	1009883a 	mov	r4,r2
  20a76c:	020d2d00 	call	20d2d0 <memset>
    sp->line[y].width = 0;
  20a770:	e43ffe17 	ldw	r16,-8(fp)
  20a774:	e0bffd17 	ldw	r2,-12(fp)
  20a778:	014018c4 	movi	r5,99
  20a77c:	1009883a 	mov	r4,r2
  20a780:	020d7a80 	call	20d7a8 <__mulsi3>
  20a784:	8085883a 	add	r2,r16,r2
  20a788:	10802444 	addi	r2,r2,145
  20a78c:	10000005 	stb	zero,0(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20a790:	e0bffd17 	ldw	r2,-12(fp)
  20a794:	10800044 	addi	r2,r2,1
  20a798:	e0bffd15 	stw	r2,-12(fp)
  20a79c:	e0bffd17 	ldw	r2,-12(fp)
  20a7a0:	10800090 	cmplti	r2,r2,2
  20a7a4:	103fde1e 	bne	r2,zero,20a720 <_gp+0xffff4688>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
  20a7a8:	0001883a 	nop
  20a7ac:	e6ffff04 	addi	sp,fp,-4
  20a7b0:	dfc00217 	ldw	ra,8(sp)
  20a7b4:	df000117 	ldw	fp,4(sp)
  20a7b8:	dc000017 	ldw	r16,0(sp)
  20a7bc:	dec00304 	addi	sp,sp,12
  20a7c0:	f800283a 	ret

0020a7c4 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
  20a7c4:	defff504 	addi	sp,sp,-44
  20a7c8:	dfc00a15 	stw	ra,40(sp)
  20a7cc:	df000915 	stw	fp,36(sp)
  20a7d0:	dc400815 	stw	r17,32(sp)
  20a7d4:	dc000715 	stw	r16,28(sp)
  20a7d8:	df000904 	addi	fp,sp,36
  20a7dc:	e13ffd15 	stw	r4,-12(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
  20a7e0:	e0bffd17 	ldw	r2,-12(fp)
  20a7e4:	10800943 	ldbu	r2,37(r2)
  20a7e8:	10803fcc 	andi	r2,r2,255
  20a7ec:	e0bffa15 	stw	r2,-24(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20a7f0:	e03ff715 	stw	zero,-36(fp)
  20a7f4:	00007206 	br	20a9c0 <lcd_repaint_screen+0x1fc>
  {
    int width  = sp->line[y].width;
  20a7f8:	e43ffd17 	ldw	r16,-12(fp)
  20a7fc:	e0bff717 	ldw	r2,-36(fp)
  20a800:	014018c4 	movi	r5,99
  20a804:	1009883a 	mov	r4,r2
  20a808:	020d7a80 	call	20d7a8 <__mulsi3>
  20a80c:	8085883a 	add	r2,r16,r2
  20a810:	10802444 	addi	r2,r2,145
  20a814:	10800003 	ldbu	r2,0(r2)
  20a818:	10803fcc 	andi	r2,r2,255
  20a81c:	1080201c 	xori	r2,r2,128
  20a820:	10bfe004 	addi	r2,r2,-128
  20a824:	e0bffb15 	stw	r2,-20(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
  20a828:	e43ffd17 	ldw	r16,-12(fp)
  20a82c:	e0bff717 	ldw	r2,-36(fp)
  20a830:	014018c4 	movi	r5,99
  20a834:	1009883a 	mov	r4,r2
  20a838:	020d7a80 	call	20d7a8 <__mulsi3>
  20a83c:	8085883a 	add	r2,r16,r2
  20a840:	10802484 	addi	r2,r2,146
  20a844:	10800003 	ldbu	r2,0(r2)
  20a848:	10803fcc 	andi	r2,r2,255
  20a84c:	e17ffa17 	ldw	r5,-24(fp)
  20a850:	1009883a 	mov	r4,r2
  20a854:	020d7a80 	call	20d7a8 <__mulsi3>
  20a858:	1005d23a 	srai	r2,r2,8
  20a85c:	e0bff915 	stw	r2,-28(fp)
    if (offset >= width)
  20a860:	e0fff917 	ldw	r3,-28(fp)
  20a864:	e0bffb17 	ldw	r2,-20(fp)
  20a868:	18800116 	blt	r3,r2,20a870 <lcd_repaint_screen+0xac>
      offset = 0;
  20a86c:	e03ff915 	stw	zero,-28(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
  20a870:	e03ff815 	stw	zero,-32(fp)
  20a874:	00004c06 	br	20a9a8 <lcd_repaint_screen+0x1e4>
    {
      char c = sp->line[y].data[(x + offset) % width];
  20a878:	e0fff817 	ldw	r3,-32(fp)
  20a87c:	e0bff917 	ldw	r2,-28(fp)
  20a880:	1885883a 	add	r2,r3,r2
  20a884:	e17ffb17 	ldw	r5,-20(fp)
  20a888:	1009883a 	mov	r4,r2
  20a88c:	020d6780 	call	20d678 <__modsi3>
  20a890:	1023883a 	mov	r17,r2
  20a894:	e43ffd17 	ldw	r16,-12(fp)
  20a898:	e0bff717 	ldw	r2,-36(fp)
  20a89c:	014018c4 	movi	r5,99
  20a8a0:	1009883a 	mov	r4,r2
  20a8a4:	020d7a80 	call	20d7a8 <__mulsi3>
  20a8a8:	8085883a 	add	r2,r16,r2
  20a8ac:	1445883a 	add	r2,r2,r17
  20a8b0:	10801004 	addi	r2,r2,64
  20a8b4:	10800003 	ldbu	r2,0(r2)
  20a8b8:	e0bffc05 	stb	r2,-16(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
  20a8bc:	e43ffd17 	ldw	r16,-12(fp)
  20a8c0:	e0bff717 	ldw	r2,-36(fp)
  20a8c4:	014018c4 	movi	r5,99
  20a8c8:	1009883a 	mov	r4,r2
  20a8cc:	020d7a80 	call	20d7a8 <__mulsi3>
  20a8d0:	8087883a 	add	r3,r16,r2
  20a8d4:	e0bff817 	ldw	r2,-32(fp)
  20a8d8:	1885883a 	add	r2,r3,r2
  20a8dc:	10800c04 	addi	r2,r2,48
  20a8e0:	10800003 	ldbu	r2,0(r2)
  20a8e4:	10c03fcc 	andi	r3,r2,255
  20a8e8:	18c0201c 	xori	r3,r3,128
  20a8ec:	18ffe004 	addi	r3,r3,-128
  20a8f0:	e0bffc07 	ldb	r2,-16(fp)
  20a8f4:	18802926 	beq	r3,r2,20a99c <lcd_repaint_screen+0x1d8>
      {
        unsigned char address = x + colstart[y];
  20a8f8:	e0fff717 	ldw	r3,-36(fp)
  20a8fc:	d0a00e04 	addi	r2,gp,-32712
  20a900:	1885883a 	add	r2,r3,r2
  20a904:	10800003 	ldbu	r2,0(r2)
  20a908:	1007883a 	mov	r3,r2
  20a90c:	e0bff817 	ldw	r2,-32(fp)
  20a910:	1885883a 	add	r2,r3,r2
  20a914:	e0bffc45 	stb	r2,-15(fp)

        if (address != sp->address)
  20a918:	e0fffc43 	ldbu	r3,-15(fp)
  20a91c:	e0bffd17 	ldw	r2,-12(fp)
  20a920:	108008c3 	ldbu	r2,35(r2)
  20a924:	10803fcc 	andi	r2,r2,255
  20a928:	1080201c 	xori	r2,r2,128
  20a92c:	10bfe004 	addi	r2,r2,-128
  20a930:	18800a26 	beq	r3,r2,20a95c <lcd_repaint_screen+0x198>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
  20a934:	e0fffc43 	ldbu	r3,-15(fp)
  20a938:	00bfe004 	movi	r2,-128
  20a93c:	1884b03a 	or	r2,r3,r2
  20a940:	10803fcc 	andi	r2,r2,255
  20a944:	100b883a 	mov	r5,r2
  20a948:	e13ffd17 	ldw	r4,-12(fp)
  20a94c:	020a54c0 	call	20a54c <lcd_write_command>
          sp->address = address;
  20a950:	e0fffc43 	ldbu	r3,-15(fp)
  20a954:	e0bffd17 	ldw	r2,-12(fp)
  20a958:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
  20a95c:	e0bffc03 	ldbu	r2,-16(fp)
  20a960:	10803fcc 	andi	r2,r2,255
  20a964:	100b883a 	mov	r5,r2
  20a968:	e13ffd17 	ldw	r4,-12(fp)
  20a96c:	020a6040 	call	20a604 <lcd_write_data>
        sp->line[y].visible[x] = c;
  20a970:	e43ffd17 	ldw	r16,-12(fp)
  20a974:	e0bff717 	ldw	r2,-36(fp)
  20a978:	014018c4 	movi	r5,99
  20a97c:	1009883a 	mov	r4,r2
  20a980:	020d7a80 	call	20d7a8 <__mulsi3>
  20a984:	8087883a 	add	r3,r16,r2
  20a988:	e0bff817 	ldw	r2,-32(fp)
  20a98c:	1885883a 	add	r2,r3,r2
  20a990:	10800c04 	addi	r2,r2,48
  20a994:	e0fffc03 	ldbu	r3,-16(fp)
  20a998:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
  20a99c:	e0bff817 	ldw	r2,-32(fp)
  20a9a0:	10800044 	addi	r2,r2,1
  20a9a4:	e0bff815 	stw	r2,-32(fp)
  20a9a8:	e0bff817 	ldw	r2,-32(fp)
  20a9ac:	10800410 	cmplti	r2,r2,16
  20a9b0:	103fb11e 	bne	r2,zero,20a878 <_gp+0xffff47e0>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20a9b4:	e0bff717 	ldw	r2,-36(fp)
  20a9b8:	10800044 	addi	r2,r2,1
  20a9bc:	e0bff715 	stw	r2,-36(fp)
  20a9c0:	e0bff717 	ldw	r2,-36(fp)
  20a9c4:	10800090 	cmplti	r2,r2,2
  20a9c8:	103f8b1e 	bne	r2,zero,20a7f8 <_gp+0xffff4760>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
  20a9cc:	0001883a 	nop
  20a9d0:	e6fffe04 	addi	sp,fp,-8
  20a9d4:	dfc00317 	ldw	ra,12(sp)
  20a9d8:	df000217 	ldw	fp,8(sp)
  20a9dc:	dc400117 	ldw	r17,4(sp)
  20a9e0:	dc000017 	ldw	r16,0(sp)
  20a9e4:	dec00404 	addi	sp,sp,16
  20a9e8:	f800283a 	ret

0020a9ec <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  20a9ec:	defffb04 	addi	sp,sp,-20
  20a9f0:	dfc00415 	stw	ra,16(sp)
  20a9f4:	df000315 	stw	fp,12(sp)
  20a9f8:	dc000215 	stw	r16,8(sp)
  20a9fc:	df000304 	addi	fp,sp,12
  20aa00:	e13ffe15 	stw	r4,-8(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20aa04:	e03ffd15 	stw	zero,-12(fp)
  20aa08:	00002206 	br	20aa94 <lcd_scroll_up+0xa8>
  {
    if (y < ALT_LCD_HEIGHT-1)
  20aa0c:	e0bffd17 	ldw	r2,-12(fp)
  20aa10:	00801316 	blt	zero,r2,20aa60 <lcd_scroll_up+0x74>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
  20aa14:	014018c4 	movi	r5,99
  20aa18:	e13ffd17 	ldw	r4,-12(fp)
  20aa1c:	020d7a80 	call	20d7a8 <__mulsi3>
  20aa20:	10801004 	addi	r2,r2,64
  20aa24:	e0fffe17 	ldw	r3,-8(fp)
  20aa28:	18a1883a 	add	r16,r3,r2
  20aa2c:	e0bffd17 	ldw	r2,-12(fp)
  20aa30:	10800044 	addi	r2,r2,1
  20aa34:	014018c4 	movi	r5,99
  20aa38:	1009883a 	mov	r4,r2
  20aa3c:	020d7a80 	call	20d7a8 <__mulsi3>
  20aa40:	10801004 	addi	r2,r2,64
  20aa44:	e0fffe17 	ldw	r3,-8(fp)
  20aa48:	1885883a 	add	r2,r3,r2
  20aa4c:	01801404 	movi	r6,80
  20aa50:	100b883a 	mov	r5,r2
  20aa54:	8009883a 	mov	r4,r16
  20aa58:	020d2a80 	call	20d2a8 <memcpy>
  20aa5c:	00000a06 	br	20aa88 <lcd_scroll_up+0x9c>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  20aa60:	014018c4 	movi	r5,99
  20aa64:	e13ffd17 	ldw	r4,-12(fp)
  20aa68:	020d7a80 	call	20d7a8 <__mulsi3>
  20aa6c:	10801004 	addi	r2,r2,64
  20aa70:	e0fffe17 	ldw	r3,-8(fp)
  20aa74:	1885883a 	add	r2,r3,r2
  20aa78:	01801404 	movi	r6,80
  20aa7c:	01400804 	movi	r5,32
  20aa80:	1009883a 	mov	r4,r2
  20aa84:	020d2d00 	call	20d2d0 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20aa88:	e0bffd17 	ldw	r2,-12(fp)
  20aa8c:	10800044 	addi	r2,r2,1
  20aa90:	e0bffd15 	stw	r2,-12(fp)
  20aa94:	e0bffd17 	ldw	r2,-12(fp)
  20aa98:	10800090 	cmplti	r2,r2,2
  20aa9c:	103fdb1e 	bne	r2,zero,20aa0c <_gp+0xffff4974>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
  20aaa0:	e0bffe17 	ldw	r2,-8(fp)
  20aaa4:	10800883 	ldbu	r2,34(r2)
  20aaa8:	10bfffc4 	addi	r2,r2,-1
  20aaac:	1007883a 	mov	r3,r2
  20aab0:	e0bffe17 	ldw	r2,-8(fp)
  20aab4:	10c00885 	stb	r3,34(r2)
}
  20aab8:	0001883a 	nop
  20aabc:	e6ffff04 	addi	sp,fp,-4
  20aac0:	dfc00217 	ldw	ra,8(sp)
  20aac4:	df000117 	ldw	fp,4(sp)
  20aac8:	dc000017 	ldw	r16,0(sp)
  20aacc:	dec00304 	addi	sp,sp,12
  20aad0:	f800283a 	ret

0020aad4 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
  20aad4:	defff904 	addi	sp,sp,-28
  20aad8:	dfc00615 	stw	ra,24(sp)
  20aadc:	df000515 	stw	fp,20(sp)
  20aae0:	df000504 	addi	fp,sp,20
  20aae4:	e13ffe15 	stw	r4,-8(fp)
  20aae8:	2805883a 	mov	r2,r5
  20aaec:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
  20aaf0:	e03ffb15 	stw	zero,-20(fp)
  20aaf4:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
  20aaf8:	e0bffe17 	ldw	r2,-8(fp)
  20aafc:	10800a03 	ldbu	r2,40(r2)
  20ab00:	10803fcc 	andi	r2,r2,255
  20ab04:	1080201c 	xori	r2,r2,128
  20ab08:	10bfe004 	addi	r2,r2,-128
  20ab0c:	108016d8 	cmpnei	r2,r2,91
  20ab10:	1000451e 	bne	r2,zero,20ac28 <lcd_handle_escape+0x154>
  {
    char * ptr = sp->escape+1;
  20ab14:	e0bffe17 	ldw	r2,-8(fp)
  20ab18:	10800a04 	addi	r2,r2,40
  20ab1c:	10800044 	addi	r2,r2,1
  20ab20:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
  20ab24:	00000e06 	br	20ab60 <lcd_handle_escape+0x8c>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
  20ab28:	01400284 	movi	r5,10
  20ab2c:	e13ffb17 	ldw	r4,-20(fp)
  20ab30:	020d7a80 	call	20d7a8 <__mulsi3>
  20ab34:	1009883a 	mov	r4,r2
  20ab38:	e0bffd17 	ldw	r2,-12(fp)
  20ab3c:	10c00044 	addi	r3,r2,1
  20ab40:	e0fffd15 	stw	r3,-12(fp)
  20ab44:	10800003 	ldbu	r2,0(r2)
  20ab48:	10803fcc 	andi	r2,r2,255
  20ab4c:	1080201c 	xori	r2,r2,128
  20ab50:	10bfe004 	addi	r2,r2,-128
  20ab54:	10bff404 	addi	r2,r2,-48
  20ab58:	2085883a 	add	r2,r4,r2
  20ab5c:	e0bffb15 	stw	r2,-20(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
  20ab60:	d0e01917 	ldw	r3,-32668(gp)
  20ab64:	e0bffd17 	ldw	r2,-12(fp)
  20ab68:	10800003 	ldbu	r2,0(r2)
  20ab6c:	10803fcc 	andi	r2,r2,255
  20ab70:	1080201c 	xori	r2,r2,128
  20ab74:	10bfe004 	addi	r2,r2,-128
  20ab78:	10800044 	addi	r2,r2,1
  20ab7c:	1885883a 	add	r2,r3,r2
  20ab80:	10800003 	ldbu	r2,0(r2)
  20ab84:	10803fcc 	andi	r2,r2,255
  20ab88:	1080010c 	andi	r2,r2,4
  20ab8c:	103fe61e 	bne	r2,zero,20ab28 <_gp+0xffff4a90>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
  20ab90:	e0bffd17 	ldw	r2,-12(fp)
  20ab94:	10800003 	ldbu	r2,0(r2)
  20ab98:	10803fcc 	andi	r2,r2,255
  20ab9c:	1080201c 	xori	r2,r2,128
  20aba0:	10bfe004 	addi	r2,r2,-128
  20aba4:	10800ed8 	cmpnei	r2,r2,59
  20aba8:	1000211e 	bne	r2,zero,20ac30 <lcd_handle_escape+0x15c>
    {
      ptr++;
  20abac:	e0bffd17 	ldw	r2,-12(fp)
  20abb0:	10800044 	addi	r2,r2,1
  20abb4:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
  20abb8:	00000e06 	br	20abf4 <lcd_handle_escape+0x120>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
  20abbc:	01400284 	movi	r5,10
  20abc0:	e13ffc17 	ldw	r4,-16(fp)
  20abc4:	020d7a80 	call	20d7a8 <__mulsi3>
  20abc8:	1009883a 	mov	r4,r2
  20abcc:	e0bffd17 	ldw	r2,-12(fp)
  20abd0:	10c00044 	addi	r3,r2,1
  20abd4:	e0fffd15 	stw	r3,-12(fp)
  20abd8:	10800003 	ldbu	r2,0(r2)
  20abdc:	10803fcc 	andi	r2,r2,255
  20abe0:	1080201c 	xori	r2,r2,128
  20abe4:	10bfe004 	addi	r2,r2,-128
  20abe8:	10bff404 	addi	r2,r2,-48
  20abec:	2085883a 	add	r2,r4,r2
  20abf0:	e0bffc15 	stw	r2,-16(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
  20abf4:	d0e01917 	ldw	r3,-32668(gp)
  20abf8:	e0bffd17 	ldw	r2,-12(fp)
  20abfc:	10800003 	ldbu	r2,0(r2)
  20ac00:	10803fcc 	andi	r2,r2,255
  20ac04:	1080201c 	xori	r2,r2,128
  20ac08:	10bfe004 	addi	r2,r2,-128
  20ac0c:	10800044 	addi	r2,r2,1
  20ac10:	1885883a 	add	r2,r3,r2
  20ac14:	10800003 	ldbu	r2,0(r2)
  20ac18:	10803fcc 	andi	r2,r2,255
  20ac1c:	1080010c 	andi	r2,r2,4
  20ac20:	103fe61e 	bne	r2,zero,20abbc <_gp+0xffff4b24>
  20ac24:	00000206 	br	20ac30 <lcd_handle_escape+0x15c>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
  20ac28:	00bfffc4 	movi	r2,-1
  20ac2c:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
  20ac30:	e0bfff07 	ldb	r2,-4(fp)
  20ac34:	10c012a0 	cmpeqi	r3,r2,74
  20ac38:	1800291e 	bne	r3,zero,20ace0 <lcd_handle_escape+0x20c>
  20ac3c:	10c012c8 	cmpgei	r3,r2,75
  20ac40:	1800031e 	bne	r3,zero,20ac50 <lcd_handle_escape+0x17c>
  20ac44:	10801220 	cmpeqi	r2,r2,72
  20ac48:	1000061e 	bne	r2,zero,20ac64 <lcd_handle_escape+0x190>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
  20ac4c:	00004c06 	br	20ad80 <lcd_handle_escape+0x2ac>
    }
  }
  else
    parm1 = -1;

  switch (c)
  20ac50:	10c012e0 	cmpeqi	r3,r2,75
  20ac54:	1800281e 	bne	r3,zero,20acf8 <lcd_handle_escape+0x224>
  20ac58:	108019a0 	cmpeqi	r2,r2,102
  20ac5c:	1000011e 	bne	r2,zero,20ac64 <lcd_handle_escape+0x190>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
  20ac60:	00004706 	br	20ad80 <lcd_handle_escape+0x2ac>

  switch (c)
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
  20ac64:	e0bffc17 	ldw	r2,-16(fp)
  20ac68:	0080050e 	bge	zero,r2,20ac80 <lcd_handle_escape+0x1ac>
      sp->x = parm2 - 1;
  20ac6c:	e0bffc17 	ldw	r2,-16(fp)
  20ac70:	10bfffc4 	addi	r2,r2,-1
  20ac74:	1007883a 	mov	r3,r2
  20ac78:	e0bffe17 	ldw	r2,-8(fp)
  20ac7c:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
  20ac80:	e0bffb17 	ldw	r2,-20(fp)
  20ac84:	0080390e 	bge	zero,r2,20ad6c <lcd_handle_escape+0x298>
    {
      sp->y = parm1 - 1;
  20ac88:	e0bffb17 	ldw	r2,-20(fp)
  20ac8c:	10bfffc4 	addi	r2,r2,-1
  20ac90:	1007883a 	mov	r3,r2
  20ac94:	e0bffe17 	ldw	r2,-8(fp)
  20ac98:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
  20ac9c:	e0bffe17 	ldw	r2,-8(fp)
  20aca0:	10800883 	ldbu	r2,34(r2)
  20aca4:	10803fcc 	andi	r2,r2,255
  20aca8:	10800170 	cmpltui	r2,r2,5
  20acac:	1000061e 	bne	r2,zero,20acc8 <lcd_handle_escape+0x1f4>
        sp->y = ALT_LCD_HEIGHT * 2;
  20acb0:	e0bffe17 	ldw	r2,-8(fp)
  20acb4:	00c00104 	movi	r3,4
  20acb8:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
  20acbc:	00000206 	br	20acc8 <lcd_handle_escape+0x1f4>
        lcd_scroll_up(sp);
  20acc0:	e13ffe17 	ldw	r4,-8(fp)
  20acc4:	020a9ec0 	call	20a9ec <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
  20acc8:	e0bffe17 	ldw	r2,-8(fp)
  20accc:	10800883 	ldbu	r2,34(r2)
  20acd0:	10803fcc 	andi	r2,r2,255
  20acd4:	108000e8 	cmpgeui	r2,r2,3
  20acd8:	103ff91e 	bne	r2,zero,20acc0 <_gp+0xffff4c28>
        lcd_scroll_up(sp);
    }
    break;
  20acdc:	00002306 	br	20ad6c <lcd_handle_escape+0x298>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
  20ace0:	e0bffb17 	ldw	r2,-20(fp)
  20ace4:	10800098 	cmpnei	r2,r2,2
  20ace8:	1000221e 	bne	r2,zero,20ad74 <lcd_handle_escape+0x2a0>
      lcd_clear_screen(sp);
  20acec:	e13ffe17 	ldw	r4,-8(fp)
  20acf0:	020a6dc0 	call	20a6dc <lcd_clear_screen>
    break;
  20acf4:	00001f06 	br	20ad74 <lcd_handle_escape+0x2a0>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
  20acf8:	e0bffb17 	ldw	r2,-20(fp)
  20acfc:	00801f16 	blt	zero,r2,20ad7c <lcd_handle_escape+0x2a8>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
  20ad00:	e0bffe17 	ldw	r2,-8(fp)
  20ad04:	10800843 	ldbu	r2,33(r2)
  20ad08:	10803fcc 	andi	r2,r2,255
  20ad0c:	10801428 	cmpgeui	r2,r2,80
  20ad10:	10001a1e 	bne	r2,zero,20ad7c <lcd_handle_escape+0x2a8>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
  20ad14:	e0bffe17 	ldw	r2,-8(fp)
  20ad18:	10800883 	ldbu	r2,34(r2)
  20ad1c:	10803fcc 	andi	r2,r2,255
  20ad20:	014018c4 	movi	r5,99
  20ad24:	1009883a 	mov	r4,r2
  20ad28:	020d7a80 	call	20d7a8 <__mulsi3>
  20ad2c:	10801004 	addi	r2,r2,64
  20ad30:	e0fffe17 	ldw	r3,-8(fp)
  20ad34:	1887883a 	add	r3,r3,r2
  20ad38:	e0bffe17 	ldw	r2,-8(fp)
  20ad3c:	10800843 	ldbu	r2,33(r2)
  20ad40:	10803fcc 	andi	r2,r2,255
  20ad44:	1889883a 	add	r4,r3,r2
  20ad48:	e0bffe17 	ldw	r2,-8(fp)
  20ad4c:	10800843 	ldbu	r2,33(r2)
  20ad50:	10803fcc 	andi	r2,r2,255
  20ad54:	00c01404 	movi	r3,80
  20ad58:	1885c83a 	sub	r2,r3,r2
  20ad5c:	100d883a 	mov	r6,r2
  20ad60:	01400804 	movi	r5,32
  20ad64:	020d2d00 	call	20d2d0 <memset>
    }
    break;
  20ad68:	00000406 	br	20ad7c <lcd_handle_escape+0x2a8>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
  20ad6c:	0001883a 	nop
  20ad70:	00000306 	br	20ad80 <lcd_handle_escape+0x2ac>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
  20ad74:	0001883a 	nop
  20ad78:	00000106 	br	20ad80 <lcd_handle_escape+0x2ac>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  20ad7c:	0001883a 	nop
  }
}
  20ad80:	0001883a 	nop
  20ad84:	e037883a 	mov	sp,fp
  20ad88:	dfc00117 	ldw	ra,4(sp)
  20ad8c:	df000017 	ldw	fp,0(sp)
  20ad90:	dec00204 	addi	sp,sp,8
  20ad94:	f800283a 	ret

0020ad98 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
  20ad98:	defff104 	addi	sp,sp,-60
  20ad9c:	dfc00e15 	stw	ra,56(sp)
  20ada0:	df000d15 	stw	fp,52(sp)
  20ada4:	dc400c15 	stw	r17,48(sp)
  20ada8:	dc000b15 	stw	r16,44(sp)
  20adac:	df000d04 	addi	fp,sp,52
  20adb0:	e13ffa15 	stw	r4,-24(fp)
  20adb4:	e17ffb15 	stw	r5,-20(fp)
  20adb8:	e1bffc15 	stw	r6,-16(fp)
  20adbc:	e1fffd15 	stw	r7,-12(fp)
  const char* end = ptr + len;
  20adc0:	e0bffc17 	ldw	r2,-16(fp)
  20adc4:	e0fffb17 	ldw	r3,-20(fp)
  20adc8:	1885883a 	add	r2,r3,r2
  20adcc:	e0bff615 	stw	r2,-40(fp)

  ALT_SEM_PEND (sp->write_lock, 0);

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
  20add0:	e0bffa17 	ldw	r2,-24(fp)
  20add4:	00c00044 	movi	r3,1
  20add8:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
  20addc:	00009b06 	br	20b04c <altera_avalon_lcd_16207_write+0x2b4>
  {
    char c = *ptr;
  20ade0:	e0bffb17 	ldw	r2,-20(fp)
  20ade4:	10800003 	ldbu	r2,0(r2)
  20ade8:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
  20adec:	e0bffa17 	ldw	r2,-24(fp)
  20adf0:	10800903 	ldbu	r2,36(r2)
  20adf4:	10803fcc 	andi	r2,r2,255
  20adf8:	1080201c 	xori	r2,r2,128
  20adfc:	10bfe004 	addi	r2,r2,-128
  20ae00:	10003716 	blt	r2,zero,20aee0 <altera_avalon_lcd_16207_write+0x148>
    {
      unsigned int esccount = sp->esccount;
  20ae04:	e0bffa17 	ldw	r2,-24(fp)
  20ae08:	10800903 	ldbu	r2,36(r2)
  20ae0c:	10803fcc 	andi	r2,r2,255
  20ae10:	1080201c 	xori	r2,r2,128
  20ae14:	10bfe004 	addi	r2,r2,-128
  20ae18:	e0bff815 	stw	r2,-32(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
  20ae1c:	e0bff817 	ldw	r2,-32(fp)
  20ae20:	1000031e 	bne	r2,zero,20ae30 <altera_avalon_lcd_16207_write+0x98>
  20ae24:	e0bff707 	ldb	r2,-36(fp)
  20ae28:	108016d8 	cmpnei	r2,r2,91
  20ae2c:	10000d1e 	bne	r2,zero,20ae64 <altera_avalon_lcd_16207_write+0xcc>
  20ae30:	e0bff817 	ldw	r2,-32(fp)
  20ae34:	10001826 	beq	r2,zero,20ae98 <altera_avalon_lcd_16207_write+0x100>
          (esccount > 0 && !isdigit(c) && c != ';'))
  20ae38:	d0e01917 	ldw	r3,-32668(gp)
  20ae3c:	e0bff707 	ldb	r2,-36(fp)
  20ae40:	10800044 	addi	r2,r2,1
  20ae44:	1885883a 	add	r2,r3,r2
  20ae48:	10800003 	ldbu	r2,0(r2)
  20ae4c:	10803fcc 	andi	r2,r2,255
  20ae50:	1080010c 	andi	r2,r2,4
  20ae54:	1000101e 	bne	r2,zero,20ae98 <altera_avalon_lcd_16207_write+0x100>
  20ae58:	e0bff707 	ldb	r2,-36(fp)
  20ae5c:	10800ee0 	cmpeqi	r2,r2,59
  20ae60:	10000d1e 	bne	r2,zero,20ae98 <altera_avalon_lcd_16207_write+0x100>
      {
        sp->escape[esccount] = 0;
  20ae64:	e0fffa17 	ldw	r3,-24(fp)
  20ae68:	e0bff817 	ldw	r2,-32(fp)
  20ae6c:	1885883a 	add	r2,r3,r2
  20ae70:	10800a04 	addi	r2,r2,40
  20ae74:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
  20ae78:	e0bff707 	ldb	r2,-36(fp)
  20ae7c:	100b883a 	mov	r5,r2
  20ae80:	e13ffa17 	ldw	r4,-24(fp)
  20ae84:	020aad40 	call	20aad4 <lcd_handle_escape>

        sp->esccount = -1;
  20ae88:	e0bffa17 	ldw	r2,-24(fp)
  20ae8c:	00ffffc4 	movi	r3,-1
  20ae90:	10c00905 	stb	r3,36(r2)
  20ae94:	00006a06 	br	20b040 <altera_avalon_lcd_16207_write+0x2a8>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
  20ae98:	e0bffa17 	ldw	r2,-24(fp)
  20ae9c:	10800903 	ldbu	r2,36(r2)
  20aea0:	10803fcc 	andi	r2,r2,255
  20aea4:	108001e8 	cmpgeui	r2,r2,7
  20aea8:	1000651e 	bne	r2,zero,20b040 <altera_avalon_lcd_16207_write+0x2a8>
      {
        sp->escape[esccount] = c;
  20aeac:	e0fffa17 	ldw	r3,-24(fp)
  20aeb0:	e0bff817 	ldw	r2,-32(fp)
  20aeb4:	1885883a 	add	r2,r3,r2
  20aeb8:	10800a04 	addi	r2,r2,40
  20aebc:	e0fff703 	ldbu	r3,-36(fp)
  20aec0:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
  20aec4:	e0bffa17 	ldw	r2,-24(fp)
  20aec8:	10800903 	ldbu	r2,36(r2)
  20aecc:	10800044 	addi	r2,r2,1
  20aed0:	1007883a 	mov	r3,r2
  20aed4:	e0bffa17 	ldw	r2,-24(fp)
  20aed8:	10c00905 	stb	r3,36(r2)
  20aedc:	00005806 	br	20b040 <altera_avalon_lcd_16207_write+0x2a8>
      }
    }
    else if (c == 27) /* ESC */
  20aee0:	e0bff707 	ldb	r2,-36(fp)
  20aee4:	108006d8 	cmpnei	r2,r2,27
  20aee8:	1000031e 	bne	r2,zero,20aef8 <altera_avalon_lcd_16207_write+0x160>
    {
      sp->esccount = 0;
  20aeec:	e0bffa17 	ldw	r2,-24(fp)
  20aef0:	10000905 	stb	zero,36(r2)
  20aef4:	00005206 	br	20b040 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\r')
  20aef8:	e0bff707 	ldb	r2,-36(fp)
  20aefc:	10800358 	cmpnei	r2,r2,13
  20af00:	1000031e 	bne	r2,zero,20af10 <altera_avalon_lcd_16207_write+0x178>
    {
      sp->x = 0;
  20af04:	e0bffa17 	ldw	r2,-24(fp)
  20af08:	10000845 	stb	zero,33(r2)
  20af0c:	00004c06 	br	20b040 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\n')
  20af10:	e0bff707 	ldb	r2,-36(fp)
  20af14:	10800298 	cmpnei	r2,r2,10
  20af18:	1000101e 	bne	r2,zero,20af5c <altera_avalon_lcd_16207_write+0x1c4>
    {
      sp->x = 0;
  20af1c:	e0bffa17 	ldw	r2,-24(fp)
  20af20:	10000845 	stb	zero,33(r2)
      sp->y++;
  20af24:	e0bffa17 	ldw	r2,-24(fp)
  20af28:	10800883 	ldbu	r2,34(r2)
  20af2c:	10800044 	addi	r2,r2,1
  20af30:	1007883a 	mov	r3,r2
  20af34:	e0bffa17 	ldw	r2,-24(fp)
  20af38:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
  20af3c:	e0bffa17 	ldw	r2,-24(fp)
  20af40:	10800883 	ldbu	r2,34(r2)
  20af44:	10803fcc 	andi	r2,r2,255
  20af48:	108000f0 	cmpltui	r2,r2,3
  20af4c:	10003c1e 	bne	r2,zero,20b040 <altera_avalon_lcd_16207_write+0x2a8>
        lcd_scroll_up(sp);
  20af50:	e13ffa17 	ldw	r4,-24(fp)
  20af54:	020a9ec0 	call	20a9ec <lcd_scroll_up>
  20af58:	00003906 	br	20b040 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\b')
  20af5c:	e0bff707 	ldb	r2,-36(fp)
  20af60:	10800218 	cmpnei	r2,r2,8
  20af64:	10000b1e 	bne	r2,zero,20af94 <altera_avalon_lcd_16207_write+0x1fc>
    {
      if (sp->x > 0)
  20af68:	e0bffa17 	ldw	r2,-24(fp)
  20af6c:	10800843 	ldbu	r2,33(r2)
  20af70:	10803fcc 	andi	r2,r2,255
  20af74:	10003226 	beq	r2,zero,20b040 <altera_avalon_lcd_16207_write+0x2a8>
        sp->x--;
  20af78:	e0bffa17 	ldw	r2,-24(fp)
  20af7c:	10800843 	ldbu	r2,33(r2)
  20af80:	10bfffc4 	addi	r2,r2,-1
  20af84:	1007883a 	mov	r3,r2
  20af88:	e0bffa17 	ldw	r2,-24(fp)
  20af8c:	10c00845 	stb	r3,33(r2)
  20af90:	00002b06 	br	20b040 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (isprint(c))
  20af94:	d0e01917 	ldw	r3,-32668(gp)
  20af98:	e0bff707 	ldb	r2,-36(fp)
  20af9c:	10800044 	addi	r2,r2,1
  20afa0:	1885883a 	add	r2,r3,r2
  20afa4:	10800003 	ldbu	r2,0(r2)
  20afa8:	10803fcc 	andi	r2,r2,255
  20afac:	1080201c 	xori	r2,r2,128
  20afb0:	10bfe004 	addi	r2,r2,-128
  20afb4:	108025cc 	andi	r2,r2,151
  20afb8:	10002126 	beq	r2,zero,20b040 <altera_avalon_lcd_16207_write+0x2a8>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
  20afbc:	e0bffa17 	ldw	r2,-24(fp)
  20afc0:	10800883 	ldbu	r2,34(r2)
  20afc4:	10803fcc 	andi	r2,r2,255
  20afc8:	108000b0 	cmpltui	r2,r2,2
  20afcc:	1000021e 	bne	r2,zero,20afd8 <altera_avalon_lcd_16207_write+0x240>
        lcd_scroll_up(sp);
  20afd0:	e13ffa17 	ldw	r4,-24(fp)
  20afd4:	020a9ec0 	call	20a9ec <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
  20afd8:	e0bffa17 	ldw	r2,-24(fp)
  20afdc:	10800843 	ldbu	r2,33(r2)
  20afe0:	10803fcc 	andi	r2,r2,255
  20afe4:	10801428 	cmpgeui	r2,r2,80
  20afe8:	10000f1e 	bne	r2,zero,20b028 <altera_avalon_lcd_16207_write+0x290>
        sp->line[sp->y].data[sp->x] = c;
  20afec:	e0bffa17 	ldw	r2,-24(fp)
  20aff0:	10800883 	ldbu	r2,34(r2)
  20aff4:	10c03fcc 	andi	r3,r2,255
  20aff8:	e0bffa17 	ldw	r2,-24(fp)
  20affc:	10800843 	ldbu	r2,33(r2)
  20b000:	14003fcc 	andi	r16,r2,255
  20b004:	e47ffa17 	ldw	r17,-24(fp)
  20b008:	014018c4 	movi	r5,99
  20b00c:	1809883a 	mov	r4,r3
  20b010:	020d7a80 	call	20d7a8 <__mulsi3>
  20b014:	8885883a 	add	r2,r17,r2
  20b018:	1405883a 	add	r2,r2,r16
  20b01c:	10801004 	addi	r2,r2,64
  20b020:	e0fff703 	ldbu	r3,-36(fp)
  20b024:	10c00005 	stb	r3,0(r2)

      sp->x++;
  20b028:	e0bffa17 	ldw	r2,-24(fp)
  20b02c:	10800843 	ldbu	r2,33(r2)
  20b030:	10800044 	addi	r2,r2,1
  20b034:	1007883a 	mov	r3,r2
  20b038:	e0bffa17 	ldw	r2,-24(fp)
  20b03c:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
  20b040:	e0bffb17 	ldw	r2,-20(fp)
  20b044:	10800044 	addi	r2,r2,1
  20b048:	e0bffb15 	stw	r2,-20(fp)
  20b04c:	e0fffb17 	ldw	r3,-20(fp)
  20b050:	e0bff617 	ldw	r2,-40(fp)
  20b054:	18bf6236 	bltu	r3,r2,20ade0 <_gp+0xffff4d48>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  20b058:	00800404 	movi	r2,16
  20b05c:	e0bff415 	stw	r2,-48(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20b060:	e03ff315 	stw	zero,-52(fp)
  20b064:	00003d06 	br	20b15c <altera_avalon_lcd_16207_write+0x3c4>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
  20b068:	00801404 	movi	r2,80
  20b06c:	e0bff515 	stw	r2,-44(fp)
  20b070:	00001306 	br	20b0c0 <altera_avalon_lcd_16207_write+0x328>
      if (sp->line[y].data[width-1] != ' ')
  20b074:	e0bff517 	ldw	r2,-44(fp)
  20b078:	143fffc4 	addi	r16,r2,-1
  20b07c:	e47ffa17 	ldw	r17,-24(fp)
  20b080:	e0bff317 	ldw	r2,-52(fp)
  20b084:	014018c4 	movi	r5,99
  20b088:	1009883a 	mov	r4,r2
  20b08c:	020d7a80 	call	20d7a8 <__mulsi3>
  20b090:	8885883a 	add	r2,r17,r2
  20b094:	1405883a 	add	r2,r2,r16
  20b098:	10801004 	addi	r2,r2,64
  20b09c:	10800003 	ldbu	r2,0(r2)
  20b0a0:	10803fcc 	andi	r2,r2,255
  20b0a4:	1080201c 	xori	r2,r2,128
  20b0a8:	10bfe004 	addi	r2,r2,-128
  20b0ac:	10800820 	cmpeqi	r2,r2,32
  20b0b0:	10000626 	beq	r2,zero,20b0cc <altera_avalon_lcd_16207_write+0x334>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
  20b0b4:	e0bff517 	ldw	r2,-44(fp)
  20b0b8:	10bfffc4 	addi	r2,r2,-1
  20b0bc:	e0bff515 	stw	r2,-44(fp)
  20b0c0:	e0bff517 	ldw	r2,-44(fp)
  20b0c4:	00bfeb16 	blt	zero,r2,20b074 <_gp+0xffff4fdc>
  20b0c8:	00000106 	br	20b0d0 <altera_avalon_lcd_16207_write+0x338>
      if (sp->line[y].data[width-1] != ' ')
        break;
  20b0cc:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
  20b0d0:	e0bff517 	ldw	r2,-44(fp)
  20b0d4:	10800448 	cmpgei	r2,r2,17
  20b0d8:	1000031e 	bne	r2,zero,20b0e8 <altera_avalon_lcd_16207_write+0x350>
      width = ALT_LCD_WIDTH;
  20b0dc:	00800404 	movi	r2,16
  20b0e0:	e0bff515 	stw	r2,-44(fp)
  20b0e4:	00000306 	br	20b0f4 <altera_avalon_lcd_16207_write+0x35c>
    else
      width++;
  20b0e8:	e0bff517 	ldw	r2,-44(fp)
  20b0ec:	10800044 	addi	r2,r2,1
  20b0f0:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
  20b0f4:	e0bff517 	ldw	r2,-44(fp)
  20b0f8:	1023883a 	mov	r17,r2
  20b0fc:	e43ffa17 	ldw	r16,-24(fp)
  20b100:	e0bff317 	ldw	r2,-52(fp)
  20b104:	014018c4 	movi	r5,99
  20b108:	1009883a 	mov	r4,r2
  20b10c:	020d7a80 	call	20d7a8 <__mulsi3>
  20b110:	8085883a 	add	r2,r16,r2
  20b114:	10802444 	addi	r2,r2,145
  20b118:	14400005 	stb	r17,0(r2)
    if (widthmax < width)
  20b11c:	e0fff417 	ldw	r3,-48(fp)
  20b120:	e0bff517 	ldw	r2,-44(fp)
  20b124:	1880020e 	bge	r3,r2,20b130 <altera_avalon_lcd_16207_write+0x398>
      widthmax = width;
  20b128:	e0bff517 	ldw	r2,-44(fp)
  20b12c:	e0bff415 	stw	r2,-48(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
  20b130:	e43ffa17 	ldw	r16,-24(fp)
  20b134:	e0bff317 	ldw	r2,-52(fp)
  20b138:	014018c4 	movi	r5,99
  20b13c:	1009883a 	mov	r4,r2
  20b140:	020d7a80 	call	20d7a8 <__mulsi3>
  20b144:	8085883a 	add	r2,r16,r2
  20b148:	10802484 	addi	r2,r2,146
  20b14c:	10000005 	stb	zero,0(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20b150:	e0bff317 	ldw	r2,-52(fp)
  20b154:	10800044 	addi	r2,r2,1
  20b158:	e0bff315 	stw	r2,-52(fp)
  20b15c:	e0bff317 	ldw	r2,-52(fp)
  20b160:	10800090 	cmplti	r2,r2,2
  20b164:	103fc01e 	bne	r2,zero,20b068 <_gp+0xffff4fd0>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
  20b168:	e0bff417 	ldw	r2,-48(fp)
  20b16c:	10800448 	cmpgei	r2,r2,17
  20b170:	1000031e 	bne	r2,zero,20b180 <altera_avalon_lcd_16207_write+0x3e8>
    sp->scrollmax = 0;
  20b174:	e0bffa17 	ldw	r2,-24(fp)
  20b178:	10000985 	stb	zero,38(r2)
  20b17c:	00003406 	br	20b250 <altera_avalon_lcd_16207_write+0x4b8>
  else
  {
    widthmax *= 2;
  20b180:	e0bff417 	ldw	r2,-48(fp)
  20b184:	1085883a 	add	r2,r2,r2
  20b188:	e0bff415 	stw	r2,-48(fp)
    sp->scrollmax = widthmax;
  20b18c:	e0bff417 	ldw	r2,-48(fp)
  20b190:	1007883a 	mov	r3,r2
  20b194:	e0bffa17 	ldw	r2,-24(fp)
  20b198:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20b19c:	e03ff315 	stw	zero,-52(fp)
  20b1a0:	00002806 	br	20b244 <altera_avalon_lcd_16207_write+0x4ac>
      if (sp->line[y].width > ALT_LCD_WIDTH)
  20b1a4:	e43ffa17 	ldw	r16,-24(fp)
  20b1a8:	e0bff317 	ldw	r2,-52(fp)
  20b1ac:	014018c4 	movi	r5,99
  20b1b0:	1009883a 	mov	r4,r2
  20b1b4:	020d7a80 	call	20d7a8 <__mulsi3>
  20b1b8:	8085883a 	add	r2,r16,r2
  20b1bc:	10802444 	addi	r2,r2,145
  20b1c0:	10800003 	ldbu	r2,0(r2)
  20b1c4:	10803fcc 	andi	r2,r2,255
  20b1c8:	1080201c 	xori	r2,r2,128
  20b1cc:	10bfe004 	addi	r2,r2,-128
  20b1d0:	10800450 	cmplti	r2,r2,17
  20b1d4:	1000181e 	bne	r2,zero,20b238 <altera_avalon_lcd_16207_write+0x4a0>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
  20b1d8:	e43ffa17 	ldw	r16,-24(fp)
  20b1dc:	e0bff317 	ldw	r2,-52(fp)
  20b1e0:	014018c4 	movi	r5,99
  20b1e4:	1009883a 	mov	r4,r2
  20b1e8:	020d7a80 	call	20d7a8 <__mulsi3>
  20b1ec:	8085883a 	add	r2,r16,r2
  20b1f0:	10802444 	addi	r2,r2,145
  20b1f4:	10800003 	ldbu	r2,0(r2)
  20b1f8:	10803fcc 	andi	r2,r2,255
  20b1fc:	1080201c 	xori	r2,r2,128
  20b200:	10bfe004 	addi	r2,r2,-128
  20b204:	1004923a 	slli	r2,r2,8
  20b208:	e17ff417 	ldw	r5,-48(fp)
  20b20c:	1009883a 	mov	r4,r2
  20b210:	020d5f40 	call	20d5f4 <__divsi3>
  20b214:	1023883a 	mov	r17,r2
  20b218:	e43ffa17 	ldw	r16,-24(fp)
  20b21c:	e0bff317 	ldw	r2,-52(fp)
  20b220:	014018c4 	movi	r5,99
  20b224:	1009883a 	mov	r4,r2
  20b228:	020d7a80 	call	20d7a8 <__mulsi3>
  20b22c:	8085883a 	add	r2,r16,r2
  20b230:	10802484 	addi	r2,r2,146
  20b234:	14400005 	stb	r17,0(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  20b238:	e0bff317 	ldw	r2,-52(fp)
  20b23c:	10800044 	addi	r2,r2,1
  20b240:	e0bff315 	stw	r2,-52(fp)
  20b244:	e0bff317 	ldw	r2,-52(fp)
  20b248:	10800090 	cmplti	r2,r2,2
  20b24c:	103fd51e 	bne	r2,zero,20b1a4 <_gp+0xffff510c>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
  20b250:	e0bffa17 	ldw	r2,-24(fp)
  20b254:	10800943 	ldbu	r2,37(r2)
  20b258:	10803fcc 	andi	r2,r2,255
  20b25c:	e0bff915 	stw	r2,-28(fp)

    lcd_repaint_screen(sp);
  20b260:	e13ffa17 	ldw	r4,-24(fp)
  20b264:	020a7c40 	call	20a7c4 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
  20b268:	e0bffa17 	ldw	r2,-24(fp)
  20b26c:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
  20b270:	e0bffa17 	ldw	r2,-24(fp)
  20b274:	10800943 	ldbu	r2,37(r2)
  20b278:	10c03fcc 	andi	r3,r2,255
  20b27c:	e0bff917 	ldw	r2,-28(fp)
  20b280:	18800426 	beq	r3,r2,20b294 <altera_avalon_lcd_16207_write+0x4fc>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
  20b284:	e0bffa17 	ldw	r2,-24(fp)
  20b288:	00c00044 	movi	r3,1
  20b28c:	10c009c5 	stb	r3,39(r2)
  }
  20b290:	003fef06 	br	20b250 <_gp+0xffff51b8>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
  20b294:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);

  return len;
  20b298:	e0bffc17 	ldw	r2,-16(fp)
}
  20b29c:	e6fffe04 	addi	sp,fp,-8
  20b2a0:	dfc00317 	ldw	ra,12(sp)
  20b2a4:	df000217 	ldw	fp,8(sp)
  20b2a8:	dc400117 	ldw	r17,4(sp)
  20b2ac:	dc000017 	ldw	r16,0(sp)
  20b2b0:	dec00404 	addi	sp,sp,16
  20b2b4:	f800283a 	ret

0020b2b8 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
  20b2b8:	defffc04 	addi	sp,sp,-16
  20b2bc:	dfc00315 	stw	ra,12(sp)
  20b2c0:	df000215 	stw	fp,8(sp)
  20b2c4:	df000204 	addi	fp,sp,8
  20b2c8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
  20b2cc:	e0bfff17 	ldw	r2,-4(fp)
  20b2d0:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
  20b2d4:	e0bffe17 	ldw	r2,-8(fp)
  20b2d8:	10800943 	ldbu	r2,37(r2)
  20b2dc:	10803fcc 	andi	r2,r2,255
  20b2e0:	10c00044 	addi	r3,r2,1
  20b2e4:	e0bffe17 	ldw	r2,-8(fp)
  20b2e8:	10800983 	ldbu	r2,38(r2)
  20b2ec:	10803fcc 	andi	r2,r2,255
  20b2f0:	18800316 	blt	r3,r2,20b300 <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
  20b2f4:	e0bffe17 	ldw	r2,-8(fp)
  20b2f8:	10000945 	stb	zero,37(r2)
  20b2fc:	00000606 	br	20b318 <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
  20b300:	e0bffe17 	ldw	r2,-8(fp)
  20b304:	10800943 	ldbu	r2,37(r2)
  20b308:	10800044 	addi	r2,r2,1
  20b30c:	1007883a 	mov	r3,r2
  20b310:	e0bffe17 	ldw	r2,-8(fp)
  20b314:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
  20b318:	e0bffe17 	ldw	r2,-8(fp)
  20b31c:	10800983 	ldbu	r2,38(r2)
  20b320:	10803fcc 	andi	r2,r2,255
  20b324:	10000826 	beq	r2,zero,20b348 <alt_lcd_16207_timeout+0x90>
  20b328:	e0bffe17 	ldw	r2,-8(fp)
  20b32c:	108009c3 	ldbu	r2,39(r2)
  20b330:	10803fcc 	andi	r2,r2,255
  20b334:	1080201c 	xori	r2,r2,128
  20b338:	10bfe004 	addi	r2,r2,-128
  20b33c:	1000021e 	bne	r2,zero,20b348 <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
  20b340:	e13ffe17 	ldw	r4,-8(fp)
  20b344:	020a7c40 	call	20a7c4 <lcd_repaint_screen>

  return sp->period;
  20b348:	e0bffe17 	ldw	r2,-8(fp)
  20b34c:	10800717 	ldw	r2,28(r2)
}
  20b350:	e037883a 	mov	sp,fp
  20b354:	dfc00117 	ldw	ra,4(sp)
  20b358:	df000017 	ldw	fp,0(sp)
  20b35c:	dec00204 	addi	sp,sp,8
  20b360:	f800283a 	ret

0020b364 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
  20b364:	defffc04 	addi	sp,sp,-16
  20b368:	dfc00315 	stw	ra,12(sp)
  20b36c:	df000215 	stw	fp,8(sp)
  20b370:	df000204 	addi	fp,sp,8
  20b374:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
  20b378:	e0bfff17 	ldw	r2,-4(fp)
  20b37c:	10800017 	ldw	r2,0(r2)
  20b380:	e0bffe15 	stw	r2,-8(fp)

  /* Mark the device as functional */
  sp->broken = 0;
  20b384:	e0bfff17 	ldw	r2,-4(fp)
  20b388:	10000805 	stb	zero,32(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
  20b38c:	010ea604 	movi	r4,15000
  20b390:	020cecc0 	call	20cecc <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
  20b394:	e0bffe17 	ldw	r2,-8(fp)
  20b398:	00c00c04 	movi	r3,48
  20b39c:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
  20b3a0:	01040104 	movi	r4,4100
  20b3a4:	020cecc0 	call	20cecc <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
  20b3a8:	e0bffe17 	ldw	r2,-8(fp)
  20b3ac:	00c00c04 	movi	r3,48
  20b3b0:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
  20b3b4:	0100fa04 	movi	r4,1000
  20b3b8:	020cecc0 	call	20cecc <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
  20b3bc:	e0bffe17 	ldw	r2,-8(fp)
  20b3c0:	00c00c04 	movi	r3,48
  20b3c4:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
  20b3c8:	01400e04 	movi	r5,56
  20b3cc:	e13fff17 	ldw	r4,-4(fp)
  20b3d0:	020a54c0 	call	20a54c <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
  20b3d4:	01400204 	movi	r5,8
  20b3d8:	e13fff17 	ldw	r4,-4(fp)
  20b3dc:	020a54c0 	call	20a54c <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
  20b3e0:	e13fff17 	ldw	r4,-4(fp)
  20b3e4:	020a6dc0 	call	20a6dc <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
  20b3e8:	01400184 	movi	r5,6
  20b3ec:	e13fff17 	ldw	r4,-4(fp)
  20b3f0:	020a54c0 	call	20a54c <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
  20b3f4:	01400304 	movi	r5,12
  20b3f8:	e13fff17 	ldw	r4,-4(fp)
  20b3fc:	020a54c0 	call	20a54c <lcd_write_command>

  sp->esccount = -1;
  20b400:	e0bfff17 	ldw	r2,-4(fp)
  20b404:	00ffffc4 	movi	r3,-1
  20b408:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
  20b40c:	e0bfff17 	ldw	r2,-4(fp)
  20b410:	10800a04 	addi	r2,r2,40
  20b414:	01800204 	movi	r6,8
  20b418:	000b883a 	mov	r5,zero
  20b41c:	1009883a 	mov	r4,r2
  20b420:	020d2d00 	call	20d2d0 <memset>

  sp->scrollpos = 0;
  20b424:	e0bfff17 	ldw	r2,-4(fp)
  20b428:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
  20b42c:	e0bfff17 	ldw	r2,-4(fp)
  20b430:	10000985 	stb	zero,38(r2)
  sp->active = 0;
  20b434:	e0bfff17 	ldw	r2,-4(fp)
  20b438:	100009c5 	stb	zero,39(r2)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  20b43c:	d0a1a317 	ldw	r2,-31092(gp)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
  20b440:	01400284 	movi	r5,10
  20b444:	1009883a 	mov	r4,r2
  20b448:	020d6ec0 	call	20d6ec <__udivsi3>
  20b44c:	1007883a 	mov	r3,r2
  20b450:	e0bfff17 	ldw	r2,-4(fp)
  20b454:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
  20b458:	e0bfff17 	ldw	r2,-4(fp)
  20b45c:	10c00104 	addi	r3,r2,4
  20b460:	e0bfff17 	ldw	r2,-4(fp)
  20b464:	10800717 	ldw	r2,28(r2)
  20b468:	e1ffff17 	ldw	r7,-4(fp)
  20b46c:	01800874 	movhi	r6,33
  20b470:	31acae04 	addi	r6,r6,-19784
  20b474:	100b883a 	mov	r5,r2
  20b478:	1809883a 	mov	r4,r3
  20b47c:	020c3200 	call	20c320 <alt_alarm_start>
}
  20b480:	0001883a 	nop
  20b484:	e037883a 	mov	sp,fp
  20b488:	dfc00117 	ldw	ra,4(sp)
  20b48c:	df000017 	ldw	fp,0(sp)
  20b490:	dec00204 	addi	sp,sp,8
  20b494:	f800283a 	ret

0020b498 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  20b498:	defffe04 	addi	sp,sp,-8
  20b49c:	dfc00115 	stw	ra,4(sp)
  20b4a0:	df000015 	stw	fp,0(sp)
  20b4a4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  20b4a8:	d0a01617 	ldw	r2,-32680(gp)
  20b4ac:	10000326 	beq	r2,zero,20b4bc <alt_get_errno+0x24>
  20b4b0:	d0a01617 	ldw	r2,-32680(gp)
  20b4b4:	103ee83a 	callr	r2
  20b4b8:	00000106 	br	20b4c0 <alt_get_errno+0x28>
  20b4bc:	d0a1a504 	addi	r2,gp,-31084
}
  20b4c0:	e037883a 	mov	sp,fp
  20b4c4:	dfc00117 	ldw	ra,4(sp)
  20b4c8:	df000017 	ldw	fp,0(sp)
  20b4cc:	dec00204 	addi	sp,sp,8
  20b4d0:	f800283a 	ret

0020b4d4 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
  20b4d4:	defffc04 	addi	sp,sp,-16
  20b4d8:	df000315 	stw	fp,12(sp)
  20b4dc:	df000304 	addi	fp,sp,12
  20b4e0:	e13ffe15 	stw	r4,-8(fp)
  20b4e4:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  20b4e8:	e0bffe17 	ldw	r2,-8(fp)
  20b4ec:	10800317 	ldw	r2,12(r2)
  20b4f0:	10800037 	ldwio	r2,0(r2)
  20b4f4:	1080040c 	andi	r2,r2,16
  20b4f8:	10000226 	beq	r2,zero,20b504 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  20b4fc:	00bffc04 	movi	r2,-16
  20b500:	00003906 	br	20b5e8 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  20b504:	e0bffe17 	ldw	r2,-8(fp)
  20b508:	10800317 	ldw	r2,12(r2)
  20b50c:	10800404 	addi	r2,r2,16
  20b510:	e0fffe17 	ldw	r3,-8(fp)
  20b514:	18c00317 	ldw	r3,12(r3)
  20b518:	18c00404 	addi	r3,r3,16
  20b51c:	19000037 	ldwio	r4,0(r3)
  20b520:	00fff7c4 	movi	r3,-33
  20b524:	20c6703a 	and	r3,r4,r3
  20b528:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  20b52c:	e0bffe17 	ldw	r2,-8(fp)
  20b530:	10800317 	ldw	r2,12(r2)
  20b534:	00c03fc4 	movi	r3,255
  20b538:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  20b53c:	e0bffe17 	ldw	r2,-8(fp)
  20b540:	10800317 	ldw	r2,12(r2)
  20b544:	10800804 	addi	r2,r2,32
  20b548:	e0ffff17 	ldw	r3,-4(fp)
  20b54c:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
  20b550:	e0bffe17 	ldw	r2,-8(fp)
  20b554:	10800917 	ldw	r2,36(r2)
  20b558:	10001126 	beq	r2,zero,20b5a0 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  20b55c:	e0bffe17 	ldw	r2,-8(fp)
  20b560:	10800317 	ldw	r2,12(r2)
  20b564:	10800404 	addi	r2,r2,16
  20b568:	10800037 	ldwio	r2,0(r2)
  20b56c:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
  20b570:	e0bffe17 	ldw	r2,-8(fp)
  20b574:	10c00b17 	ldw	r3,44(r2)
  20b578:	e0bffd17 	ldw	r2,-12(fp)
  20b57c:	1884b03a 	or	r2,r3,r2
  20b580:	10801814 	ori	r2,r2,96
  20b584:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  20b588:	e0bffe17 	ldw	r2,-8(fp)
  20b58c:	10800317 	ldw	r2,12(r2)
  20b590:	10800404 	addi	r2,r2,16
  20b594:	e0fffd17 	ldw	r3,-12(fp)
  20b598:	10c00035 	stwio	r3,0(r2)
  20b59c:	00001106 	br	20b5e4 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  20b5a0:	e0bffe17 	ldw	r2,-8(fp)
  20b5a4:	10800317 	ldw	r2,12(r2)
  20b5a8:	10800404 	addi	r2,r2,16
  20b5ac:	10800037 	ldwio	r2,0(r2)
  20b5b0:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
  20b5b4:	e0bffd17 	ldw	r2,-12(fp)
  20b5b8:	10801814 	ori	r2,r2,96
  20b5bc:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
  20b5c0:	e0fffd17 	ldw	r3,-12(fp)
  20b5c4:	00bffbc4 	movi	r2,-17
  20b5c8:	1884703a 	and	r2,r3,r2
  20b5cc:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  20b5d0:	e0bffe17 	ldw	r2,-8(fp)
  20b5d4:	10800317 	ldw	r2,12(r2)
  20b5d8:	10800404 	addi	r2,r2,16
  20b5dc:	e0fffd17 	ldw	r3,-12(fp)
  20b5e0:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
  20b5e4:	0005883a 	mov	r2,zero
}
  20b5e8:	e037883a 	mov	sp,fp
  20b5ec:	df000017 	ldw	fp,0(sp)
  20b5f0:	dec00104 	addi	sp,sp,4
  20b5f4:	f800283a 	ret

0020b5f8 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
  20b5f8:	defffc04 	addi	sp,sp,-16
  20b5fc:	df000315 	stw	fp,12(sp)
  20b600:	df000304 	addi	fp,sp,12
  20b604:	e13ffe15 	stw	r4,-8(fp)
  20b608:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  20b60c:	0001883a 	nop
  20b610:	e0bffe17 	ldw	r2,-8(fp)
  20b614:	10800317 	ldw	r2,12(r2)
  20b618:	10800037 	ldwio	r2,0(r2)
  20b61c:	1080040c 	andi	r2,r2,16
  20b620:	103ffb1e 	bne	r2,zero,20b610 <_gp+0xffff5578>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  20b624:	e0bffe17 	ldw	r2,-8(fp)
  20b628:	10800317 	ldw	r2,12(r2)
  20b62c:	10800404 	addi	r2,r2,16
  20b630:	e0fffe17 	ldw	r3,-8(fp)
  20b634:	18c00317 	ldw	r3,12(r3)
  20b638:	18c00404 	addi	r3,r3,16
  20b63c:	19000037 	ldwio	r4,0(r3)
  20b640:	00fff7c4 	movi	r3,-33
  20b644:	20c6703a 	and	r3,r4,r3
  20b648:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  20b64c:	e0bffe17 	ldw	r2,-8(fp)
  20b650:	10800317 	ldw	r2,12(r2)
  20b654:	00c03fc4 	movi	r3,255
  20b658:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  20b65c:	e0bffe17 	ldw	r2,-8(fp)
  20b660:	10800317 	ldw	r2,12(r2)
  20b664:	10800804 	addi	r2,r2,32
  20b668:	e0ffff17 	ldw	r3,-4(fp)
  20b66c:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  20b670:	e0bffe17 	ldw	r2,-8(fp)
  20b674:	10800317 	ldw	r2,12(r2)
  20b678:	10800404 	addi	r2,r2,16
  20b67c:	e0fffe17 	ldw	r3,-8(fp)
  20b680:	18c00317 	ldw	r3,12(r3)
  20b684:	18c00404 	addi	r3,r3,16
  20b688:	18c00037 	ldwio	r3,0(r3)
  20b68c:	18c01814 	ori	r3,r3,96
  20b690:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  20b694:	0001883a 	nop
  20b698:	e0bffe17 	ldw	r2,-8(fp)
  20b69c:	10800317 	ldw	r2,12(r2)
  20b6a0:	10800037 	ldwio	r2,0(r2)
  20b6a4:	1080040c 	andi	r2,r2,16
  20b6a8:	103ffb1e 	bne	r2,zero,20b698 <_gp+0xffff5600>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  20b6ac:	e0bffe17 	ldw	r2,-8(fp)
  20b6b0:	10800317 	ldw	r2,12(r2)
  20b6b4:	10800404 	addi	r2,r2,16
  20b6b8:	e0fffe17 	ldw	r3,-8(fp)
  20b6bc:	18c00317 	ldw	r3,12(r3)
  20b6c0:	18c00404 	addi	r3,r3,16
  20b6c4:	19000037 	ldwio	r4,0(r3)
  20b6c8:	00fff7c4 	movi	r3,-33
  20b6cc:	20c6703a 	and	r3,r4,r3
  20b6d0:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
  20b6d4:	e0bffe17 	ldw	r2,-8(fp)
  20b6d8:	10800317 	ldw	r2,12(r2)
  20b6dc:	10800037 	ldwio	r2,0(r2)
  20b6e0:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  20b6e4:	e0bffe17 	ldw	r2,-8(fp)
  20b6e8:	10800317 	ldw	r2,12(r2)
  20b6ec:	00c03fc4 	movi	r3,255
  20b6f0:	10c00035 	stwio	r3,0(r2)

  return status;
  20b6f4:	e0bffd03 	ldbu	r2,-12(fp)
}
  20b6f8:	e037883a 	mov	sp,fp
  20b6fc:	df000017 	ldw	fp,0(sp)
  20b700:	dec00104 	addi	sp,sp,4
  20b704:	f800283a 	ret

0020b708 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
  20b708:	defff404 	addi	sp,sp,-48
  20b70c:	dfc00b15 	stw	ra,44(sp)
  20b710:	df000a15 	stw	fp,40(sp)
  20b714:	df000a04 	addi	fp,sp,40
  20b718:	e13ffb15 	stw	r4,-20(fp)
  20b71c:	e17ffc15 	stw	r5,-16(fp)
  20b720:	e1bffd15 	stw	r6,-12(fp)
  20b724:	e1fffe15 	stw	r7,-8(fp)
  20b728:	e0800217 	ldw	r2,8(fp)
  20b72c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
  20b730:	e0bfff0b 	ldhu	r2,-4(fp)
  20b734:	d8000415 	stw	zero,16(sp)
  20b738:	d8000315 	stw	zero,12(sp)
  20b73c:	e0c00417 	ldw	r3,16(fp)
  20b740:	d8c00215 	stw	r3,8(sp)
  20b744:	e0c00317 	ldw	r3,12(fp)
  20b748:	d8c00115 	stw	r3,4(sp)
  20b74c:	d8800015 	stw	r2,0(sp)
  20b750:	e1fffe17 	ldw	r7,-8(fp)
  20b754:	e1bffd17 	ldw	r6,-12(fp)
  20b758:	e17ffc17 	ldw	r5,-16(fp)
  20b75c:	e13ffb17 	ldw	r4,-20(fp)
  20b760:	020b77c0 	call	20b77c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
  20b764:	0001883a 	nop
  20b768:	e037883a 	mov	sp,fp
  20b76c:	dfc00117 	ldw	ra,4(sp)
  20b770:	df000017 	ldw	fp,0(sp)
  20b774:	dec00204 	addi	sp,sp,8
  20b778:	f800283a 	ret

0020b77c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
  20b77c:	defff204 	addi	sp,sp,-56
  20b780:	dfc00d15 	stw	ra,52(sp)
  20b784:	df000c15 	stw	fp,48(sp)
  20b788:	df000c04 	addi	fp,sp,48
  20b78c:	e13ffb15 	stw	r4,-20(fp)
  20b790:	e17ffc15 	stw	r5,-16(fp)
  20b794:	e1bffd15 	stw	r6,-12(fp)
  20b798:	e1fffe15 	stw	r7,-8(fp)
  20b79c:	e0800217 	ldw	r2,8(fp)
  20b7a0:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
  20b7a4:	e0bfff0b 	ldhu	r2,-4(fp)
  20b7a8:	d8000615 	stw	zero,24(sp)
  20b7ac:	e0c00617 	ldw	r3,24(fp)
  20b7b0:	d8c00515 	stw	r3,20(sp)
  20b7b4:	e0c00517 	ldw	r3,20(fp)
  20b7b8:	d8c00415 	stw	r3,16(sp)
  20b7bc:	e0c00417 	ldw	r3,16(fp)
  20b7c0:	d8c00315 	stw	r3,12(sp)
  20b7c4:	e0c00317 	ldw	r3,12(fp)
  20b7c8:	d8c00215 	stw	r3,8(sp)
  20b7cc:	d8000115 	stw	zero,4(sp)
  20b7d0:	d8800015 	stw	r2,0(sp)
  20b7d4:	e1fffe17 	ldw	r7,-8(fp)
  20b7d8:	e1bffd17 	ldw	r6,-12(fp)
  20b7dc:	e17ffc17 	ldw	r5,-16(fp)
  20b7e0:	e13ffb17 	ldw	r4,-20(fp)
  20b7e4:	020bd100 	call	20bd10 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
  20b7e8:	0001883a 	nop
  20b7ec:	e037883a 	mov	sp,fp
  20b7f0:	dfc00117 	ldw	ra,4(sp)
  20b7f4:	df000017 	ldw	fp,0(sp)
  20b7f8:	dec00204 	addi	sp,sp,8
  20b7fc:	f800283a 	ret

0020b800 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
  20b800:	defff804 	addi	sp,sp,-32
  20b804:	dfc00715 	stw	ra,28(sp)
  20b808:	df000615 	stw	fp,24(sp)
  20b80c:	df000604 	addi	fp,sp,24
  20b810:	e13ffc15 	stw	r4,-16(fp)
  20b814:	e17ffd15 	stw	r5,-12(fp)
  20b818:	e1bffe15 	stw	r6,-8(fp)
  20b81c:	3805883a 	mov	r2,r7
  20b820:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
  20b824:	e0ffff0b 	ldhu	r3,-4(fp)
  20b828:	d8000115 	stw	zero,4(sp)
  20b82c:	e0800217 	ldw	r2,8(fp)
  20b830:	d8800015 	stw	r2,0(sp)
  20b834:	180f883a 	mov	r7,r3
  20b838:	e1bffe17 	ldw	r6,-8(fp)
  20b83c:	e17ffd17 	ldw	r5,-12(fp)
  20b840:	e13ffc17 	ldw	r4,-16(fp)
  20b844:	020b8600 	call	20b860 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
  20b848:	0001883a 	nop
  20b84c:	e037883a 	mov	sp,fp
  20b850:	dfc00117 	ldw	ra,4(sp)
  20b854:	df000017 	ldw	fp,0(sp)
  20b858:	dec00204 	addi	sp,sp,8
  20b85c:	f800283a 	ret

0020b860 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
  20b860:	defff304 	addi	sp,sp,-52
  20b864:	dfc00c15 	stw	ra,48(sp)
  20b868:	df000b15 	stw	fp,44(sp)
  20b86c:	df000b04 	addi	fp,sp,44
  20b870:	e13ffc15 	stw	r4,-16(fp)
  20b874:	e17ffd15 	stw	r5,-12(fp)
  20b878:	e1bffe15 	stw	r6,-8(fp)
  20b87c:	3805883a 	mov	r2,r7
  20b880:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
  20b884:	e0bfff0b 	ldhu	r2,-4(fp)
  20b888:	d8000615 	stw	zero,24(sp)
  20b88c:	e0c00317 	ldw	r3,12(fp)
  20b890:	d8c00515 	stw	r3,20(sp)
  20b894:	d8000415 	stw	zero,16(sp)
  20b898:	e0c00217 	ldw	r3,8(fp)
  20b89c:	d8c00315 	stw	r3,12(sp)
  20b8a0:	d8000215 	stw	zero,8(sp)
  20b8a4:	d8000115 	stw	zero,4(sp)
  20b8a8:	d8800015 	stw	r2,0(sp)
  20b8ac:	e1fffe17 	ldw	r7,-8(fp)
  20b8b0:	000d883a 	mov	r6,zero
  20b8b4:	e17ffd17 	ldw	r5,-12(fp)
  20b8b8:	e13ffc17 	ldw	r4,-16(fp)
  20b8bc:	020bd100 	call	20bd10 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
  20b8c0:	0001883a 	nop
  20b8c4:	e037883a 	mov	sp,fp
  20b8c8:	dfc00117 	ldw	ra,4(sp)
  20b8cc:	df000017 	ldw	fp,0(sp)
  20b8d0:	dec00204 	addi	sp,sp,8
  20b8d4:	f800283a 	ret

0020b8d8 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
  20b8d8:	defff404 	addi	sp,sp,-48
  20b8dc:	dfc00b15 	stw	ra,44(sp)
  20b8e0:	df000a15 	stw	fp,40(sp)
  20b8e4:	df000a04 	addi	fp,sp,40
  20b8e8:	e13ffb15 	stw	r4,-20(fp)
  20b8ec:	e17ffc15 	stw	r5,-16(fp)
  20b8f0:	e1bffd15 	stw	r6,-12(fp)
  20b8f4:	3807883a 	mov	r3,r7
  20b8f8:	e0800517 	ldw	r2,20(fp)
  20b8fc:	e0fffe0d 	sth	r3,-8(fp)
  20b900:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
  20b904:	e0fffe0b 	ldhu	r3,-8(fp)
  20b908:	e0bfff03 	ldbu	r2,-4(fp)
  20b90c:	d8800415 	stw	r2,16(sp)
  20b910:	d8000315 	stw	zero,12(sp)
  20b914:	e0800417 	ldw	r2,16(fp)
  20b918:	d8800215 	stw	r2,8(sp)
  20b91c:	e0800317 	ldw	r2,12(fp)
  20b920:	d8800115 	stw	r2,4(sp)
  20b924:	e0800217 	ldw	r2,8(fp)
  20b928:	d8800015 	stw	r2,0(sp)
  20b92c:	180f883a 	mov	r7,r3
  20b930:	e1bffd17 	ldw	r6,-12(fp)
  20b934:	e17ffc17 	ldw	r5,-16(fp)
  20b938:	e13ffb17 	ldw	r4,-20(fp)
  20b93c:	020b9580 	call	20b958 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
  20b940:	0001883a 	nop
  20b944:	e037883a 	mov	sp,fp
  20b948:	dfc00117 	ldw	ra,4(sp)
  20b94c:	df000017 	ldw	fp,0(sp)
  20b950:	dec00204 	addi	sp,sp,8
  20b954:	f800283a 	ret

0020b958 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
  20b958:	defff204 	addi	sp,sp,-56
  20b95c:	dfc00d15 	stw	ra,52(sp)
  20b960:	df000c15 	stw	fp,48(sp)
  20b964:	df000c04 	addi	fp,sp,48
  20b968:	e13ffb15 	stw	r4,-20(fp)
  20b96c:	e17ffc15 	stw	r5,-16(fp)
  20b970:	e1bffd15 	stw	r6,-12(fp)
  20b974:	3807883a 	mov	r3,r7
  20b978:	e0800617 	ldw	r2,24(fp)
  20b97c:	e0fffe0d 	sth	r3,-8(fp)
  20b980:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
  20b984:	e0bffe0b 	ldhu	r2,-8(fp)
  20b988:	e0ffff03 	ldbu	r3,-4(fp)
  20b98c:	d8c00615 	stw	r3,24(sp)
  20b990:	d8000515 	stw	zero,20(sp)
  20b994:	e0c00517 	ldw	r3,20(fp)
  20b998:	d8c00415 	stw	r3,16(sp)
  20b99c:	e0c00317 	ldw	r3,12(fp)
  20b9a0:	d8c00315 	stw	r3,12(sp)
  20b9a4:	e0c00217 	ldw	r3,8(fp)
  20b9a8:	d8c00215 	stw	r3,8(sp)
  20b9ac:	e0c00417 	ldw	r3,16(fp)
  20b9b0:	d8c00115 	stw	r3,4(sp)
  20b9b4:	d8800015 	stw	r2,0(sp)
  20b9b8:	000f883a 	mov	r7,zero
  20b9bc:	e1bffd17 	ldw	r6,-12(fp)
  20b9c0:	e17ffc17 	ldw	r5,-16(fp)
  20b9c4:	e13ffb17 	ldw	r4,-20(fp)
  20b9c8:	020bd100 	call	20bd10 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
  20b9cc:	0001883a 	nop
  20b9d0:	e037883a 	mov	sp,fp
  20b9d4:	dfc00117 	ldw	ra,4(sp)
  20b9d8:	df000017 	ldw	fp,0(sp)
  20b9dc:	dec00204 	addi	sp,sp,8
  20b9e0:	f800283a 	ret

0020b9e4 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  20b9e4:	defffb04 	addi	sp,sp,-20
  20b9e8:	df000415 	stw	fp,16(sp)
  20b9ec:	df000404 	addi	fp,sp,16
  20b9f0:	e13ffc15 	stw	r4,-16(fp)
  20b9f4:	e17ffd15 	stw	r5,-12(fp)
  20b9f8:	e1bffe15 	stw	r6,-8(fp)
  20b9fc:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
  20ba00:	e0bffc17 	ldw	r2,-16(fp)
  20ba04:	e0fffd17 	ldw	r3,-12(fp)
  20ba08:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
  20ba0c:	e0bffc17 	ldw	r2,-16(fp)
  20ba10:	e0ffff17 	ldw	r3,-4(fp)
  20ba14:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
  20ba18:	e0bffc17 	ldw	r2,-16(fp)
  20ba1c:	e0fffe17 	ldw	r3,-8(fp)
  20ba20:	10c00b15 	stw	r3,44(r2)
}
  20ba24:	0001883a 	nop
  20ba28:	e037883a 	mov	sp,fp
  20ba2c:	df000017 	ldw	fp,0(sp)
  20ba30:	dec00104 	addi	sp,sp,4
  20ba34:	f800283a 	ret

0020ba38 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  20ba38:	defffd04 	addi	sp,sp,-12
  20ba3c:	df000215 	stw	fp,8(sp)
  20ba40:	df000204 	addi	fp,sp,8
  20ba44:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  20ba48:	e0bfff17 	ldw	r2,-4(fp)
  20ba4c:	10800317 	ldw	r2,12(r2)
  20ba50:	10800404 	addi	r2,r2,16
  20ba54:	10800037 	ldwio	r2,0(r2)
  20ba58:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  20ba5c:	e0bffe17 	ldw	r2,-8(fp)
  20ba60:	10800814 	ori	r2,r2,32
  20ba64:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  20ba68:	e0bfff17 	ldw	r2,-4(fp)
  20ba6c:	10800317 	ldw	r2,12(r2)
  20ba70:	10800404 	addi	r2,r2,16
  20ba74:	e0fffe17 	ldw	r3,-8(fp)
  20ba78:	10c00035 	stwio	r3,0(r2)
}
  20ba7c:	0001883a 	nop
  20ba80:	e037883a 	mov	sp,fp
  20ba84:	df000017 	ldw	fp,0(sp)
  20ba88:	dec00104 	addi	sp,sp,4
  20ba8c:	f800283a 	ret

0020ba90 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  20ba90:	defffd04 	addi	sp,sp,-12
  20ba94:	df000215 	stw	fp,8(sp)
  20ba98:	df000204 	addi	fp,sp,8
  20ba9c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  20baa0:	e0bfff17 	ldw	r2,-4(fp)
  20baa4:	10800317 	ldw	r2,12(r2)
  20baa8:	10800404 	addi	r2,r2,16
  20baac:	10800037 	ldwio	r2,0(r2)
  20bab0:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  20bab4:	e0fffe17 	ldw	r3,-8(fp)
  20bab8:	00bff7c4 	movi	r2,-33
  20babc:	1884703a 	and	r2,r3,r2
  20bac0:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  20bac4:	e0bfff17 	ldw	r2,-4(fp)
  20bac8:	10800317 	ldw	r2,12(r2)
  20bacc:	10800404 	addi	r2,r2,16
  20bad0:	e0fffe17 	ldw	r3,-8(fp)
  20bad4:	10c00035 	stwio	r3,0(r2)
}
  20bad8:	0001883a 	nop
  20badc:	e037883a 	mov	sp,fp
  20bae0:	df000017 	ldw	fp,0(sp)
  20bae4:	dec00104 	addi	sp,sp,4
  20bae8:	f800283a 	ret

0020baec <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  20baec:	defffe04 	addi	sp,sp,-8
  20baf0:	df000115 	stw	fp,4(sp)
  20baf4:	df000104 	addi	fp,sp,4
  20baf8:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
  20bafc:	e0bfff17 	ldw	r2,-4(fp)
  20bb00:	10800784 	addi	r2,r2,30
  20bb04:	10800023 	ldbuio	r2,0(r2)
  20bb08:	10803fcc 	andi	r2,r2,255
  20bb0c:	10801fcc 	andi	r2,r2,127
  20bb10:	10000226 	beq	r2,zero,20bb1c <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  20bb14:	00bffec4 	movi	r2,-5
  20bb18:	00000906 	br	20bb40 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
  20bb1c:	e0bfff17 	ldw	r2,-4(fp)
  20bb20:	108007c4 	addi	r2,r2,31
  20bb24:	10800023 	ldbuio	r2,0(r2)
  20bb28:	10803fcc 	andi	r2,r2,255
  20bb2c:	1080200c 	andi	r2,r2,128
  20bb30:	10000226 	beq	r2,zero,20bb3c <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
  20bb34:	00bfe244 	movi	r2,-119
  20bb38:	00000106 	br	20bb40 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
  20bb3c:	0005883a 	mov	r2,zero
}
  20bb40:	e037883a 	mov	sp,fp
  20bb44:	df000017 	ldw	fp,0(sp)
  20bb48:	dec00104 	addi	sp,sp,4
  20bb4c:	f800283a 	ret

0020bb50 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
  20bb50:	defffc04 	addi	sp,sp,-16
  20bb54:	dfc00315 	stw	ra,12(sp)
  20bb58:	df000215 	stw	fp,8(sp)
  20bb5c:	df000204 	addi	fp,sp,8
  20bb60:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
  20bb64:	d1600f04 	addi	r5,gp,-32708
  20bb68:	e13fff17 	ldw	r4,-4(fp)
  20bb6c:	020c7740 	call	20c774 <alt_find_dev>
  20bb70:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
  20bb74:	e0bffe17 	ldw	r2,-8(fp)
  20bb78:	1000041e 	bne	r2,zero,20bb8c <alt_avalon_sgdma_open+0x3c>
    ALT_ERRNO = ENODEV;
  20bb7c:	020b4980 	call	20b498 <alt_get_errno>
  20bb80:	1007883a 	mov	r3,r2
  20bb84:	008004c4 	movi	r2,19
  20bb88:	18800015 	stw	r2,0(r3)
  }

  return dev;
  20bb8c:	e0bffe17 	ldw	r2,-8(fp)
}
  20bb90:	e037883a 	mov	sp,fp
  20bb94:	dfc00117 	ldw	ra,4(sp)
  20bb98:	df000017 	ldw	fp,0(sp)
  20bb9c:	dec00204 	addi	sp,sp,8
  20bba0:	f800283a 	ret

0020bba4 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
  20bba4:	defff104 	addi	sp,sp,-60
  20bba8:	dfc00e15 	stw	ra,56(sp)
  20bbac:	df000d15 	stw	fp,52(sp)
  20bbb0:	df000d04 	addi	fp,sp,52
  20bbb4:	e13ffa15 	stw	r4,-24(fp)
  20bbb8:	e17ffb15 	stw	r5,-20(fp)
  20bbbc:	e1bffc15 	stw	r6,-16(fp)
  20bbc0:	e1fffd15 	stw	r7,-12(fp)
  20bbc4:	e0c00217 	ldw	r3,8(fp)
  20bbc8:	e0800617 	ldw	r2,24(fp)
  20bbcc:	e0fffe0d 	sth	r3,-8(fp)
  20bbd0:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
  20bbd4:	e0bffe0b 	ldhu	r2,-8(fp)
  20bbd8:	e0ffff03 	ldbu	r3,-4(fp)
  20bbdc:	d8c00615 	stw	r3,24(sp)
  20bbe0:	d8000515 	stw	zero,20(sp)
  20bbe4:	d8000415 	stw	zero,16(sp)
  20bbe8:	e0c00517 	ldw	r3,20(fp)
  20bbec:	d8c00315 	stw	r3,12(sp)
  20bbf0:	e0c00417 	ldw	r3,16(fp)
  20bbf4:	d8c00215 	stw	r3,8(sp)
  20bbf8:	e0c00317 	ldw	r3,12(fp)
  20bbfc:	d8c00115 	stw	r3,4(sp)
  20bc00:	d8800015 	stw	r2,0(sp)
  20bc04:	e1fffd17 	ldw	r7,-12(fp)
  20bc08:	e1bffc17 	ldw	r6,-16(fp)
  20bc0c:	e17ffb17 	ldw	r5,-20(fp)
  20bc10:	e13ffa17 	ldw	r4,-24(fp)
  20bc14:	020bd100 	call	20bd10 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
  20bc18:	0001883a 	nop
  20bc1c:	e037883a 	mov	sp,fp
  20bc20:	dfc00117 	ldw	ra,4(sp)
  20bc24:	df000017 	ldw	fp,0(sp)
  20bc28:	dec00204 	addi	sp,sp,8
  20bc2c:	f800283a 	ret

0020bc30 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  20bc30:	defffc04 	addi	sp,sp,-16
  20bc34:	df000315 	stw	fp,12(sp)
  20bc38:	df000304 	addi	fp,sp,12
  20bc3c:	e13ffe15 	stw	r4,-8(fp)
  20bc40:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  20bc44:	e0bffe17 	ldw	r2,-8(fp)
  20bc48:	10800317 	ldw	r2,12(r2)
  20bc4c:	10800404 	addi	r2,r2,16
  20bc50:	10800037 	ldwio	r2,0(r2)
  20bc54:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  20bc58:	e0fffd17 	ldw	r3,-12(fp)
  20bc5c:	00a00434 	movhi	r2,32784
  20bc60:	10bfffc4 	addi	r2,r2,-1
  20bc64:	1884703a 	and	r2,r3,r2
  20bc68:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
  20bc6c:	e0bfff17 	ldw	r2,-4(fp)
  20bc70:	1004953a 	slli	r2,r2,20
  20bc74:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
  20bc78:	e0bffd17 	ldw	r2,-12(fp)
  20bc7c:	1884b03a 	or	r2,r3,r2
  20bc80:	10800134 	orhi	r2,r2,4
  20bc84:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  20bc88:	e0bffe17 	ldw	r2,-8(fp)
  20bc8c:	10800317 	ldw	r2,12(r2)
  20bc90:	10800404 	addi	r2,r2,16
  20bc94:	e0fffd17 	ldw	r3,-12(fp)
  20bc98:	10c00035 	stwio	r3,0(r2)
  
  return;
  20bc9c:	0001883a 	nop
}
  20bca0:	e037883a 	mov	sp,fp
  20bca4:	df000017 	ldw	fp,0(sp)
  20bca8:	dec00104 	addi	sp,sp,4
  20bcac:	f800283a 	ret

0020bcb0 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  20bcb0:	defffd04 	addi	sp,sp,-12
  20bcb4:	df000215 	stw	fp,8(sp)
  20bcb8:	df000204 	addi	fp,sp,8
  20bcbc:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  20bcc0:	e0bfff17 	ldw	r2,-4(fp)
  20bcc4:	10800317 	ldw	r2,12(r2)
  20bcc8:	10800404 	addi	r2,r2,16
  20bccc:	10800037 	ldwio	r2,0(r2)
  20bcd0:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
  20bcd4:	e0fffe17 	ldw	r3,-8(fp)
  20bcd8:	00bfff34 	movhi	r2,65532
  20bcdc:	10bfffc4 	addi	r2,r2,-1
  20bce0:	1884703a 	and	r2,r3,r2
  20bce4:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  20bce8:	e0bfff17 	ldw	r2,-4(fp)
  20bcec:	10800317 	ldw	r2,12(r2)
  20bcf0:	10800404 	addi	r2,r2,16
  20bcf4:	e0fffe17 	ldw	r3,-8(fp)
  20bcf8:	10c00035 	stwio	r3,0(r2)
  
  return;
  20bcfc:	0001883a 	nop
}
  20bd00:	e037883a 	mov	sp,fp
  20bd04:	df000017 	ldw	fp,0(sp)
  20bd08:	dec00104 	addi	sp,sp,4
  20bd0c:	f800283a 	ret

0020bd10 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
  20bd10:	defff804 	addi	sp,sp,-32
  20bd14:	dfc00715 	stw	ra,28(sp)
  20bd18:	df000615 	stw	fp,24(sp)
  20bd1c:	df000604 	addi	fp,sp,24
  20bd20:	e13ffa15 	stw	r4,-24(fp)
  20bd24:	e17ffb15 	stw	r5,-20(fp)
  20bd28:	e1bffc15 	stw	r6,-16(fp)
  20bd2c:	e1fffd15 	stw	r7,-12(fp)
  20bd30:	e0c00217 	ldw	r3,8(fp)
  20bd34:	e0800817 	ldw	r2,32(fp)
  20bd38:	e0fffe0d 	sth	r3,-8(fp)
  20bd3c:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
  20bd40:	e0bffb17 	ldw	r2,-20(fp)
  20bd44:	108007c4 	addi	r2,r2,31
  20bd48:	e0fffb17 	ldw	r3,-20(fp)
  20bd4c:	18c007c3 	ldbu	r3,31(r3)
  20bd50:	19003fcc 	andi	r4,r3,255
  20bd54:	00ffdfc4 	movi	r3,-129
  20bd58:	20c6703a 	and	r3,r4,r3
  20bd5c:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  20bd60:	e0bffa17 	ldw	r2,-24(fp)
  20bd64:	e0fffc17 	ldw	r3,-16(fp)
  20bd68:	19403fcc 	andi	r5,r3,255
  20bd6c:	10c00003 	ldbu	r3,0(r2)
  20bd70:	1806703a 	and	r3,r3,zero
  20bd74:	1809883a 	mov	r4,r3
  20bd78:	2807883a 	mov	r3,r5
  20bd7c:	20c6b03a 	or	r3,r4,r3
  20bd80:	10c00005 	stb	r3,0(r2)
  20bd84:	e0fffc17 	ldw	r3,-16(fp)
  20bd88:	1806d23a 	srli	r3,r3,8
  20bd8c:	19403fcc 	andi	r5,r3,255
  20bd90:	10c00043 	ldbu	r3,1(r2)
  20bd94:	1806703a 	and	r3,r3,zero
  20bd98:	1809883a 	mov	r4,r3
  20bd9c:	2807883a 	mov	r3,r5
  20bda0:	20c6b03a 	or	r3,r4,r3
  20bda4:	10c00045 	stb	r3,1(r2)
  20bda8:	e0fffc17 	ldw	r3,-16(fp)
  20bdac:	1806d43a 	srli	r3,r3,16
  20bdb0:	19403fcc 	andi	r5,r3,255
  20bdb4:	10c00083 	ldbu	r3,2(r2)
  20bdb8:	1806703a 	and	r3,r3,zero
  20bdbc:	1809883a 	mov	r4,r3
  20bdc0:	2807883a 	mov	r3,r5
  20bdc4:	20c6b03a 	or	r3,r4,r3
  20bdc8:	10c00085 	stb	r3,2(r2)
  20bdcc:	e0fffc17 	ldw	r3,-16(fp)
  20bdd0:	180ad63a 	srli	r5,r3,24
  20bdd4:	10c000c3 	ldbu	r3,3(r2)
  20bdd8:	1806703a 	and	r3,r3,zero
  20bddc:	1809883a 	mov	r4,r3
  20bde0:	2807883a 	mov	r3,r5
  20bde4:	20c6b03a 	or	r3,r4,r3
  20bde8:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
  20bdec:	e0bffa17 	ldw	r2,-24(fp)
  20bdf0:	e0fffd17 	ldw	r3,-12(fp)
  20bdf4:	19403fcc 	andi	r5,r3,255
  20bdf8:	10c00203 	ldbu	r3,8(r2)
  20bdfc:	1806703a 	and	r3,r3,zero
  20be00:	1809883a 	mov	r4,r3
  20be04:	2807883a 	mov	r3,r5
  20be08:	20c6b03a 	or	r3,r4,r3
  20be0c:	10c00205 	stb	r3,8(r2)
  20be10:	e0fffd17 	ldw	r3,-12(fp)
  20be14:	1806d23a 	srli	r3,r3,8
  20be18:	19403fcc 	andi	r5,r3,255
  20be1c:	10c00243 	ldbu	r3,9(r2)
  20be20:	1806703a 	and	r3,r3,zero
  20be24:	1809883a 	mov	r4,r3
  20be28:	2807883a 	mov	r3,r5
  20be2c:	20c6b03a 	or	r3,r4,r3
  20be30:	10c00245 	stb	r3,9(r2)
  20be34:	e0fffd17 	ldw	r3,-12(fp)
  20be38:	1806d43a 	srli	r3,r3,16
  20be3c:	19403fcc 	andi	r5,r3,255
  20be40:	10c00283 	ldbu	r3,10(r2)
  20be44:	1806703a 	and	r3,r3,zero
  20be48:	1809883a 	mov	r4,r3
  20be4c:	2807883a 	mov	r3,r5
  20be50:	20c6b03a 	or	r3,r4,r3
  20be54:	10c00285 	stb	r3,10(r2)
  20be58:	e0fffd17 	ldw	r3,-12(fp)
  20be5c:	180ad63a 	srli	r5,r3,24
  20be60:	10c002c3 	ldbu	r3,11(r2)
  20be64:	1806703a 	and	r3,r3,zero
  20be68:	1809883a 	mov	r4,r3
  20be6c:	2807883a 	mov	r3,r5
  20be70:	20c6b03a 	or	r3,r4,r3
  20be74:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
  20be78:	e0bffa17 	ldw	r2,-24(fp)
  20be7c:	e0fffb17 	ldw	r3,-20(fp)
  20be80:	19403fcc 	andi	r5,r3,255
  20be84:	10c00403 	ldbu	r3,16(r2)
  20be88:	1806703a 	and	r3,r3,zero
  20be8c:	1809883a 	mov	r4,r3
  20be90:	2807883a 	mov	r3,r5
  20be94:	20c6b03a 	or	r3,r4,r3
  20be98:	10c00405 	stb	r3,16(r2)
  20be9c:	e0fffb17 	ldw	r3,-20(fp)
  20bea0:	1806d23a 	srli	r3,r3,8
  20bea4:	19403fcc 	andi	r5,r3,255
  20bea8:	10c00443 	ldbu	r3,17(r2)
  20beac:	1806703a 	and	r3,r3,zero
  20beb0:	1809883a 	mov	r4,r3
  20beb4:	2807883a 	mov	r3,r5
  20beb8:	20c6b03a 	or	r3,r4,r3
  20bebc:	10c00445 	stb	r3,17(r2)
  20bec0:	e0fffb17 	ldw	r3,-20(fp)
  20bec4:	1806d43a 	srli	r3,r3,16
  20bec8:	19403fcc 	andi	r5,r3,255
  20becc:	10c00483 	ldbu	r3,18(r2)
  20bed0:	1806703a 	and	r3,r3,zero
  20bed4:	1809883a 	mov	r4,r3
  20bed8:	2807883a 	mov	r3,r5
  20bedc:	20c6b03a 	or	r3,r4,r3
  20bee0:	10c00485 	stb	r3,18(r2)
  20bee4:	e0fffb17 	ldw	r3,-20(fp)
  20bee8:	180ad63a 	srli	r5,r3,24
  20beec:	10c004c3 	ldbu	r3,19(r2)
  20bef0:	1806703a 	and	r3,r3,zero
  20bef4:	1809883a 	mov	r4,r3
  20bef8:	2807883a 	mov	r3,r5
  20befc:	20c6b03a 	or	r3,r4,r3
  20bf00:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
  20bf04:	e0bffa17 	ldw	r2,-24(fp)
  20bf08:	10c00103 	ldbu	r3,4(r2)
  20bf0c:	1806703a 	and	r3,r3,zero
  20bf10:	10c00105 	stb	r3,4(r2)
  20bf14:	10c00143 	ldbu	r3,5(r2)
  20bf18:	1806703a 	and	r3,r3,zero
  20bf1c:	10c00145 	stb	r3,5(r2)
  20bf20:	10c00183 	ldbu	r3,6(r2)
  20bf24:	1806703a 	and	r3,r3,zero
  20bf28:	10c00185 	stb	r3,6(r2)
  20bf2c:	10c001c3 	ldbu	r3,7(r2)
  20bf30:	1806703a 	and	r3,r3,zero
  20bf34:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
  20bf38:	e0bffa17 	ldw	r2,-24(fp)
  20bf3c:	10c00303 	ldbu	r3,12(r2)
  20bf40:	1806703a 	and	r3,r3,zero
  20bf44:	10c00305 	stb	r3,12(r2)
  20bf48:	10c00343 	ldbu	r3,13(r2)
  20bf4c:	1806703a 	and	r3,r3,zero
  20bf50:	10c00345 	stb	r3,13(r2)
  20bf54:	10c00383 	ldbu	r3,14(r2)
  20bf58:	1806703a 	and	r3,r3,zero
  20bf5c:	10c00385 	stb	r3,14(r2)
  20bf60:	10c003c3 	ldbu	r3,15(r2)
  20bf64:	1806703a 	and	r3,r3,zero
  20bf68:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
  20bf6c:	e0bffa17 	ldw	r2,-24(fp)
  20bf70:	10c00503 	ldbu	r3,20(r2)
  20bf74:	1806703a 	and	r3,r3,zero
  20bf78:	10c00505 	stb	r3,20(r2)
  20bf7c:	10c00543 	ldbu	r3,21(r2)
  20bf80:	1806703a 	and	r3,r3,zero
  20bf84:	10c00545 	stb	r3,21(r2)
  20bf88:	10c00583 	ldbu	r3,22(r2)
  20bf8c:	1806703a 	and	r3,r3,zero
  20bf90:	10c00585 	stb	r3,22(r2)
  20bf94:	10c005c3 	ldbu	r3,23(r2)
  20bf98:	1806703a 	and	r3,r3,zero
  20bf9c:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
  20bfa0:	e0bffa17 	ldw	r2,-24(fp)
  20bfa4:	e0fffe17 	ldw	r3,-8(fp)
  20bfa8:	19403fcc 	andi	r5,r3,255
  20bfac:	10c00603 	ldbu	r3,24(r2)
  20bfb0:	1806703a 	and	r3,r3,zero
  20bfb4:	1809883a 	mov	r4,r3
  20bfb8:	2807883a 	mov	r3,r5
  20bfbc:	20c6b03a 	or	r3,r4,r3
  20bfc0:	10c00605 	stb	r3,24(r2)
  20bfc4:	e0fffe17 	ldw	r3,-8(fp)
  20bfc8:	1806d23a 	srli	r3,r3,8
  20bfcc:	19403fcc 	andi	r5,r3,255
  20bfd0:	10c00643 	ldbu	r3,25(r2)
  20bfd4:	1806703a 	and	r3,r3,zero
  20bfd8:	1809883a 	mov	r4,r3
  20bfdc:	2807883a 	mov	r3,r5
  20bfe0:	20c6b03a 	or	r3,r4,r3
  20bfe4:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
  20bfe8:	e0bffa17 	ldw	r2,-24(fp)
  20bfec:	10c00703 	ldbu	r3,28(r2)
  20bff0:	1806703a 	and	r3,r3,zero
  20bff4:	10c00705 	stb	r3,28(r2)
  20bff8:	10c00743 	ldbu	r3,29(r2)
  20bffc:	1806703a 	and	r3,r3,zero
  20c000:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
  20c004:	e0bffa17 	ldw	r2,-24(fp)
  20c008:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  20c00c:	e0800617 	ldw	r2,24(fp)
  20c010:	1007883a 	mov	r3,r2
  20c014:	e0bffa17 	ldw	r2,-24(fp)
  20c018:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
  20c01c:	e0800717 	ldw	r2,28(fp)
  20c020:	1007883a 	mov	r3,r2
  20c024:	e0bffa17 	ldw	r2,-24(fp)
  20c028:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  20c02c:	e0800317 	ldw	r2,12(fp)
  20c030:	10000226 	beq	r2,zero,20c03c <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
  20c034:	00bfe044 	movi	r2,-127
  20c038:	00000106 	br	20c040 <alt_avalon_sgdma_construct_descriptor_burst+0x330>
  20c03c:	00bfe004 	movi	r2,-128
  20c040:	e0c00417 	ldw	r3,16(fp)
  20c044:	18000226 	beq	r3,zero,20c050 <alt_avalon_sgdma_construct_descriptor_burst+0x340>
  20c048:	00c00084 	movi	r3,2
  20c04c:	00000106 	br	20c054 <alt_avalon_sgdma_construct_descriptor_burst+0x344>
  20c050:	0007883a 	mov	r3,zero
  20c054:	10c4b03a 	or	r2,r2,r3
  20c058:	1007883a 	mov	r3,r2
  20c05c:	e0800517 	ldw	r2,20(fp)
  20c060:	10000226 	beq	r2,zero,20c06c <alt_avalon_sgdma_construct_descriptor_burst+0x35c>
  20c064:	00800104 	movi	r2,4
  20c068:	00000106 	br	20c070 <alt_avalon_sgdma_construct_descriptor_burst+0x360>
  20c06c:	0005883a 	mov	r2,zero
  20c070:	1884b03a 	or	r2,r3,r2
  20c074:	1007883a 	mov	r3,r2
  20c078:	e0bfff03 	ldbu	r2,-4(fp)
  20c07c:	10000426 	beq	r2,zero,20c090 <alt_avalon_sgdma_construct_descriptor_burst+0x380>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
  20c080:	e0bfff03 	ldbu	r2,-4(fp)
  20c084:	108003cc 	andi	r2,r2,15
  20c088:	100490fa 	slli	r2,r2,3
  20c08c:	00000106 	br	20c094 <alt_avalon_sgdma_construct_descriptor_burst+0x384>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  20c090:	0005883a 	mov	r2,zero
  20c094:	1884b03a 	or	r2,r3,r2
  20c098:	1007883a 	mov	r3,r2
  20c09c:	e0bffa17 	ldw	r2,-24(fp)
  20c0a0:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
  20c0a4:	01400804 	movi	r5,32
  20c0a8:	e13ffa17 	ldw	r4,-24(fp)
  20c0ac:	020c5600 	call	20c560 <alt_dcache_flush>
}
  20c0b0:	0001883a 	nop
  20c0b4:	e037883a 	mov	sp,fp
  20c0b8:	dfc00117 	ldw	ra,4(sp)
  20c0bc:	df000017 	ldw	fp,0(sp)
  20c0c0:	dec00204 	addi	sp,sp,8
  20c0c4:	f800283a 	ret

0020c0c8 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
  20c0c8:	defff904 	addi	sp,sp,-28
  20c0cc:	dfc00615 	stw	ra,24(sp)
  20c0d0:	df000515 	stw	fp,20(sp)
  20c0d4:	df000504 	addi	fp,sp,20
  20c0d8:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
  20c0dc:	e0bfff17 	ldw	r2,-4(fp)
  20c0e0:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  20c0e4:	e0bffb17 	ldw	r2,-20(fp)
  20c0e8:	10800317 	ldw	r2,12(r2)
  20c0ec:	10800404 	addi	r2,r2,16
  20c0f0:	e0fffb17 	ldw	r3,-20(fp)
  20c0f4:	18c00317 	ldw	r3,12(r3)
  20c0f8:	18c00404 	addi	r3,r3,16
  20c0fc:	18c00037 	ldwio	r3,0(r3)
  20c100:	18e00034 	orhi	r3,r3,32768
  20c104:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  20c108:	e0bffb17 	ldw	r2,-20(fp)
  20c10c:	10800317 	ldw	r2,12(r2)
  20c110:	10800404 	addi	r2,r2,16
  20c114:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
  20c118:	e0bffb17 	ldw	r2,-20(fp)
  20c11c:	10800917 	ldw	r2,36(r2)
  20c120:	10001226 	beq	r2,zero,20c16c <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20c124:	0005303a 	rdctl	r2,status
  20c128:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20c12c:	e0fffd17 	ldw	r3,-12(fp)
  20c130:	00bfff84 	movi	r2,-2
  20c134:	1884703a 	and	r2,r3,r2
  20c138:	1001703a 	wrctl	status,r2
  
  return context;
  20c13c:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
  20c140:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
  20c144:	e0bffb17 	ldw	r2,-20(fp)
  20c148:	10800917 	ldw	r2,36(r2)
  20c14c:	e0fffb17 	ldw	r3,-20(fp)
  20c150:	18c00a17 	ldw	r3,40(r3)
  20c154:	1809883a 	mov	r4,r3
  20c158:	103ee83a 	callr	r2
  20c15c:	e0bffc17 	ldw	r2,-16(fp)
  20c160:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20c164:	e0bffe17 	ldw	r2,-8(fp)
  20c168:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
  20c16c:	0001883a 	nop
  20c170:	e037883a 	mov	sp,fp
  20c174:	dfc00117 	ldw	ra,4(sp)
  20c178:	df000017 	ldw	fp,0(sp)
  20c17c:	dec00204 	addi	sp,sp,8
  20c180:	f800283a 	ret

0020c184 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
  20c184:	defffa04 	addi	sp,sp,-24
  20c188:	dfc00515 	stw	ra,20(sp)
  20c18c:	df000415 	stw	fp,16(sp)
  20c190:	df000404 	addi	fp,sp,16
  20c194:	e13ffd15 	stw	r4,-12(fp)
  20c198:	e17ffe15 	stw	r5,-8(fp)
  20c19c:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  20c1a0:	e0bffd17 	ldw	r2,-12(fp)
  20c1a4:	10800317 	ldw	r2,12(r2)
  20c1a8:	10800404 	addi	r2,r2,16
  20c1ac:	00c00074 	movhi	r3,1
  20c1b0:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  20c1b4:	e0bffd17 	ldw	r2,-12(fp)
  20c1b8:	10800317 	ldw	r2,12(r2)
  20c1bc:	10800404 	addi	r2,r2,16
  20c1c0:	00c00074 	movhi	r3,1
  20c1c4:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
  20c1c8:	e0bffd17 	ldw	r2,-12(fp)
  20c1cc:	10800317 	ldw	r2,12(r2)
  20c1d0:	10800404 	addi	r2,r2,16
  20c1d4:	0007883a 	mov	r3,zero
  20c1d8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  20c1dc:	e0bffd17 	ldw	r2,-12(fp)
  20c1e0:	10800317 	ldw	r2,12(r2)
  20c1e4:	00c03fc4 	movi	r3,255
  20c1e8:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
  20c1ec:	d1600f04 	addi	r5,gp,-32708
  20c1f0:	e13ffd17 	ldw	r4,-12(fp)
  20c1f4:	020c6100 	call	20c610 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
  20c1f8:	d8000015 	stw	zero,0(sp)
  20c1fc:	e1fffd17 	ldw	r7,-12(fp)
  20c200:	01800874 	movhi	r6,33
  20c204:	31b03204 	addi	r6,r6,-16184
  20c208:	e17fff17 	ldw	r5,-4(fp)
  20c20c:	e13ffe17 	ldw	r4,-8(fp)
  20c210:	0209e1c0 	call	209e1c <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
  20c214:	0001883a 	nop
  20c218:	e037883a 	mov	sp,fp
  20c21c:	dfc00117 	ldw	ra,4(sp)
  20c220:	df000017 	ldw	fp,0(sp)
  20c224:	dec00204 	addi	sp,sp,8
  20c228:	f800283a 	ret

0020c22c <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  20c22c:	defffa04 	addi	sp,sp,-24
  20c230:	dfc00515 	stw	ra,20(sp)
  20c234:	df000415 	stw	fp,16(sp)
  20c238:	df000404 	addi	fp,sp,16
  20c23c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  20c240:	0007883a 	mov	r3,zero
  20c244:	e0bfff17 	ldw	r2,-4(fp)
  20c248:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  20c24c:	e0bfff17 	ldw	r2,-4(fp)
  20c250:	10800104 	addi	r2,r2,4
  20c254:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20c258:	0005303a 	rdctl	r2,status
  20c25c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20c260:	e0fffd17 	ldw	r3,-12(fp)
  20c264:	00bfff84 	movi	r2,-2
  20c268:	1884703a 	and	r2,r3,r2
  20c26c:	1001703a 	wrctl	status,r2
  
  return context;
  20c270:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  20c274:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
  20c278:	020cdc40 	call	20cdc4 <alt_tick>
  20c27c:	e0bffc17 	ldw	r2,-16(fp)
  20c280:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20c284:	e0bffe17 	ldw	r2,-8(fp)
  20c288:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  20c28c:	0001883a 	nop
  20c290:	e037883a 	mov	sp,fp
  20c294:	dfc00117 	ldw	ra,4(sp)
  20c298:	df000017 	ldw	fp,0(sp)
  20c29c:	dec00204 	addi	sp,sp,8
  20c2a0:	f800283a 	ret

0020c2a4 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  20c2a4:	defff804 	addi	sp,sp,-32
  20c2a8:	dfc00715 	stw	ra,28(sp)
  20c2ac:	df000615 	stw	fp,24(sp)
  20c2b0:	df000604 	addi	fp,sp,24
  20c2b4:	e13ffc15 	stw	r4,-16(fp)
  20c2b8:	e17ffd15 	stw	r5,-12(fp)
  20c2bc:	e1bffe15 	stw	r6,-8(fp)
  20c2c0:	e1ffff15 	stw	r7,-4(fp)
  20c2c4:	e0bfff17 	ldw	r2,-4(fp)
  20c2c8:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  20c2cc:	d0a1a317 	ldw	r2,-31092(gp)
  20c2d0:	1000021e 	bne	r2,zero,20c2dc <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
  20c2d4:	e0bffb17 	ldw	r2,-20(fp)
  20c2d8:	d0a1a315 	stw	r2,-31092(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  20c2dc:	e0bffc17 	ldw	r2,-16(fp)
  20c2e0:	10800104 	addi	r2,r2,4
  20c2e4:	00c001c4 	movi	r3,7
  20c2e8:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  20c2ec:	d8000015 	stw	zero,0(sp)
  20c2f0:	e1fffc17 	ldw	r7,-16(fp)
  20c2f4:	01800874 	movhi	r6,33
  20c2f8:	31b08b04 	addi	r6,r6,-15828
  20c2fc:	e17ffe17 	ldw	r5,-8(fp)
  20c300:	e13ffd17 	ldw	r4,-12(fp)
  20c304:	0209e1c0 	call	209e1c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  20c308:	0001883a 	nop
  20c30c:	e037883a 	mov	sp,fp
  20c310:	dfc00117 	ldw	ra,4(sp)
  20c314:	df000017 	ldw	fp,0(sp)
  20c318:	dec00204 	addi	sp,sp,8
  20c31c:	f800283a 	ret

0020c320 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  20c320:	defff504 	addi	sp,sp,-44
  20c324:	df000a15 	stw	fp,40(sp)
  20c328:	df000a04 	addi	fp,sp,40
  20c32c:	e13ffc15 	stw	r4,-16(fp)
  20c330:	e17ffd15 	stw	r5,-12(fp)
  20c334:	e1bffe15 	stw	r6,-8(fp)
  20c338:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  20c33c:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  20c340:	d0a1a317 	ldw	r2,-31092(gp)
  
  if (alt_ticks_per_second ())
  20c344:	10003c26 	beq	r2,zero,20c438 <alt_alarm_start+0x118>
  {
    if (alarm)
  20c348:	e0bffc17 	ldw	r2,-16(fp)
  20c34c:	10003826 	beq	r2,zero,20c430 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
  20c350:	e0bffc17 	ldw	r2,-16(fp)
  20c354:	e0fffe17 	ldw	r3,-8(fp)
  20c358:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  20c35c:	e0bffc17 	ldw	r2,-16(fp)
  20c360:	e0ffff17 	ldw	r3,-4(fp)
  20c364:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20c368:	0005303a 	rdctl	r2,status
  20c36c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20c370:	e0fff917 	ldw	r3,-28(fp)
  20c374:	00bfff84 	movi	r2,-2
  20c378:	1884703a 	and	r2,r3,r2
  20c37c:	1001703a 	wrctl	status,r2
  
  return context;
  20c380:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
  20c384:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  20c388:	d0a1a417 	ldw	r2,-31088(gp)
      
      current_nticks = alt_nticks();
  20c38c:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  20c390:	e0fffd17 	ldw	r3,-12(fp)
  20c394:	e0bff617 	ldw	r2,-40(fp)
  20c398:	1885883a 	add	r2,r3,r2
  20c39c:	10c00044 	addi	r3,r2,1
  20c3a0:	e0bffc17 	ldw	r2,-16(fp)
  20c3a4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  20c3a8:	e0bffc17 	ldw	r2,-16(fp)
  20c3ac:	10c00217 	ldw	r3,8(r2)
  20c3b0:	e0bff617 	ldw	r2,-40(fp)
  20c3b4:	1880042e 	bgeu	r3,r2,20c3c8 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
  20c3b8:	e0bffc17 	ldw	r2,-16(fp)
  20c3bc:	00c00044 	movi	r3,1
  20c3c0:	10c00405 	stb	r3,16(r2)
  20c3c4:	00000206 	br	20c3d0 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
  20c3c8:	e0bffc17 	ldw	r2,-16(fp)
  20c3cc:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  20c3d0:	e0bffc17 	ldw	r2,-16(fp)
  20c3d4:	d0e01704 	addi	r3,gp,-32676
  20c3d8:	e0fffa15 	stw	r3,-24(fp)
  20c3dc:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  20c3e0:	e0bffb17 	ldw	r2,-20(fp)
  20c3e4:	e0fffa17 	ldw	r3,-24(fp)
  20c3e8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  20c3ec:	e0bffa17 	ldw	r2,-24(fp)
  20c3f0:	10c00017 	ldw	r3,0(r2)
  20c3f4:	e0bffb17 	ldw	r2,-20(fp)
  20c3f8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  20c3fc:	e0bffa17 	ldw	r2,-24(fp)
  20c400:	10800017 	ldw	r2,0(r2)
  20c404:	e0fffb17 	ldw	r3,-20(fp)
  20c408:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  20c40c:	e0bffa17 	ldw	r2,-24(fp)
  20c410:	e0fffb17 	ldw	r3,-20(fp)
  20c414:	10c00015 	stw	r3,0(r2)
  20c418:	e0bff817 	ldw	r2,-32(fp)
  20c41c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20c420:	e0bff717 	ldw	r2,-36(fp)
  20c424:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  20c428:	0005883a 	mov	r2,zero
  20c42c:	00000306 	br	20c43c <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
  20c430:	00bffa84 	movi	r2,-22
  20c434:	00000106 	br	20c43c <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
  20c438:	00bfde84 	movi	r2,-134
  }
}
  20c43c:	e037883a 	mov	sp,fp
  20c440:	df000017 	ldw	fp,0(sp)
  20c444:	dec00104 	addi	sp,sp,4
  20c448:	f800283a 	ret

0020c44c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  20c44c:	defffe04 	addi	sp,sp,-8
  20c450:	dfc00115 	stw	ra,4(sp)
  20c454:	df000015 	stw	fp,0(sp)
  20c458:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  20c45c:	d0a01617 	ldw	r2,-32680(gp)
  20c460:	10000326 	beq	r2,zero,20c470 <alt_get_errno+0x24>
  20c464:	d0a01617 	ldw	r2,-32680(gp)
  20c468:	103ee83a 	callr	r2
  20c46c:	00000106 	br	20c474 <alt_get_errno+0x28>
  20c470:	d0a1a504 	addi	r2,gp,-31084
}
  20c474:	e037883a 	mov	sp,fp
  20c478:	dfc00117 	ldw	ra,4(sp)
  20c47c:	df000017 	ldw	fp,0(sp)
  20c480:	dec00204 	addi	sp,sp,8
  20c484:	f800283a 	ret

0020c488 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  20c488:	defffb04 	addi	sp,sp,-20
  20c48c:	dfc00415 	stw	ra,16(sp)
  20c490:	df000315 	stw	fp,12(sp)
  20c494:	df000304 	addi	fp,sp,12
  20c498:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  20c49c:	e0bfff17 	ldw	r2,-4(fp)
  20c4a0:	10000816 	blt	r2,zero,20c4c4 <close+0x3c>
  20c4a4:	01400304 	movi	r5,12
  20c4a8:	e13fff17 	ldw	r4,-4(fp)
  20c4ac:	020d7a80 	call	20d7a8 <__mulsi3>
  20c4b0:	1007883a 	mov	r3,r2
  20c4b4:	00800874 	movhi	r2,33
  20c4b8:	10b78e04 	addi	r2,r2,-8648
  20c4bc:	1885883a 	add	r2,r3,r2
  20c4c0:	00000106 	br	20c4c8 <close+0x40>
  20c4c4:	0005883a 	mov	r2,zero
  20c4c8:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  20c4cc:	e0bffd17 	ldw	r2,-12(fp)
  20c4d0:	10001926 	beq	r2,zero,20c538 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  20c4d4:	e0bffd17 	ldw	r2,-12(fp)
  20c4d8:	10800017 	ldw	r2,0(r2)
  20c4dc:	10800417 	ldw	r2,16(r2)
  20c4e0:	10000626 	beq	r2,zero,20c4fc <close+0x74>
  20c4e4:	e0bffd17 	ldw	r2,-12(fp)
  20c4e8:	10800017 	ldw	r2,0(r2)
  20c4ec:	10800417 	ldw	r2,16(r2)
  20c4f0:	e13ffd17 	ldw	r4,-12(fp)
  20c4f4:	103ee83a 	callr	r2
  20c4f8:	00000106 	br	20c500 <close+0x78>
  20c4fc:	0005883a 	mov	r2,zero
  20c500:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  20c504:	e13fff17 	ldw	r4,-4(fp)
  20c508:	020cca40 	call	20cca4 <alt_release_fd>
    if (rval < 0)
  20c50c:	e0bffe17 	ldw	r2,-8(fp)
  20c510:	1000070e 	bge	r2,zero,20c530 <close+0xa8>
    {
      ALT_ERRNO = -rval;
  20c514:	020c44c0 	call	20c44c <alt_get_errno>
  20c518:	1007883a 	mov	r3,r2
  20c51c:	e0bffe17 	ldw	r2,-8(fp)
  20c520:	0085c83a 	sub	r2,zero,r2
  20c524:	18800015 	stw	r2,0(r3)
      return -1;
  20c528:	00bfffc4 	movi	r2,-1
  20c52c:	00000706 	br	20c54c <close+0xc4>
    }
    return 0;
  20c530:	0005883a 	mov	r2,zero
  20c534:	00000506 	br	20c54c <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  20c538:	020c44c0 	call	20c44c <alt_get_errno>
  20c53c:	1007883a 	mov	r3,r2
  20c540:	00801444 	movi	r2,81
  20c544:	18800015 	stw	r2,0(r3)
    return -1;
  20c548:	00bfffc4 	movi	r2,-1
  }
}
  20c54c:	e037883a 	mov	sp,fp
  20c550:	dfc00117 	ldw	ra,4(sp)
  20c554:	df000017 	ldw	fp,0(sp)
  20c558:	dec00204 	addi	sp,sp,8
  20c55c:	f800283a 	ret

0020c560 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
  20c560:	defffd04 	addi	sp,sp,-12
  20c564:	df000215 	stw	fp,8(sp)
  20c568:	df000204 	addi	fp,sp,8
  20c56c:	e13ffe15 	stw	r4,-8(fp)
  20c570:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  20c574:	0001883a 	nop
  20c578:	e037883a 	mov	sp,fp
  20c57c:	df000017 	ldw	fp,0(sp)
  20c580:	dec00104 	addi	sp,sp,4
  20c584:	f800283a 	ret

0020c588 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  20c588:	deffff04 	addi	sp,sp,-4
  20c58c:	df000015 	stw	fp,0(sp)
  20c590:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  20c594:	0001883a 	nop
  20c598:	e037883a 	mov	sp,fp
  20c59c:	df000017 	ldw	fp,0(sp)
  20c5a0:	dec00104 	addi	sp,sp,4
  20c5a4:	f800283a 	ret

0020c5a8 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  20c5a8:	defffc04 	addi	sp,sp,-16
  20c5ac:	df000315 	stw	fp,12(sp)
  20c5b0:	df000304 	addi	fp,sp,12
  20c5b4:	e13ffd15 	stw	r4,-12(fp)
  20c5b8:	e17ffe15 	stw	r5,-8(fp)
  20c5bc:	e1bfff15 	stw	r6,-4(fp)
  return len;
  20c5c0:	e0bfff17 	ldw	r2,-4(fp)
}
  20c5c4:	e037883a 	mov	sp,fp
  20c5c8:	df000017 	ldw	fp,0(sp)
  20c5cc:	dec00104 	addi	sp,sp,4
  20c5d0:	f800283a 	ret

0020c5d4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  20c5d4:	defffe04 	addi	sp,sp,-8
  20c5d8:	dfc00115 	stw	ra,4(sp)
  20c5dc:	df000015 	stw	fp,0(sp)
  20c5e0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  20c5e4:	d0a01617 	ldw	r2,-32680(gp)
  20c5e8:	10000326 	beq	r2,zero,20c5f8 <alt_get_errno+0x24>
  20c5ec:	d0a01617 	ldw	r2,-32680(gp)
  20c5f0:	103ee83a 	callr	r2
  20c5f4:	00000106 	br	20c5fc <alt_get_errno+0x28>
  20c5f8:	d0a1a504 	addi	r2,gp,-31084
}
  20c5fc:	e037883a 	mov	sp,fp
  20c600:	dfc00117 	ldw	ra,4(sp)
  20c604:	df000017 	ldw	fp,0(sp)
  20c608:	dec00204 	addi	sp,sp,8
  20c60c:	f800283a 	ret

0020c610 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  20c610:	defffa04 	addi	sp,sp,-24
  20c614:	dfc00515 	stw	ra,20(sp)
  20c618:	df000415 	stw	fp,16(sp)
  20c61c:	df000404 	addi	fp,sp,16
  20c620:	e13ffe15 	stw	r4,-8(fp)
  20c624:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  20c628:	e0bffe17 	ldw	r2,-8(fp)
  20c62c:	10000326 	beq	r2,zero,20c63c <alt_dev_llist_insert+0x2c>
  20c630:	e0bffe17 	ldw	r2,-8(fp)
  20c634:	10800217 	ldw	r2,8(r2)
  20c638:	1000061e 	bne	r2,zero,20c654 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
  20c63c:	020c5d40 	call	20c5d4 <alt_get_errno>
  20c640:	1007883a 	mov	r3,r2
  20c644:	00800584 	movi	r2,22
  20c648:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  20c64c:	00bffa84 	movi	r2,-22
  20c650:	00001306 	br	20c6a0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  20c654:	e0bffe17 	ldw	r2,-8(fp)
  20c658:	e0ffff17 	ldw	r3,-4(fp)
  20c65c:	e0fffc15 	stw	r3,-16(fp)
  20c660:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  20c664:	e0bffd17 	ldw	r2,-12(fp)
  20c668:	e0fffc17 	ldw	r3,-16(fp)
  20c66c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  20c670:	e0bffc17 	ldw	r2,-16(fp)
  20c674:	10c00017 	ldw	r3,0(r2)
  20c678:	e0bffd17 	ldw	r2,-12(fp)
  20c67c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  20c680:	e0bffc17 	ldw	r2,-16(fp)
  20c684:	10800017 	ldw	r2,0(r2)
  20c688:	e0fffd17 	ldw	r3,-12(fp)
  20c68c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  20c690:	e0bffc17 	ldw	r2,-16(fp)
  20c694:	e0fffd17 	ldw	r3,-12(fp)
  20c698:	10c00015 	stw	r3,0(r2)

  return 0;  
  20c69c:	0005883a 	mov	r2,zero
}
  20c6a0:	e037883a 	mov	sp,fp
  20c6a4:	dfc00117 	ldw	ra,4(sp)
  20c6a8:	df000017 	ldw	fp,0(sp)
  20c6ac:	dec00204 	addi	sp,sp,8
  20c6b0:	f800283a 	ret

0020c6b4 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  20c6b4:	defffd04 	addi	sp,sp,-12
  20c6b8:	dfc00215 	stw	ra,8(sp)
  20c6bc:	df000115 	stw	fp,4(sp)
  20c6c0:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  20c6c4:	00800874 	movhi	r2,33
  20c6c8:	10b60004 	addi	r2,r2,-10240
  20c6cc:	e0bfff15 	stw	r2,-4(fp)
  20c6d0:	00000606 	br	20c6ec <_do_ctors+0x38>
        (*ctor) (); 
  20c6d4:	e0bfff17 	ldw	r2,-4(fp)
  20c6d8:	10800017 	ldw	r2,0(r2)
  20c6dc:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  20c6e0:	e0bfff17 	ldw	r2,-4(fp)
  20c6e4:	10bfff04 	addi	r2,r2,-4
  20c6e8:	e0bfff15 	stw	r2,-4(fp)
  20c6ec:	e0ffff17 	ldw	r3,-4(fp)
  20c6f0:	00800874 	movhi	r2,33
  20c6f4:	10b60104 	addi	r2,r2,-10236
  20c6f8:	18bff62e 	bgeu	r3,r2,20c6d4 <_gp+0xffff663c>
        (*ctor) (); 
}
  20c6fc:	0001883a 	nop
  20c700:	e037883a 	mov	sp,fp
  20c704:	dfc00117 	ldw	ra,4(sp)
  20c708:	df000017 	ldw	fp,0(sp)
  20c70c:	dec00204 	addi	sp,sp,8
  20c710:	f800283a 	ret

0020c714 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  20c714:	defffd04 	addi	sp,sp,-12
  20c718:	dfc00215 	stw	ra,8(sp)
  20c71c:	df000115 	stw	fp,4(sp)
  20c720:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  20c724:	00800874 	movhi	r2,33
  20c728:	10b60004 	addi	r2,r2,-10240
  20c72c:	e0bfff15 	stw	r2,-4(fp)
  20c730:	00000606 	br	20c74c <_do_dtors+0x38>
        (*dtor) (); 
  20c734:	e0bfff17 	ldw	r2,-4(fp)
  20c738:	10800017 	ldw	r2,0(r2)
  20c73c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  20c740:	e0bfff17 	ldw	r2,-4(fp)
  20c744:	10bfff04 	addi	r2,r2,-4
  20c748:	e0bfff15 	stw	r2,-4(fp)
  20c74c:	e0ffff17 	ldw	r3,-4(fp)
  20c750:	00800874 	movhi	r2,33
  20c754:	10b60104 	addi	r2,r2,-10236
  20c758:	18bff62e 	bgeu	r3,r2,20c734 <_gp+0xffff669c>
        (*dtor) (); 
}
  20c75c:	0001883a 	nop
  20c760:	e037883a 	mov	sp,fp
  20c764:	dfc00117 	ldw	ra,4(sp)
  20c768:	df000017 	ldw	fp,0(sp)
  20c76c:	dec00204 	addi	sp,sp,8
  20c770:	f800283a 	ret

0020c774 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  20c774:	defffa04 	addi	sp,sp,-24
  20c778:	dfc00515 	stw	ra,20(sp)
  20c77c:	df000415 	stw	fp,16(sp)
  20c780:	df000404 	addi	fp,sp,16
  20c784:	e13ffe15 	stw	r4,-8(fp)
  20c788:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  20c78c:	e0bfff17 	ldw	r2,-4(fp)
  20c790:	10800017 	ldw	r2,0(r2)
  20c794:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  20c798:	e13ffe17 	ldw	r4,-8(fp)
  20c79c:	020d2f00 	call	20d2f0 <strlen>
  20c7a0:	10800044 	addi	r2,r2,1
  20c7a4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  20c7a8:	00000d06 	br	20c7e0 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  20c7ac:	e0bffc17 	ldw	r2,-16(fp)
  20c7b0:	10800217 	ldw	r2,8(r2)
  20c7b4:	e0fffd17 	ldw	r3,-12(fp)
  20c7b8:	180d883a 	mov	r6,r3
  20c7bc:	e17ffe17 	ldw	r5,-8(fp)
  20c7c0:	1009883a 	mov	r4,r2
  20c7c4:	020d2780 	call	20d278 <memcmp>
  20c7c8:	1000021e 	bne	r2,zero,20c7d4 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  20c7cc:	e0bffc17 	ldw	r2,-16(fp)
  20c7d0:	00000706 	br	20c7f0 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  20c7d4:	e0bffc17 	ldw	r2,-16(fp)
  20c7d8:	10800017 	ldw	r2,0(r2)
  20c7dc:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  20c7e0:	e0fffc17 	ldw	r3,-16(fp)
  20c7e4:	e0bfff17 	ldw	r2,-4(fp)
  20c7e8:	18bff01e 	bne	r3,r2,20c7ac <_gp+0xffff6714>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  20c7ec:	0005883a 	mov	r2,zero
}
  20c7f0:	e037883a 	mov	sp,fp
  20c7f4:	dfc00117 	ldw	ra,4(sp)
  20c7f8:	df000017 	ldw	fp,0(sp)
  20c7fc:	dec00204 	addi	sp,sp,8
  20c800:	f800283a 	ret

0020c804 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  20c804:	deffff04 	addi	sp,sp,-4
  20c808:	df000015 	stw	fp,0(sp)
  20c80c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
  20c810:	0001883a 	nop
  20c814:	e037883a 	mov	sp,fp
  20c818:	df000017 	ldw	fp,0(sp)
  20c81c:	dec00104 	addi	sp,sp,4
  20c820:	f800283a 	ret

0020c824 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  20c824:	defffe04 	addi	sp,sp,-8
  20c828:	df000115 	stw	fp,4(sp)
  20c82c:	df000104 	addi	fp,sp,4
  20c830:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
  20c834:	e0bfff17 	ldw	r2,-4(fp)
  20c838:	10bffe84 	addi	r2,r2,-6
  20c83c:	10c00428 	cmpgeui	r3,r2,16
  20c840:	18001a1e 	bne	r3,zero,20c8ac <alt_exception_cause_generated_bad_addr+0x88>
  20c844:	100690ba 	slli	r3,r2,2
  20c848:	00800874 	movhi	r2,33
  20c84c:	10b21704 	addi	r2,r2,-14244
  20c850:	1885883a 	add	r2,r3,r2
  20c854:	10800017 	ldw	r2,0(r2)
  20c858:	1000683a 	jmp	r2
  20c85c:	0020c89c 	xori	zero,zero,33570
  20c860:	0020c89c 	xori	zero,zero,33570
  20c864:	0020c8ac 	andhi	zero,zero,33570
  20c868:	0020c8ac 	andhi	zero,zero,33570
  20c86c:	0020c8ac 	andhi	zero,zero,33570
  20c870:	0020c89c 	xori	zero,zero,33570
  20c874:	0020c8a4 	muli	zero,zero,-31966
  20c878:	0020c8ac 	andhi	zero,zero,33570
  20c87c:	0020c89c 	xori	zero,zero,33570
  20c880:	0020c89c 	xori	zero,zero,33570
  20c884:	0020c8ac 	andhi	zero,zero,33570
  20c888:	0020c89c 	xori	zero,zero,33570
  20c88c:	0020c8a4 	muli	zero,zero,-31966
  20c890:	0020c8ac 	andhi	zero,zero,33570
  20c894:	0020c8ac 	andhi	zero,zero,33570
  20c898:	0020c89c 	xori	zero,zero,33570
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
  20c89c:	00800044 	movi	r2,1
  20c8a0:	00000306 	br	20c8b0 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
  20c8a4:	0005883a 	mov	r2,zero
  20c8a8:	00000106 	br	20c8b0 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
  20c8ac:	0005883a 	mov	r2,zero
  }
}
  20c8b0:	e037883a 	mov	sp,fp
  20c8b4:	df000017 	ldw	fp,0(sp)
  20c8b8:	dec00104 	addi	sp,sp,4
  20c8bc:	f800283a 	ret

0020c8c0 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  20c8c0:	defff804 	addi	sp,sp,-32
  20c8c4:	dfc00715 	stw	ra,28(sp)
  20c8c8:	df000615 	stw	fp,24(sp)
  20c8cc:	dc000515 	stw	r16,20(sp)
  20c8d0:	df000604 	addi	fp,sp,24
  20c8d4:	e13ffb15 	stw	r4,-20(fp)
  20c8d8:	e17ffc15 	stw	r5,-16(fp)
  20c8dc:	e1bffd15 	stw	r6,-12(fp)
  20c8e0:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
  20c8e4:	e1bffe17 	ldw	r6,-8(fp)
  20c8e8:	e17ffd17 	ldw	r5,-12(fp)
  20c8ec:	e13ffc17 	ldw	r4,-16(fp)
  20c8f0:	020cb480 	call	20cb48 <open>
  20c8f4:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
  20c8f8:	e0bffa17 	ldw	r2,-24(fp)
  20c8fc:	10002216 	blt	r2,zero,20c988 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
  20c900:	04000874 	movhi	r16,33
  20c904:	84378e04 	addi	r16,r16,-8648
  20c908:	e0bffa17 	ldw	r2,-24(fp)
  20c90c:	01400304 	movi	r5,12
  20c910:	1009883a 	mov	r4,r2
  20c914:	020d7a80 	call	20d7a8 <__mulsi3>
  20c918:	8085883a 	add	r2,r16,r2
  20c91c:	10c00017 	ldw	r3,0(r2)
  20c920:	e0bffb17 	ldw	r2,-20(fp)
  20c924:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  20c928:	04000874 	movhi	r16,33
  20c92c:	84378e04 	addi	r16,r16,-8648
  20c930:	e0bffa17 	ldw	r2,-24(fp)
  20c934:	01400304 	movi	r5,12
  20c938:	1009883a 	mov	r4,r2
  20c93c:	020d7a80 	call	20d7a8 <__mulsi3>
  20c940:	8085883a 	add	r2,r16,r2
  20c944:	10800104 	addi	r2,r2,4
  20c948:	10c00017 	ldw	r3,0(r2)
  20c94c:	e0bffb17 	ldw	r2,-20(fp)
  20c950:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  20c954:	04000874 	movhi	r16,33
  20c958:	84378e04 	addi	r16,r16,-8648
  20c95c:	e0bffa17 	ldw	r2,-24(fp)
  20c960:	01400304 	movi	r5,12
  20c964:	1009883a 	mov	r4,r2
  20c968:	020d7a80 	call	20d7a8 <__mulsi3>
  20c96c:	8085883a 	add	r2,r16,r2
  20c970:	10800204 	addi	r2,r2,8
  20c974:	10c00017 	ldw	r3,0(r2)
  20c978:	e0bffb17 	ldw	r2,-20(fp)
  20c97c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  20c980:	e13ffa17 	ldw	r4,-24(fp)
  20c984:	020cca40 	call	20cca4 <alt_release_fd>
  }
} 
  20c988:	0001883a 	nop
  20c98c:	e6ffff04 	addi	sp,fp,-4
  20c990:	dfc00217 	ldw	ra,8(sp)
  20c994:	df000117 	ldw	fp,4(sp)
  20c998:	dc000017 	ldw	r16,0(sp)
  20c99c:	dec00304 	addi	sp,sp,12
  20c9a0:	f800283a 	ret

0020c9a4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  20c9a4:	defffb04 	addi	sp,sp,-20
  20c9a8:	dfc00415 	stw	ra,16(sp)
  20c9ac:	df000315 	stw	fp,12(sp)
  20c9b0:	df000304 	addi	fp,sp,12
  20c9b4:	e13ffd15 	stw	r4,-12(fp)
  20c9b8:	e17ffe15 	stw	r5,-8(fp)
  20c9bc:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  20c9c0:	01c07fc4 	movi	r7,511
  20c9c4:	01800044 	movi	r6,1
  20c9c8:	e17ffd17 	ldw	r5,-12(fp)
  20c9cc:	01000874 	movhi	r4,33
  20c9d0:	21379104 	addi	r4,r4,-8636
  20c9d4:	020c8c00 	call	20c8c0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  20c9d8:	01c07fc4 	movi	r7,511
  20c9dc:	000d883a 	mov	r6,zero
  20c9e0:	e17ffe17 	ldw	r5,-8(fp)
  20c9e4:	01000874 	movhi	r4,33
  20c9e8:	21378e04 	addi	r4,r4,-8648
  20c9ec:	020c8c00 	call	20c8c0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  20c9f0:	01c07fc4 	movi	r7,511
  20c9f4:	01800044 	movi	r6,1
  20c9f8:	e17fff17 	ldw	r5,-4(fp)
  20c9fc:	01000874 	movhi	r4,33
  20ca00:	21379404 	addi	r4,r4,-8624
  20ca04:	020c8c00 	call	20c8c0 <alt_open_fd>
}  
  20ca08:	0001883a 	nop
  20ca0c:	e037883a 	mov	sp,fp
  20ca10:	dfc00117 	ldw	ra,4(sp)
  20ca14:	df000017 	ldw	fp,0(sp)
  20ca18:	dec00204 	addi	sp,sp,8
  20ca1c:	f800283a 	ret

0020ca20 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  20ca20:	defffe04 	addi	sp,sp,-8
  20ca24:	dfc00115 	stw	ra,4(sp)
  20ca28:	df000015 	stw	fp,0(sp)
  20ca2c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  20ca30:	d0a01617 	ldw	r2,-32680(gp)
  20ca34:	10000326 	beq	r2,zero,20ca44 <alt_get_errno+0x24>
  20ca38:	d0a01617 	ldw	r2,-32680(gp)
  20ca3c:	103ee83a 	callr	r2
  20ca40:	00000106 	br	20ca48 <alt_get_errno+0x28>
  20ca44:	d0a1a504 	addi	r2,gp,-31084
}
  20ca48:	e037883a 	mov	sp,fp
  20ca4c:	dfc00117 	ldw	ra,4(sp)
  20ca50:	df000017 	ldw	fp,0(sp)
  20ca54:	dec00204 	addi	sp,sp,8
  20ca58:	f800283a 	ret

0020ca5c <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  20ca5c:	defffb04 	addi	sp,sp,-20
  20ca60:	dfc00415 	stw	ra,16(sp)
  20ca64:	df000315 	stw	fp,12(sp)
  20ca68:	dc000215 	stw	r16,8(sp)
  20ca6c:	df000304 	addi	fp,sp,12
  20ca70:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  20ca74:	e0bffe17 	ldw	r2,-8(fp)
  20ca78:	10800217 	ldw	r2,8(r2)
  20ca7c:	10d00034 	orhi	r3,r2,16384
  20ca80:	e0bffe17 	ldw	r2,-8(fp)
  20ca84:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  20ca88:	e03ffd15 	stw	zero,-12(fp)
  20ca8c:	00002306 	br	20cb1c <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  20ca90:	04000874 	movhi	r16,33
  20ca94:	84378e04 	addi	r16,r16,-8648
  20ca98:	e0bffd17 	ldw	r2,-12(fp)
  20ca9c:	01400304 	movi	r5,12
  20caa0:	1009883a 	mov	r4,r2
  20caa4:	020d7a80 	call	20d7a8 <__mulsi3>
  20caa8:	8085883a 	add	r2,r16,r2
  20caac:	10c00017 	ldw	r3,0(r2)
  20cab0:	e0bffe17 	ldw	r2,-8(fp)
  20cab4:	10800017 	ldw	r2,0(r2)
  20cab8:	1880151e 	bne	r3,r2,20cb10 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  20cabc:	04000874 	movhi	r16,33
  20cac0:	84378e04 	addi	r16,r16,-8648
  20cac4:	e0bffd17 	ldw	r2,-12(fp)
  20cac8:	01400304 	movi	r5,12
  20cacc:	1009883a 	mov	r4,r2
  20cad0:	020d7a80 	call	20d7a8 <__mulsi3>
  20cad4:	8085883a 	add	r2,r16,r2
  20cad8:	10800204 	addi	r2,r2,8
  20cadc:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  20cae0:	10000b0e 	bge	r2,zero,20cb10 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  20cae4:	01400304 	movi	r5,12
  20cae8:	e13ffd17 	ldw	r4,-12(fp)
  20caec:	020d7a80 	call	20d7a8 <__mulsi3>
  20caf0:	1007883a 	mov	r3,r2
  20caf4:	00800874 	movhi	r2,33
  20caf8:	10b78e04 	addi	r2,r2,-8648
  20cafc:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  20cb00:	e0bffe17 	ldw	r2,-8(fp)
  20cb04:	18800226 	beq	r3,r2,20cb10 <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  20cb08:	00bffcc4 	movi	r2,-13
  20cb0c:	00000806 	br	20cb30 <alt_file_locked+0xd4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  20cb10:	e0bffd17 	ldw	r2,-12(fp)
  20cb14:	10800044 	addi	r2,r2,1
  20cb18:	e0bffd15 	stw	r2,-12(fp)
  20cb1c:	d0a01517 	ldw	r2,-32684(gp)
  20cb20:	1007883a 	mov	r3,r2
  20cb24:	e0bffd17 	ldw	r2,-12(fp)
  20cb28:	18bfd92e 	bgeu	r3,r2,20ca90 <_gp+0xffff69f8>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  20cb2c:	0005883a 	mov	r2,zero
}
  20cb30:	e6ffff04 	addi	sp,fp,-4
  20cb34:	dfc00217 	ldw	ra,8(sp)
  20cb38:	df000117 	ldw	fp,4(sp)
  20cb3c:	dc000017 	ldw	r16,0(sp)
  20cb40:	dec00304 	addi	sp,sp,12
  20cb44:	f800283a 	ret

0020cb48 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  20cb48:	defff604 	addi	sp,sp,-40
  20cb4c:	dfc00915 	stw	ra,36(sp)
  20cb50:	df000815 	stw	fp,32(sp)
  20cb54:	df000804 	addi	fp,sp,32
  20cb58:	e13ffd15 	stw	r4,-12(fp)
  20cb5c:	e17ffe15 	stw	r5,-8(fp)
  20cb60:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  20cb64:	00bfffc4 	movi	r2,-1
  20cb68:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  20cb6c:	00bffb44 	movi	r2,-19
  20cb70:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  20cb74:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  20cb78:	d1601304 	addi	r5,gp,-32692
  20cb7c:	e13ffd17 	ldw	r4,-12(fp)
  20cb80:	020c7740 	call	20c774 <alt_find_dev>
  20cb84:	e0bff815 	stw	r2,-32(fp)
  20cb88:	e0bff817 	ldw	r2,-32(fp)
  20cb8c:	1000051e 	bne	r2,zero,20cba4 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  20cb90:	e13ffd17 	ldw	r4,-12(fp)
  20cb94:	020d0780 	call	20d078 <alt_find_file>
  20cb98:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  20cb9c:	00800044 	movi	r2,1
  20cba0:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  20cba4:	e0bff817 	ldw	r2,-32(fp)
  20cba8:	10002b26 	beq	r2,zero,20cc58 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
  20cbac:	e13ff817 	ldw	r4,-32(fp)
  20cbb0:	020d1800 	call	20d180 <alt_get_fd>
  20cbb4:	e0bff915 	stw	r2,-28(fp)
  20cbb8:	e0bff917 	ldw	r2,-28(fp)
  20cbbc:	1000030e 	bge	r2,zero,20cbcc <open+0x84>
    {
      status = index;
  20cbc0:	e0bff917 	ldw	r2,-28(fp)
  20cbc4:	e0bffa15 	stw	r2,-24(fp)
  20cbc8:	00002506 	br	20cc60 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
  20cbcc:	01400304 	movi	r5,12
  20cbd0:	e13ff917 	ldw	r4,-28(fp)
  20cbd4:	020d7a80 	call	20d7a8 <__mulsi3>
  20cbd8:	1007883a 	mov	r3,r2
  20cbdc:	00800874 	movhi	r2,33
  20cbe0:	10b78e04 	addi	r2,r2,-8648
  20cbe4:	1885883a 	add	r2,r3,r2
  20cbe8:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  20cbec:	e0fffe17 	ldw	r3,-8(fp)
  20cbf0:	00900034 	movhi	r2,16384
  20cbf4:	10bfffc4 	addi	r2,r2,-1
  20cbf8:	1886703a 	and	r3,r3,r2
  20cbfc:	e0bffc17 	ldw	r2,-16(fp)
  20cc00:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  20cc04:	e0bffb17 	ldw	r2,-20(fp)
  20cc08:	1000051e 	bne	r2,zero,20cc20 <open+0xd8>
  20cc0c:	e13ffc17 	ldw	r4,-16(fp)
  20cc10:	020ca5c0 	call	20ca5c <alt_file_locked>
  20cc14:	e0bffa15 	stw	r2,-24(fp)
  20cc18:	e0bffa17 	ldw	r2,-24(fp)
  20cc1c:	10001016 	blt	r2,zero,20cc60 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  20cc20:	e0bff817 	ldw	r2,-32(fp)
  20cc24:	10800317 	ldw	r2,12(r2)
  20cc28:	10000826 	beq	r2,zero,20cc4c <open+0x104>
  20cc2c:	e0bff817 	ldw	r2,-32(fp)
  20cc30:	10800317 	ldw	r2,12(r2)
  20cc34:	e1ffff17 	ldw	r7,-4(fp)
  20cc38:	e1bffe17 	ldw	r6,-8(fp)
  20cc3c:	e17ffd17 	ldw	r5,-12(fp)
  20cc40:	e13ffc17 	ldw	r4,-16(fp)
  20cc44:	103ee83a 	callr	r2
  20cc48:	00000106 	br	20cc50 <open+0x108>
  20cc4c:	0005883a 	mov	r2,zero
  20cc50:	e0bffa15 	stw	r2,-24(fp)
  20cc54:	00000206 	br	20cc60 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
  20cc58:	00bffb44 	movi	r2,-19
  20cc5c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  20cc60:	e0bffa17 	ldw	r2,-24(fp)
  20cc64:	1000090e 	bge	r2,zero,20cc8c <open+0x144>
  {
    alt_release_fd (index);  
  20cc68:	e13ff917 	ldw	r4,-28(fp)
  20cc6c:	020cca40 	call	20cca4 <alt_release_fd>
    ALT_ERRNO = -status;
  20cc70:	020ca200 	call	20ca20 <alt_get_errno>
  20cc74:	1007883a 	mov	r3,r2
  20cc78:	e0bffa17 	ldw	r2,-24(fp)
  20cc7c:	0085c83a 	sub	r2,zero,r2
  20cc80:	18800015 	stw	r2,0(r3)
    return -1;
  20cc84:	00bfffc4 	movi	r2,-1
  20cc88:	00000106 	br	20cc90 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
  20cc8c:	e0bff917 	ldw	r2,-28(fp)
}
  20cc90:	e037883a 	mov	sp,fp
  20cc94:	dfc00117 	ldw	ra,4(sp)
  20cc98:	df000017 	ldw	fp,0(sp)
  20cc9c:	dec00204 	addi	sp,sp,8
  20cca0:	f800283a 	ret

0020cca4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  20cca4:	defffc04 	addi	sp,sp,-16
  20cca8:	dfc00315 	stw	ra,12(sp)
  20ccac:	df000215 	stw	fp,8(sp)
  20ccb0:	dc000115 	stw	r16,4(sp)
  20ccb4:	df000204 	addi	fp,sp,8
  20ccb8:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
  20ccbc:	e0bffe17 	ldw	r2,-8(fp)
  20ccc0:	108000d0 	cmplti	r2,r2,3
  20ccc4:	1000111e 	bne	r2,zero,20cd0c <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
  20ccc8:	04000874 	movhi	r16,33
  20cccc:	84378e04 	addi	r16,r16,-8648
  20ccd0:	e0bffe17 	ldw	r2,-8(fp)
  20ccd4:	01400304 	movi	r5,12
  20ccd8:	1009883a 	mov	r4,r2
  20ccdc:	020d7a80 	call	20d7a8 <__mulsi3>
  20cce0:	8085883a 	add	r2,r16,r2
  20cce4:	10800204 	addi	r2,r2,8
  20cce8:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  20ccec:	04000874 	movhi	r16,33
  20ccf0:	84378e04 	addi	r16,r16,-8648
  20ccf4:	e0bffe17 	ldw	r2,-8(fp)
  20ccf8:	01400304 	movi	r5,12
  20ccfc:	1009883a 	mov	r4,r2
  20cd00:	020d7a80 	call	20d7a8 <__mulsi3>
  20cd04:	8085883a 	add	r2,r16,r2
  20cd08:	10000015 	stw	zero,0(r2)
  }
}
  20cd0c:	0001883a 	nop
  20cd10:	e6ffff04 	addi	sp,fp,-4
  20cd14:	dfc00217 	ldw	ra,8(sp)
  20cd18:	df000117 	ldw	fp,4(sp)
  20cd1c:	dc000017 	ldw	r16,0(sp)
  20cd20:	dec00304 	addi	sp,sp,12
  20cd24:	f800283a 	ret

0020cd28 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  20cd28:	defffa04 	addi	sp,sp,-24
  20cd2c:	df000515 	stw	fp,20(sp)
  20cd30:	df000504 	addi	fp,sp,20
  20cd34:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20cd38:	0005303a 	rdctl	r2,status
  20cd3c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20cd40:	e0fffc17 	ldw	r3,-16(fp)
  20cd44:	00bfff84 	movi	r2,-2
  20cd48:	1884703a 	and	r2,r3,r2
  20cd4c:	1001703a 	wrctl	status,r2
  
  return context;
  20cd50:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  20cd54:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  20cd58:	e0bfff17 	ldw	r2,-4(fp)
  20cd5c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  20cd60:	e0bffd17 	ldw	r2,-12(fp)
  20cd64:	10800017 	ldw	r2,0(r2)
  20cd68:	e0fffd17 	ldw	r3,-12(fp)
  20cd6c:	18c00117 	ldw	r3,4(r3)
  20cd70:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  20cd74:	e0bffd17 	ldw	r2,-12(fp)
  20cd78:	10800117 	ldw	r2,4(r2)
  20cd7c:	e0fffd17 	ldw	r3,-12(fp)
  20cd80:	18c00017 	ldw	r3,0(r3)
  20cd84:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  20cd88:	e0bffd17 	ldw	r2,-12(fp)
  20cd8c:	e0fffd17 	ldw	r3,-12(fp)
  20cd90:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  20cd94:	e0bffd17 	ldw	r2,-12(fp)
  20cd98:	e0fffd17 	ldw	r3,-12(fp)
  20cd9c:	10c00015 	stw	r3,0(r2)
  20cda0:	e0bffb17 	ldw	r2,-20(fp)
  20cda4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20cda8:	e0bffe17 	ldw	r2,-8(fp)
  20cdac:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  20cdb0:	0001883a 	nop
  20cdb4:	e037883a 	mov	sp,fp
  20cdb8:	df000017 	ldw	fp,0(sp)
  20cdbc:	dec00104 	addi	sp,sp,4
  20cdc0:	f800283a 	ret

0020cdc4 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  20cdc4:	defffb04 	addi	sp,sp,-20
  20cdc8:	dfc00415 	stw	ra,16(sp)
  20cdcc:	df000315 	stw	fp,12(sp)
  20cdd0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  20cdd4:	d0a01717 	ldw	r2,-32676(gp)
  20cdd8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  20cddc:	d0a1a417 	ldw	r2,-31088(gp)
  20cde0:	10800044 	addi	r2,r2,1
  20cde4:	d0a1a415 	stw	r2,-31088(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  20cde8:	00002e06 	br	20cea4 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  20cdec:	e0bffd17 	ldw	r2,-12(fp)
  20cdf0:	10800017 	ldw	r2,0(r2)
  20cdf4:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  20cdf8:	e0bffd17 	ldw	r2,-12(fp)
  20cdfc:	10800403 	ldbu	r2,16(r2)
  20ce00:	10803fcc 	andi	r2,r2,255
  20ce04:	10000426 	beq	r2,zero,20ce18 <alt_tick+0x54>
  20ce08:	d0a1a417 	ldw	r2,-31088(gp)
  20ce0c:	1000021e 	bne	r2,zero,20ce18 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  20ce10:	e0bffd17 	ldw	r2,-12(fp)
  20ce14:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  20ce18:	e0bffd17 	ldw	r2,-12(fp)
  20ce1c:	10800217 	ldw	r2,8(r2)
  20ce20:	d0e1a417 	ldw	r3,-31088(gp)
  20ce24:	18801d36 	bltu	r3,r2,20ce9c <alt_tick+0xd8>
  20ce28:	e0bffd17 	ldw	r2,-12(fp)
  20ce2c:	10800403 	ldbu	r2,16(r2)
  20ce30:	10803fcc 	andi	r2,r2,255
  20ce34:	1000191e 	bne	r2,zero,20ce9c <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  20ce38:	e0bffd17 	ldw	r2,-12(fp)
  20ce3c:	10800317 	ldw	r2,12(r2)
  20ce40:	e0fffd17 	ldw	r3,-12(fp)
  20ce44:	18c00517 	ldw	r3,20(r3)
  20ce48:	1809883a 	mov	r4,r3
  20ce4c:	103ee83a 	callr	r2
  20ce50:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  20ce54:	e0bfff17 	ldw	r2,-4(fp)
  20ce58:	1000031e 	bne	r2,zero,20ce68 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  20ce5c:	e13ffd17 	ldw	r4,-12(fp)
  20ce60:	020cd280 	call	20cd28 <alt_alarm_stop>
  20ce64:	00000d06 	br	20ce9c <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  20ce68:	e0bffd17 	ldw	r2,-12(fp)
  20ce6c:	10c00217 	ldw	r3,8(r2)
  20ce70:	e0bfff17 	ldw	r2,-4(fp)
  20ce74:	1887883a 	add	r3,r3,r2
  20ce78:	e0bffd17 	ldw	r2,-12(fp)
  20ce7c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  20ce80:	e0bffd17 	ldw	r2,-12(fp)
  20ce84:	10c00217 	ldw	r3,8(r2)
  20ce88:	d0a1a417 	ldw	r2,-31088(gp)
  20ce8c:	1880032e 	bgeu	r3,r2,20ce9c <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  20ce90:	e0bffd17 	ldw	r2,-12(fp)
  20ce94:	00c00044 	movi	r3,1
  20ce98:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  20ce9c:	e0bffe17 	ldw	r2,-8(fp)
  20cea0:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  20cea4:	e0fffd17 	ldw	r3,-12(fp)
  20cea8:	d0a01704 	addi	r2,gp,-32676
  20ceac:	18bfcf1e 	bne	r3,r2,20cdec <_gp+0xffff6d54>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  20ceb0:	0001883a 	nop
}
  20ceb4:	0001883a 	nop
  20ceb8:	e037883a 	mov	sp,fp
  20cebc:	dfc00117 	ldw	ra,4(sp)
  20cec0:	df000017 	ldw	fp,0(sp)
  20cec4:	dec00204 	addi	sp,sp,8
  20cec8:	f800283a 	ret

0020cecc <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  20cecc:	defffd04 	addi	sp,sp,-12
  20ced0:	dfc00215 	stw	ra,8(sp)
  20ced4:	df000115 	stw	fp,4(sp)
  20ced8:	df000104 	addi	fp,sp,4
  20cedc:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
  20cee0:	e13fff17 	ldw	r4,-4(fp)
  20cee4:	020cf200 	call	20cf20 <alt_busy_sleep>
}
  20cee8:	e037883a 	mov	sp,fp
  20ceec:	dfc00117 	ldw	ra,4(sp)
  20cef0:	df000017 	ldw	fp,0(sp)
  20cef4:	dec00204 	addi	sp,sp,8
  20cef8:	f800283a 	ret

0020cefc <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  20cefc:	deffff04 	addi	sp,sp,-4
  20cf00:	df000015 	stw	fp,0(sp)
  20cf04:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  20cf08:	000170fa 	wrctl	ienable,zero
}
  20cf0c:	0001883a 	nop
  20cf10:	e037883a 	mov	sp,fp
  20cf14:	df000017 	ldw	fp,0(sp)
  20cf18:	dec00104 	addi	sp,sp,4
  20cf1c:	f800283a 	ret

0020cf20 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  20cf20:	defffa04 	addi	sp,sp,-24
  20cf24:	dfc00515 	stw	ra,20(sp)
  20cf28:	df000415 	stw	fp,16(sp)
  20cf2c:	df000404 	addi	fp,sp,16
  20cf30:	e13fff15 	stw	r4,-4(fp)
  int big_loops;
  alt_u32 cycles_per_loop;
  
  if (!strcmp(NIOS2_CPU_IMPLEMENTATION,"tiny"))
  {
    cycles_per_loop = 9;
  20cf34:	00800244 	movi	r2,9
  20cf38:	e0bffd15 	stw	r2,-12(fp)
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
  20cf3c:	014003f4 	movhi	r5,15
  20cf40:	29509004 	addi	r5,r5,16960
  20cf44:	e13ffd17 	ldw	r4,-12(fp)
  20cf48:	020d7a80 	call	20d7a8 <__mulsi3>
  20cf4c:	100b883a 	mov	r5,r2
  20cf50:	01017db4 	movhi	r4,1526
  20cf54:	21384004 	addi	r4,r4,-7936
  20cf58:	020d6ec0 	call	20d6ec <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  20cf5c:	100b883a 	mov	r5,r2
  20cf60:	01200034 	movhi	r4,32768
  20cf64:	213fffc4 	addi	r4,r4,-1
  20cf68:	020d6ec0 	call	20d6ec <__udivsi3>
  20cf6c:	100b883a 	mov	r5,r2
  20cf70:	e13fff17 	ldw	r4,-4(fp)
  20cf74:	020d6ec0 	call	20d6ec <__udivsi3>
  20cf78:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  20cf7c:	e0bffe17 	ldw	r2,-8(fp)
  20cf80:	10002a26 	beq	r2,zero,20d02c <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
  20cf84:	e03ffc15 	stw	zero,-16(fp)
  20cf88:	00001706 	br	20cfe8 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  20cf8c:	00a00034 	movhi	r2,32768
  20cf90:	10bfffc4 	addi	r2,r2,-1
  20cf94:	10bfffc4 	addi	r2,r2,-1
  20cf98:	103ffe1e 	bne	r2,zero,20cf94 <_gp+0xffff6efc>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
  20cf9c:	014003f4 	movhi	r5,15
  20cfa0:	29509004 	addi	r5,r5,16960
  20cfa4:	e13ffd17 	ldw	r4,-12(fp)
  20cfa8:	020d7a80 	call	20d7a8 <__mulsi3>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  20cfac:	100b883a 	mov	r5,r2
  20cfb0:	01017db4 	movhi	r4,1526
  20cfb4:	21384004 	addi	r4,r4,-7936
  20cfb8:	020d6ec0 	call	20d6ec <__udivsi3>
  20cfbc:	100b883a 	mov	r5,r2
  20cfc0:	01200034 	movhi	r4,32768
  20cfc4:	213fffc4 	addi	r4,r4,-1
  20cfc8:	020d6ec0 	call	20d6ec <__udivsi3>
  20cfcc:	1007883a 	mov	r3,r2
  20cfd0:	e0bfff17 	ldw	r2,-4(fp)
  20cfd4:	10c5c83a 	sub	r2,r2,r3
  20cfd8:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  20cfdc:	e0bffc17 	ldw	r2,-16(fp)
  20cfe0:	10800044 	addi	r2,r2,1
  20cfe4:	e0bffc15 	stw	r2,-16(fp)
  20cfe8:	e0fffc17 	ldw	r3,-16(fp)
  20cfec:	e0bffe17 	ldw	r2,-8(fp)
  20cff0:	18bfe616 	blt	r3,r2,20cf8c <_gp+0xffff6ef4>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  20cff4:	014003f4 	movhi	r5,15
  20cff8:	29509004 	addi	r5,r5,16960
  20cffc:	e13ffd17 	ldw	r4,-12(fp)
  20d000:	020d7a80 	call	20d7a8 <__mulsi3>
  20d004:	100b883a 	mov	r5,r2
  20d008:	01017db4 	movhi	r4,1526
  20d00c:	21384004 	addi	r4,r4,-7936
  20d010:	020d6ec0 	call	20d6ec <__udivsi3>
  20d014:	e17fff17 	ldw	r5,-4(fp)
  20d018:	1009883a 	mov	r4,r2
  20d01c:	020d7a80 	call	20d7a8 <__mulsi3>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  20d020:	10bfffc4 	addi	r2,r2,-1
  20d024:	103ffe1e 	bne	r2,zero,20d020 <_gp+0xffff6f88>
  20d028:	00000d06 	br	20d060 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  20d02c:	014003f4 	movhi	r5,15
  20d030:	29509004 	addi	r5,r5,16960
  20d034:	e13ffd17 	ldw	r4,-12(fp)
  20d038:	020d7a80 	call	20d7a8 <__mulsi3>
  20d03c:	100b883a 	mov	r5,r2
  20d040:	01017db4 	movhi	r4,1526
  20d044:	21384004 	addi	r4,r4,-7936
  20d048:	020d6ec0 	call	20d6ec <__udivsi3>
  20d04c:	e17fff17 	ldw	r5,-4(fp)
  20d050:	1009883a 	mov	r4,r2
  20d054:	020d7a80 	call	20d7a8 <__mulsi3>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  20d058:	10bfffc4 	addi	r2,r2,-1
  20d05c:	00bffe16 	blt	zero,r2,20d058 <_gp+0xffff6fc0>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
  20d060:	0005883a 	mov	r2,zero
}
  20d064:	e037883a 	mov	sp,fp
  20d068:	dfc00117 	ldw	ra,4(sp)
  20d06c:	df000017 	ldw	fp,0(sp)
  20d070:	dec00204 	addi	sp,sp,8
  20d074:	f800283a 	ret

0020d078 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  20d078:	defffb04 	addi	sp,sp,-20
  20d07c:	dfc00415 	stw	ra,16(sp)
  20d080:	df000315 	stw	fp,12(sp)
  20d084:	df000304 	addi	fp,sp,12
  20d088:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  20d08c:	d0a01117 	ldw	r2,-32700(gp)
  20d090:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  20d094:	00003106 	br	20d15c <alt_find_file+0xe4>
  {
    len = strlen(next->name);
  20d098:	e0bffd17 	ldw	r2,-12(fp)
  20d09c:	10800217 	ldw	r2,8(r2)
  20d0a0:	1009883a 	mov	r4,r2
  20d0a4:	020d2f00 	call	20d2f0 <strlen>
  20d0a8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  20d0ac:	e0bffd17 	ldw	r2,-12(fp)
  20d0b0:	10c00217 	ldw	r3,8(r2)
  20d0b4:	e0bffe17 	ldw	r2,-8(fp)
  20d0b8:	10bfffc4 	addi	r2,r2,-1
  20d0bc:	1885883a 	add	r2,r3,r2
  20d0c0:	10800003 	ldbu	r2,0(r2)
  20d0c4:	10803fcc 	andi	r2,r2,255
  20d0c8:	1080201c 	xori	r2,r2,128
  20d0cc:	10bfe004 	addi	r2,r2,-128
  20d0d0:	10800bd8 	cmpnei	r2,r2,47
  20d0d4:	1000031e 	bne	r2,zero,20d0e4 <alt_find_file+0x6c>
    {
      len -= 1;
  20d0d8:	e0bffe17 	ldw	r2,-8(fp)
  20d0dc:	10bfffc4 	addi	r2,r2,-1
  20d0e0:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  20d0e4:	e0bffe17 	ldw	r2,-8(fp)
  20d0e8:	e0ffff17 	ldw	r3,-4(fp)
  20d0ec:	1885883a 	add	r2,r3,r2
  20d0f0:	10800003 	ldbu	r2,0(r2)
  20d0f4:	10803fcc 	andi	r2,r2,255
  20d0f8:	1080201c 	xori	r2,r2,128
  20d0fc:	10bfe004 	addi	r2,r2,-128
  20d100:	10800be0 	cmpeqi	r2,r2,47
  20d104:	1000081e 	bne	r2,zero,20d128 <alt_find_file+0xb0>
  20d108:	e0bffe17 	ldw	r2,-8(fp)
  20d10c:	e0ffff17 	ldw	r3,-4(fp)
  20d110:	1885883a 	add	r2,r3,r2
  20d114:	10800003 	ldbu	r2,0(r2)
  20d118:	10803fcc 	andi	r2,r2,255
  20d11c:	1080201c 	xori	r2,r2,128
  20d120:	10bfe004 	addi	r2,r2,-128
  20d124:	10000a1e 	bne	r2,zero,20d150 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
  20d128:	e0bffd17 	ldw	r2,-12(fp)
  20d12c:	10800217 	ldw	r2,8(r2)
  20d130:	e0fffe17 	ldw	r3,-8(fp)
  20d134:	180d883a 	mov	r6,r3
  20d138:	e17fff17 	ldw	r5,-4(fp)
  20d13c:	1009883a 	mov	r4,r2
  20d140:	020d2780 	call	20d278 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  20d144:	1000021e 	bne	r2,zero,20d150 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  20d148:	e0bffd17 	ldw	r2,-12(fp)
  20d14c:	00000706 	br	20d16c <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
  20d150:	e0bffd17 	ldw	r2,-12(fp)
  20d154:	10800017 	ldw	r2,0(r2)
  20d158:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  20d15c:	e0fffd17 	ldw	r3,-12(fp)
  20d160:	d0a01104 	addi	r2,gp,-32700
  20d164:	18bfcc1e 	bne	r3,r2,20d098 <_gp+0xffff7000>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  20d168:	0005883a 	mov	r2,zero
}
  20d16c:	e037883a 	mov	sp,fp
  20d170:	dfc00117 	ldw	ra,4(sp)
  20d174:	df000017 	ldw	fp,0(sp)
  20d178:	dec00204 	addi	sp,sp,8
  20d17c:	f800283a 	ret

0020d180 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  20d180:	defffa04 	addi	sp,sp,-24
  20d184:	dfc00515 	stw	ra,20(sp)
  20d188:	df000415 	stw	fp,16(sp)
  20d18c:	dc000315 	stw	r16,12(sp)
  20d190:	df000404 	addi	fp,sp,16
  20d194:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
  20d198:	00bffa04 	movi	r2,-24
  20d19c:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  20d1a0:	e03ffc15 	stw	zero,-16(fp)
  20d1a4:	00001d06 	br	20d21c <alt_get_fd+0x9c>
  {
    if (!alt_fd_list[i].dev)
  20d1a8:	04000874 	movhi	r16,33
  20d1ac:	84378e04 	addi	r16,r16,-8648
  20d1b0:	e0bffc17 	ldw	r2,-16(fp)
  20d1b4:	01400304 	movi	r5,12
  20d1b8:	1009883a 	mov	r4,r2
  20d1bc:	020d7a80 	call	20d7a8 <__mulsi3>
  20d1c0:	8085883a 	add	r2,r16,r2
  20d1c4:	10800017 	ldw	r2,0(r2)
  20d1c8:	1000111e 	bne	r2,zero,20d210 <alt_get_fd+0x90>
    {
      alt_fd_list[i].dev = dev;
  20d1cc:	04000874 	movhi	r16,33
  20d1d0:	84378e04 	addi	r16,r16,-8648
  20d1d4:	e0bffc17 	ldw	r2,-16(fp)
  20d1d8:	01400304 	movi	r5,12
  20d1dc:	1009883a 	mov	r4,r2
  20d1e0:	020d7a80 	call	20d7a8 <__mulsi3>
  20d1e4:	8085883a 	add	r2,r16,r2
  20d1e8:	e0fffe17 	ldw	r3,-8(fp)
  20d1ec:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  20d1f0:	d0e01517 	ldw	r3,-32684(gp)
  20d1f4:	e0bffc17 	ldw	r2,-16(fp)
  20d1f8:	1880020e 	bge	r3,r2,20d204 <alt_get_fd+0x84>
      {
        alt_max_fd = i;
  20d1fc:	e0bffc17 	ldw	r2,-16(fp)
  20d200:	d0a01515 	stw	r2,-32684(gp)
      }
      rc = i;
  20d204:	e0bffc17 	ldw	r2,-16(fp)
  20d208:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
  20d20c:	00000606 	br	20d228 <alt_get_fd+0xa8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  20d210:	e0bffc17 	ldw	r2,-16(fp)
  20d214:	10800044 	addi	r2,r2,1
  20d218:	e0bffc15 	stw	r2,-16(fp)
  20d21c:	e0bffc17 	ldw	r2,-16(fp)
  20d220:	10800810 	cmplti	r2,r2,32
  20d224:	103fe01e 	bne	r2,zero,20d1a8 <_gp+0xffff7110>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  20d228:	e0bffd17 	ldw	r2,-12(fp)
}
  20d22c:	e6ffff04 	addi	sp,fp,-4
  20d230:	dfc00217 	ldw	ra,8(sp)
  20d234:	df000117 	ldw	fp,4(sp)
  20d238:	dc000017 	ldw	r16,0(sp)
  20d23c:	dec00304 	addi	sp,sp,12
  20d240:	f800283a 	ret

0020d244 <atexit>:
  20d244:	200b883a 	mov	r5,r4
  20d248:	000f883a 	mov	r7,zero
  20d24c:	000d883a 	mov	r6,zero
  20d250:	0009883a 	mov	r4,zero
  20d254:	020d30c1 	jmpi	20d30c <__register_exitproc>

0020d258 <exit>:
  20d258:	defffe04 	addi	sp,sp,-8
  20d25c:	000b883a 	mov	r5,zero
  20d260:	dc000015 	stw	r16,0(sp)
  20d264:	dfc00115 	stw	ra,4(sp)
  20d268:	2021883a 	mov	r16,r4
  20d26c:	020d4640 	call	20d464 <__call_exitprocs>
  20d270:	8009883a 	mov	r4,r16
  20d274:	020d7d00 	call	20d7d0 <_exit>

0020d278 <memcmp>:
  20d278:	218d883a 	add	r6,r4,r6
  20d27c:	21800826 	beq	r4,r6,20d2a0 <memcmp+0x28>
  20d280:	20800003 	ldbu	r2,0(r4)
  20d284:	28c00003 	ldbu	r3,0(r5)
  20d288:	10c00226 	beq	r2,r3,20d294 <memcmp+0x1c>
  20d28c:	10c5c83a 	sub	r2,r2,r3
  20d290:	f800283a 	ret
  20d294:	21000044 	addi	r4,r4,1
  20d298:	29400044 	addi	r5,r5,1
  20d29c:	003ff706 	br	20d27c <_gp+0xffff71e4>
  20d2a0:	0005883a 	mov	r2,zero
  20d2a4:	f800283a 	ret

0020d2a8 <memcpy>:
  20d2a8:	2005883a 	mov	r2,r4
  20d2ac:	2007883a 	mov	r3,r4
  20d2b0:	218d883a 	add	r6,r4,r6
  20d2b4:	19800526 	beq	r3,r6,20d2cc <memcpy+0x24>
  20d2b8:	29000003 	ldbu	r4,0(r5)
  20d2bc:	18c00044 	addi	r3,r3,1
  20d2c0:	29400044 	addi	r5,r5,1
  20d2c4:	193fffc5 	stb	r4,-1(r3)
  20d2c8:	003ffa06 	br	20d2b4 <_gp+0xffff721c>
  20d2cc:	f800283a 	ret

0020d2d0 <memset>:
  20d2d0:	2005883a 	mov	r2,r4
  20d2d4:	2007883a 	mov	r3,r4
  20d2d8:	218d883a 	add	r6,r4,r6
  20d2dc:	19800326 	beq	r3,r6,20d2ec <memset+0x1c>
  20d2e0:	19400005 	stb	r5,0(r3)
  20d2e4:	18c00044 	addi	r3,r3,1
  20d2e8:	003ffc06 	br	20d2dc <_gp+0xffff7244>
  20d2ec:	f800283a 	ret

0020d2f0 <strlen>:
  20d2f0:	2005883a 	mov	r2,r4
  20d2f4:	10c00007 	ldb	r3,0(r2)
  20d2f8:	18000226 	beq	r3,zero,20d304 <strlen+0x14>
  20d2fc:	10800044 	addi	r2,r2,1
  20d300:	003ffc06 	br	20d2f4 <_gp+0xffff725c>
  20d304:	1105c83a 	sub	r2,r2,r4
  20d308:	f800283a 	ret

0020d30c <__register_exitproc>:
  20d30c:	00800874 	movhi	r2,33
  20d310:	10b84004 	addi	r2,r2,-7936
  20d314:	10c00017 	ldw	r3,0(r2)
  20d318:	defff904 	addi	sp,sp,-28
  20d31c:	dc000015 	stw	r16,0(sp)
  20d320:	1c000c17 	ldw	r16,48(r3)
  20d324:	dd400515 	stw	r21,20(sp)
  20d328:	dd000415 	stw	r20,16(sp)
  20d32c:	dcc00315 	stw	r19,12(sp)
  20d330:	dc800215 	stw	r18,8(sp)
  20d334:	dc400115 	stw	r17,4(sp)
  20d338:	dfc00615 	stw	ra,24(sp)
  20d33c:	202b883a 	mov	r21,r4
  20d340:	2823883a 	mov	r17,r5
  20d344:	3027883a 	mov	r19,r6
  20d348:	3825883a 	mov	r18,r7
  20d34c:	1029883a 	mov	r20,r2
  20d350:	8000021e 	bne	r16,zero,20d35c <__register_exitproc+0x50>
  20d354:	1c000d04 	addi	r16,r3,52
  20d358:	1c000c15 	stw	r16,48(r3)
  20d35c:	80800117 	ldw	r2,4(r16)
  20d360:	00c007c4 	movi	r3,31
  20d364:	1880110e 	bge	r3,r2,20d3ac <__register_exitproc+0xa0>
  20d368:	00800034 	movhi	r2,0
  20d36c:	10800004 	addi	r2,r2,0
  20d370:	1000021e 	bne	r2,zero,20d37c <__register_exitproc+0x70>
  20d374:	00bfffc4 	movi	r2,-1
  20d378:	00003106 	br	20d440 <__register_exitproc+0x134>
  20d37c:	01002304 	movi	r4,140
  20d380:	00000000 	call	0 <__alt_mem_sram_cntrlr_0>
  20d384:	1021883a 	mov	r16,r2
  20d388:	103ffa26 	beq	r2,zero,20d374 <_gp+0xffff72dc>
  20d38c:	10000115 	stw	zero,4(r2)
  20d390:	a0800017 	ldw	r2,0(r20)
  20d394:	10c00c17 	ldw	r3,48(r2)
  20d398:	80c00015 	stw	r3,0(r16)
  20d39c:	14000c15 	stw	r16,48(r2)
  20d3a0:	80002215 	stw	zero,136(r16)
  20d3a4:	a8001d26 	beq	r21,zero,20d41c <__register_exitproc+0x110>
  20d3a8:	00000606 	br	20d3c4 <__register_exitproc+0xb8>
  20d3ac:	a8001b26 	beq	r21,zero,20d41c <__register_exitproc+0x110>
  20d3b0:	80802217 	ldw	r2,136(r16)
  20d3b4:	1000091e 	bne	r2,zero,20d3dc <__register_exitproc+0xd0>
  20d3b8:	00800034 	movhi	r2,0
  20d3bc:	10800004 	addi	r2,r2,0
  20d3c0:	103fec26 	beq	r2,zero,20d374 <_gp+0xffff72dc>
  20d3c4:	01004204 	movi	r4,264
  20d3c8:	00000000 	call	0 <__alt_mem_sram_cntrlr_0>
  20d3cc:	103fe926 	beq	r2,zero,20d374 <_gp+0xffff72dc>
  20d3d0:	10004015 	stw	zero,256(r2)
  20d3d4:	10004115 	stw	zero,260(r2)
  20d3d8:	80802215 	stw	r2,136(r16)
  20d3dc:	81400117 	ldw	r5,4(r16)
  20d3e0:	01000044 	movi	r4,1
  20d3e4:	2947883a 	add	r3,r5,r5
  20d3e8:	18c7883a 	add	r3,r3,r3
  20d3ec:	10c7883a 	add	r3,r2,r3
  20d3f0:	1cc00015 	stw	r19,0(r3)
  20d3f4:	2148983a 	sll	r4,r4,r5
  20d3f8:	11404017 	ldw	r5,256(r2)
  20d3fc:	290ab03a 	or	r5,r5,r4
  20d400:	11404015 	stw	r5,256(r2)
  20d404:	1c802015 	stw	r18,128(r3)
  20d408:	00c00084 	movi	r3,2
  20d40c:	a8c0031e 	bne	r21,r3,20d41c <__register_exitproc+0x110>
  20d410:	10c04117 	ldw	r3,260(r2)
  20d414:	1908b03a 	or	r4,r3,r4
  20d418:	11004115 	stw	r4,260(r2)
  20d41c:	80800117 	ldw	r2,4(r16)
  20d420:	10c00044 	addi	r3,r2,1
  20d424:	10800084 	addi	r2,r2,2
  20d428:	1085883a 	add	r2,r2,r2
  20d42c:	1085883a 	add	r2,r2,r2
  20d430:	80c00115 	stw	r3,4(r16)
  20d434:	80a1883a 	add	r16,r16,r2
  20d438:	84400015 	stw	r17,0(r16)
  20d43c:	0005883a 	mov	r2,zero
  20d440:	dfc00617 	ldw	ra,24(sp)
  20d444:	dd400517 	ldw	r21,20(sp)
  20d448:	dd000417 	ldw	r20,16(sp)
  20d44c:	dcc00317 	ldw	r19,12(sp)
  20d450:	dc800217 	ldw	r18,8(sp)
  20d454:	dc400117 	ldw	r17,4(sp)
  20d458:	dc000017 	ldw	r16,0(sp)
  20d45c:	dec00704 	addi	sp,sp,28
  20d460:	f800283a 	ret

0020d464 <__call_exitprocs>:
  20d464:	defff504 	addi	sp,sp,-44
  20d468:	dd000515 	stw	r20,20(sp)
  20d46c:	05000874 	movhi	r20,33
  20d470:	dc800315 	stw	r18,12(sp)
  20d474:	dfc00a15 	stw	ra,40(sp)
  20d478:	df000915 	stw	fp,36(sp)
  20d47c:	ddc00815 	stw	r23,32(sp)
  20d480:	dd800715 	stw	r22,28(sp)
  20d484:	dd400615 	stw	r21,24(sp)
  20d488:	dcc00415 	stw	r19,16(sp)
  20d48c:	dc400215 	stw	r17,8(sp)
  20d490:	dc000115 	stw	r16,4(sp)
  20d494:	d9000015 	stw	r4,0(sp)
  20d498:	2825883a 	mov	r18,r5
  20d49c:	a5384004 	addi	r20,r20,-7936
  20d4a0:	a4400017 	ldw	r17,0(r20)
  20d4a4:	8cc00c17 	ldw	r19,48(r17)
  20d4a8:	8c400c04 	addi	r17,r17,48
  20d4ac:	98004526 	beq	r19,zero,20d5c4 <__call_exitprocs+0x160>
  20d4b0:	9c000117 	ldw	r16,4(r19)
  20d4b4:	00900034 	movhi	r2,16384
  20d4b8:	10bfffc4 	addi	r2,r2,-1
  20d4bc:	9d402217 	ldw	r21,136(r19)
  20d4c0:	85bfffc4 	addi	r22,r16,-1
  20d4c4:	80a1883a 	add	r16,r16,r2
  20d4c8:	8421883a 	add	r16,r16,r16
  20d4cc:	8421883a 	add	r16,r16,r16
  20d4d0:	ac2f883a 	add	r23,r21,r16
  20d4d4:	84000204 	addi	r16,r16,8
  20d4d8:	9c21883a 	add	r16,r19,r16
  20d4dc:	b0002716 	blt	r22,zero,20d57c <__call_exitprocs+0x118>
  20d4e0:	90000726 	beq	r18,zero,20d500 <__call_exitprocs+0x9c>
  20d4e4:	a800041e 	bne	r21,zero,20d4f8 <__call_exitprocs+0x94>
  20d4e8:	b5bfffc4 	addi	r22,r22,-1
  20d4ec:	bdffff04 	addi	r23,r23,-4
  20d4f0:	843fff04 	addi	r16,r16,-4
  20d4f4:	003ff906 	br	20d4dc <_gp+0xffff7444>
  20d4f8:	b9002017 	ldw	r4,128(r23)
  20d4fc:	913ffa1e 	bne	r18,r4,20d4e8 <_gp+0xffff7450>
  20d500:	99000117 	ldw	r4,4(r19)
  20d504:	82000017 	ldw	r8,0(r16)
  20d508:	213fffc4 	addi	r4,r4,-1
  20d50c:	b100021e 	bne	r22,r4,20d518 <__call_exitprocs+0xb4>
  20d510:	9d800115 	stw	r22,4(r19)
  20d514:	00000106 	br	20d51c <__call_exitprocs+0xb8>
  20d518:	80000015 	stw	zero,0(r16)
  20d51c:	403ff226 	beq	r8,zero,20d4e8 <_gp+0xffff7450>
  20d520:	9f000117 	ldw	fp,4(r19)
  20d524:	a8000526 	beq	r21,zero,20d53c <__call_exitprocs+0xd8>
  20d528:	00800044 	movi	r2,1
  20d52c:	1592983a 	sll	r9,r2,r22
  20d530:	a9404017 	ldw	r5,256(r21)
  20d534:	494a703a 	and	r5,r9,r5
  20d538:	2800021e 	bne	r5,zero,20d544 <__call_exitprocs+0xe0>
  20d53c:	403ee83a 	callr	r8
  20d540:	00000906 	br	20d568 <__call_exitprocs+0x104>
  20d544:	a9004117 	ldw	r4,260(r21)
  20d548:	4908703a 	and	r4,r9,r4
  20d54c:	2000041e 	bne	r4,zero,20d560 <__call_exitprocs+0xfc>
  20d550:	b9400017 	ldw	r5,0(r23)
  20d554:	d9000017 	ldw	r4,0(sp)
  20d558:	403ee83a 	callr	r8
  20d55c:	00000206 	br	20d568 <__call_exitprocs+0x104>
  20d560:	b9000017 	ldw	r4,0(r23)
  20d564:	403ee83a 	callr	r8
  20d568:	99000117 	ldw	r4,4(r19)
  20d56c:	e13fcc1e 	bne	fp,r4,20d4a0 <_gp+0xffff7408>
  20d570:	89000017 	ldw	r4,0(r17)
  20d574:	993fdc26 	beq	r19,r4,20d4e8 <_gp+0xffff7450>
  20d578:	003fc906 	br	20d4a0 <_gp+0xffff7408>
  20d57c:	00800034 	movhi	r2,0
  20d580:	10800004 	addi	r2,r2,0
  20d584:	10000f26 	beq	r2,zero,20d5c4 <__call_exitprocs+0x160>
  20d588:	99400117 	ldw	r5,4(r19)
  20d58c:	99000017 	ldw	r4,0(r19)
  20d590:	2800091e 	bne	r5,zero,20d5b8 <__call_exitprocs+0x154>
  20d594:	20000826 	beq	r4,zero,20d5b8 <__call_exitprocs+0x154>
  20d598:	89000015 	stw	r4,0(r17)
  20d59c:	a8000226 	beq	r21,zero,20d5a8 <__call_exitprocs+0x144>
  20d5a0:	a809883a 	mov	r4,r21
  20d5a4:	00000000 	call	0 <__alt_mem_sram_cntrlr_0>
  20d5a8:	9809883a 	mov	r4,r19
  20d5ac:	00000000 	call	0 <__alt_mem_sram_cntrlr_0>
  20d5b0:	8cc00017 	ldw	r19,0(r17)
  20d5b4:	003fbd06 	br	20d4ac <_gp+0xffff7414>
  20d5b8:	9823883a 	mov	r17,r19
  20d5bc:	2027883a 	mov	r19,r4
  20d5c0:	003fba06 	br	20d4ac <_gp+0xffff7414>
  20d5c4:	dfc00a17 	ldw	ra,40(sp)
  20d5c8:	df000917 	ldw	fp,36(sp)
  20d5cc:	ddc00817 	ldw	r23,32(sp)
  20d5d0:	dd800717 	ldw	r22,28(sp)
  20d5d4:	dd400617 	ldw	r21,24(sp)
  20d5d8:	dd000517 	ldw	r20,20(sp)
  20d5dc:	dcc00417 	ldw	r19,16(sp)
  20d5e0:	dc800317 	ldw	r18,12(sp)
  20d5e4:	dc400217 	ldw	r17,8(sp)
  20d5e8:	dc000117 	ldw	r16,4(sp)
  20d5ec:	dec00b04 	addi	sp,sp,44
  20d5f0:	f800283a 	ret

0020d5f4 <__divsi3>:
  20d5f4:	20001b16 	blt	r4,zero,20d664 <__divsi3+0x70>
  20d5f8:	000f883a 	mov	r7,zero
  20d5fc:	28001616 	blt	r5,zero,20d658 <__divsi3+0x64>
  20d600:	200d883a 	mov	r6,r4
  20d604:	29001a2e 	bgeu	r5,r4,20d670 <__divsi3+0x7c>
  20d608:	00800804 	movi	r2,32
  20d60c:	00c00044 	movi	r3,1
  20d610:	00000106 	br	20d618 <__divsi3+0x24>
  20d614:	10000d26 	beq	r2,zero,20d64c <__divsi3+0x58>
  20d618:	294b883a 	add	r5,r5,r5
  20d61c:	10bfffc4 	addi	r2,r2,-1
  20d620:	18c7883a 	add	r3,r3,r3
  20d624:	293ffb36 	bltu	r5,r4,20d614 <_gp+0xffff757c>
  20d628:	0005883a 	mov	r2,zero
  20d62c:	18000726 	beq	r3,zero,20d64c <__divsi3+0x58>
  20d630:	0005883a 	mov	r2,zero
  20d634:	31400236 	bltu	r6,r5,20d640 <__divsi3+0x4c>
  20d638:	314dc83a 	sub	r6,r6,r5
  20d63c:	10c4b03a 	or	r2,r2,r3
  20d640:	1806d07a 	srli	r3,r3,1
  20d644:	280ad07a 	srli	r5,r5,1
  20d648:	183ffa1e 	bne	r3,zero,20d634 <_gp+0xffff759c>
  20d64c:	38000126 	beq	r7,zero,20d654 <__divsi3+0x60>
  20d650:	0085c83a 	sub	r2,zero,r2
  20d654:	f800283a 	ret
  20d658:	014bc83a 	sub	r5,zero,r5
  20d65c:	39c0005c 	xori	r7,r7,1
  20d660:	003fe706 	br	20d600 <_gp+0xffff7568>
  20d664:	0109c83a 	sub	r4,zero,r4
  20d668:	01c00044 	movi	r7,1
  20d66c:	003fe306 	br	20d5fc <_gp+0xffff7564>
  20d670:	00c00044 	movi	r3,1
  20d674:	003fee06 	br	20d630 <_gp+0xffff7598>

0020d678 <__modsi3>:
  20d678:	20001716 	blt	r4,zero,20d6d8 <__modsi3+0x60>
  20d67c:	000f883a 	mov	r7,zero
  20d680:	2005883a 	mov	r2,r4
  20d684:	28001216 	blt	r5,zero,20d6d0 <__modsi3+0x58>
  20d688:	2900162e 	bgeu	r5,r4,20d6e4 <__modsi3+0x6c>
  20d68c:	01800804 	movi	r6,32
  20d690:	00c00044 	movi	r3,1
  20d694:	00000106 	br	20d69c <__modsi3+0x24>
  20d698:	30000a26 	beq	r6,zero,20d6c4 <__modsi3+0x4c>
  20d69c:	294b883a 	add	r5,r5,r5
  20d6a0:	31bfffc4 	addi	r6,r6,-1
  20d6a4:	18c7883a 	add	r3,r3,r3
  20d6a8:	293ffb36 	bltu	r5,r4,20d698 <_gp+0xffff7600>
  20d6ac:	18000526 	beq	r3,zero,20d6c4 <__modsi3+0x4c>
  20d6b0:	1806d07a 	srli	r3,r3,1
  20d6b4:	11400136 	bltu	r2,r5,20d6bc <__modsi3+0x44>
  20d6b8:	1145c83a 	sub	r2,r2,r5
  20d6bc:	280ad07a 	srli	r5,r5,1
  20d6c0:	183ffb1e 	bne	r3,zero,20d6b0 <_gp+0xffff7618>
  20d6c4:	38000126 	beq	r7,zero,20d6cc <__modsi3+0x54>
  20d6c8:	0085c83a 	sub	r2,zero,r2
  20d6cc:	f800283a 	ret
  20d6d0:	014bc83a 	sub	r5,zero,r5
  20d6d4:	003fec06 	br	20d688 <_gp+0xffff75f0>
  20d6d8:	0109c83a 	sub	r4,zero,r4
  20d6dc:	01c00044 	movi	r7,1
  20d6e0:	003fe706 	br	20d680 <_gp+0xffff75e8>
  20d6e4:	00c00044 	movi	r3,1
  20d6e8:	003ff106 	br	20d6b0 <_gp+0xffff7618>

0020d6ec <__udivsi3>:
  20d6ec:	200d883a 	mov	r6,r4
  20d6f0:	2900152e 	bgeu	r5,r4,20d748 <__udivsi3+0x5c>
  20d6f4:	28001416 	blt	r5,zero,20d748 <__udivsi3+0x5c>
  20d6f8:	00800804 	movi	r2,32
  20d6fc:	00c00044 	movi	r3,1
  20d700:	00000206 	br	20d70c <__udivsi3+0x20>
  20d704:	10000e26 	beq	r2,zero,20d740 <__udivsi3+0x54>
  20d708:	28000516 	blt	r5,zero,20d720 <__udivsi3+0x34>
  20d70c:	294b883a 	add	r5,r5,r5
  20d710:	10bfffc4 	addi	r2,r2,-1
  20d714:	18c7883a 	add	r3,r3,r3
  20d718:	293ffa36 	bltu	r5,r4,20d704 <_gp+0xffff766c>
  20d71c:	18000826 	beq	r3,zero,20d740 <__udivsi3+0x54>
  20d720:	0005883a 	mov	r2,zero
  20d724:	31400236 	bltu	r6,r5,20d730 <__udivsi3+0x44>
  20d728:	314dc83a 	sub	r6,r6,r5
  20d72c:	10c4b03a 	or	r2,r2,r3
  20d730:	1806d07a 	srli	r3,r3,1
  20d734:	280ad07a 	srli	r5,r5,1
  20d738:	183ffa1e 	bne	r3,zero,20d724 <_gp+0xffff768c>
  20d73c:	f800283a 	ret
  20d740:	0005883a 	mov	r2,zero
  20d744:	f800283a 	ret
  20d748:	00c00044 	movi	r3,1
  20d74c:	003ff406 	br	20d720 <_gp+0xffff7688>

0020d750 <__umodsi3>:
  20d750:	2005883a 	mov	r2,r4
  20d754:	2900122e 	bgeu	r5,r4,20d7a0 <__umodsi3+0x50>
  20d758:	28001116 	blt	r5,zero,20d7a0 <__umodsi3+0x50>
  20d75c:	01800804 	movi	r6,32
  20d760:	00c00044 	movi	r3,1
  20d764:	00000206 	br	20d770 <__umodsi3+0x20>
  20d768:	30000c26 	beq	r6,zero,20d79c <__umodsi3+0x4c>
  20d76c:	28000516 	blt	r5,zero,20d784 <__umodsi3+0x34>
  20d770:	294b883a 	add	r5,r5,r5
  20d774:	31bfffc4 	addi	r6,r6,-1
  20d778:	18c7883a 	add	r3,r3,r3
  20d77c:	293ffa36 	bltu	r5,r4,20d768 <_gp+0xffff76d0>
  20d780:	18000626 	beq	r3,zero,20d79c <__umodsi3+0x4c>
  20d784:	1806d07a 	srli	r3,r3,1
  20d788:	11400136 	bltu	r2,r5,20d790 <__umodsi3+0x40>
  20d78c:	1145c83a 	sub	r2,r2,r5
  20d790:	280ad07a 	srli	r5,r5,1
  20d794:	183ffb1e 	bne	r3,zero,20d784 <_gp+0xffff76ec>
  20d798:	f800283a 	ret
  20d79c:	f800283a 	ret
  20d7a0:	00c00044 	movi	r3,1
  20d7a4:	003ff706 	br	20d784 <_gp+0xffff76ec>

0020d7a8 <__mulsi3>:
  20d7a8:	0005883a 	mov	r2,zero
  20d7ac:	20000726 	beq	r4,zero,20d7cc <__mulsi3+0x24>
  20d7b0:	20c0004c 	andi	r3,r4,1
  20d7b4:	2008d07a 	srli	r4,r4,1
  20d7b8:	18000126 	beq	r3,zero,20d7c0 <__mulsi3+0x18>
  20d7bc:	1145883a 	add	r2,r2,r5
  20d7c0:	294b883a 	add	r5,r5,r5
  20d7c4:	203ffa1e 	bne	r4,zero,20d7b0 <_gp+0xffff7718>
  20d7c8:	f800283a 	ret
  20d7cc:	f800283a 	ret

0020d7d0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  20d7d0:	defffd04 	addi	sp,sp,-12
  20d7d4:	df000215 	stw	fp,8(sp)
  20d7d8:	df000204 	addi	fp,sp,8
  20d7dc:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  20d7e0:	0001883a 	nop
  20d7e4:	e0bfff17 	ldw	r2,-4(fp)
  20d7e8:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  20d7ec:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  20d7f0:	10000226 	beq	r2,zero,20d7fc <_exit+0x2c>
    ALT_SIM_FAIL();
  20d7f4:	002af070 	cmpltui	zero,zero,43969
  20d7f8:	00000106 	br	20d800 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  20d7fc:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  20d800:	003fff06 	br	20d800 <_gp+0xffff7768>
